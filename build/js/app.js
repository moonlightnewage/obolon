/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "js/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {\"use strict\";\n\nvar _jquery = __webpack_require__(1);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\n__webpack_require__(6);\n\n__webpack_require__(7);\n\n__webpack_require__(8);\n\nvar _Dropdown = __webpack_require__(2);\n\nvar _Dropdown2 = _interopRequireDefault(_Dropdown);\n\nvar _Popup = __webpack_require__(3);\n\nvar _Popup2 = _interopRequireDefault(_Popup);\n\nvar _Tabs = __webpack_require__(4);\n\nvar _Tabs2 = _interopRequireDefault(_Tabs);\n\nvar _modal = __webpack_require__(5);\n\nvar _modal2 = _interopRequireDefault(_modal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.$ = _jquery2.default;\n__webpack_provided_window_dot_jQuery = _jquery2.default;\n\n(0, _jquery2.default)(document).ready(function () {\n    if ((0, _jquery2.default)(window).width() < 768) {\n        new _Dropdown2.default({ btn: \".js-btn-burger\", list: \".js-dropdown-list\" });\n    }\n\n    new _Popup2.default({ el: \".js-popup-open\" });\n\n    new _Tabs2.default({ section: 2, rooms: 4, type: 1 });\n\n    (0, _modal2.default)();\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvYXBwLmpzPzcxNmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQgZnJvbSBcImpxdWVyeVwiO1xuaW1wb3J0IGpRdWVyeSBmcm9tIFwianF1ZXJ5XCI7XG53aW5kb3cuJCA9ICQ7XG53aW5kb3cualF1ZXJ5ID0galF1ZXJ5O1xuXG5pbXBvcnQgXCJvd2wuY2Fyb3VzZWxcIjtcbmltcG9ydCBcIi4vbGliL2pxdWVyeS52YWxpZGF0ZS5taW4uanNcIjtcblxuaW1wb3J0IFwiLi9zbGlkZXIuanNcIjtcbmltcG9ydCBEcm9wZG93biBmcm9tIFwiLi9Ecm9wZG93blwiO1xuaW1wb3J0IFBvcHVwIGZyb20gXCIuL1BvcHVwXCI7XG5pbXBvcnQgVGFicyBmcm9tIFwiLi9UYWJzXCI7XG5pbXBvcnQgbW9kYWwgZnJvbSBcIi4vbW9kYWwuanNcIjtcblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCQod2luZG93KS53aWR0aCgpIDwgNzY4KSB7XG4gICAgICAgIG5ldyBEcm9wZG93bih7IGJ0bjogXCIuanMtYnRuLWJ1cmdlclwiLCBsaXN0OiBcIi5qcy1kcm9wZG93bi1saXN0XCIgfSk7XG4gICAgfVxuXG4gICAgbmV3IFBvcHVwKHsgZWw6IFwiLmpzLXBvcHVwLW9wZW5cIiB9KTtcblxuICAgIG5ldyBUYWJzKHsgc2VjdGlvbjogMiwgcm9vbXM6IDQsIHR5cGU6IDEgfSk7XG5cblxuICAgIG1vZGFsKCk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvanMvYXBwLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBWEE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.1.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-09-22T22:30Z\n */\n(function(global, factory) {\n    \"use strict\";\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        // For CommonJS and CommonJS-like environments where a proper `window`\n        // is present, execute the factory and get jQuery.\n        // For environments that do not have a `window` with a `document`\n        // (such as Node.js), expose a factory as module.exports.\n        // This accentuates the need for the creation of a real `window`.\n        // e.g. var jQuery = require(\"jquery\")(window);\n        // See ticket #14549 for more info.\n        module.exports = global.document\n            ? factory(global, true)\n            : (function(w) {\n                if (!w.document) {\n                    throw new Error(\"jQuery requires a window with a document\");\n                }\n                return factory(w);\n            });\n    } else {\n        factory(global);\n    }\n    // Pass this if window is not defined yet\n})(typeof window !== \"undefined\" ? window : this, function(window, noGlobal) {\n    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n    // enough that all such attempts are guarded in a try block.\n    \"use strict\";\n    var arr = [];\n\n    var document = window.document;\n\n    var getProto = Object.getPrototypeOf;\n\n    var slice = arr.slice;\n\n    var concat = arr.concat;\n\n    var push = arr.push;\n\n    var indexOf = arr.indexOf;\n\n    var class2type = {};\n\n    var toString = class2type.toString;\n\n    var hasOwn = class2type.hasOwnProperty;\n\n    var fnToString = hasOwn.toString;\n\n    var ObjectFunctionString = fnToString.call(Object);\n\n    var support = {};\n\n    function DOMEval(code, doc) {\n        doc = doc || document;\n\n        var script = doc.createElement(\"script\");\n\n        script.text = code;\n        doc.head.appendChild(script).parentNode.removeChild(script);\n    }\n    /* global Symbol */\n    // Defining this global in .eslintrc.json would create a danger of using the global\n    // unguarded in another place, it seems safer to define global only for this module\n    var version = \"3.1.1\",\n        // Define a local copy of jQuery\n        jQuery = function(selector, context) {\n            // The jQuery object is actually just the init constructor 'enhanced'\n            // Need init if jQuery is called (just allow error to be thrown if not included)\n            return new jQuery.fn.init(selector, context);\n        },\n        // Support: Android <=4.0 only\n        // Make sure we trim BOM and NBSP\n        rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n        // Matches dashed string for camelizing\n        rmsPrefix = /^-ms-/,\n        rdashAlpha = /-([a-z])/g,\n        // Used by jQuery.camelCase as callback to replace()\n        fcamelCase = function(all, letter) {\n            return letter.toUpperCase();\n        };\n\n    jQuery.fn = jQuery.prototype = {\n        // The current version of jQuery being used\n        jquery: version,\n        constructor: jQuery,\n        // The default length of a jQuery object is 0\n        length: 0,\n        toArray: function() {\n            return slice.call(this);\n        },\n        // Get the Nth element in the matched element set OR\n        // Get the whole matched element set as a clean array\n        get: function(num) {\n            // Return all the elements in a clean array\n            if (num == null) {\n                return slice.call(this);\n            }\n\n            // Return just the one element from the set\n            return num < 0 ? this[num + this.length] : this[num];\n        },\n        // Take an array of elements and push it onto the stack\n        // (returning the new matched element set)\n        pushStack: function(elems) {\n            // Build a new jQuery matched element set\n            var ret = jQuery.merge(this.constructor(), elems);\n\n            // Add the old object onto the stack (as a reference)\n            ret.prevObject = this;\n\n            // Return the newly-formed element set\n            return ret;\n        },\n        // Execute a callback for every element in the matched set.\n        each: function(callback) {\n            return jQuery.each(this, callback);\n        },\n        map: function(callback) {\n            return this.pushStack(\n                jQuery.map(this, function(elem, i) {\n                    return callback.call(elem, i, elem);\n                })\n            );\n        },\n        slice: function() {\n            return this.pushStack(slice.apply(this, arguments));\n        },\n        first: function() {\n            return this.eq(0);\n        },\n        last: function() {\n            return this.eq(-1);\n        },\n        eq: function(i) {\n            var len = this.length, j = +i + (i < 0 ? len : 0);\n            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);\n        },\n        end: function() {\n            return this.prevObject || this.constructor();\n        },\n        // For internal use only.\n        // Behaves like an Array's method, not like a jQuery method.\n        push: push,\n        sort: arr.sort,\n        splice: arr.splice\n    };\n\n    jQuery.extend = jQuery.fn.extend = function() {\n        var options,\n            name,\n            src,\n            copy,\n            copyIsArray,\n            clone,\n            target = arguments[0] || {},\n            i = 1,\n            length = arguments.length,\n            deep = false;\n\n        // Handle a deep copy situation\n        if (typeof target === \"boolean\") {\n            deep = target;\n\n            // Skip the boolean and the target\n            target = arguments[i] || {};\n            i++;\n        }\n\n        // Handle case when target is a string or something (possible in deep copy)\n        if (typeof target !== \"object\" && !jQuery.isFunction(target)) {\n            target = {};\n        }\n\n        // Extend jQuery itself if only one argument is passed\n        if (i === length) {\n            target = this;\n            i--;\n        }\n\n        for (; i < length; i++) {\n            // Only deal with non-null/undefined values\n            if ((options = arguments[i]) != null) {\n                // Extend the base object\n                for (name in options) {\n                    src = target[name];\n                    copy = options[name];\n\n                    // Prevent never-ending loop\n                    if (target === copy) {\n                        continue;\n                    }\n\n                    // Recurse if we're merging plain objects or arrays\n                    if (\n                        deep &&\n                            copy &&\n                            (jQuery.isPlainObject(copy) ||\n                                (copyIsArray = jQuery.isArray(copy)))\n                    ) {\n                        if (copyIsArray) {\n                            copyIsArray = false;\n                            clone = src && jQuery.isArray(src) ? src : [];\n                        } else {\n                            clone = src && jQuery.isPlainObject(src) ? src : {};\n                        }\n\n                        // Never move original objects, clone them\n                        target[name] = jQuery.extend(deep, clone, copy);\n                        // Don't bring in undefined values\n                    } else if (copy !== undefined) {\n                        target[name] = copy;\n                    }\n                }\n            }\n        }\n\n        // Return the modified object\n        return target;\n    };\n\n    jQuery.extend({\n        // Unique for each copy of jQuery on the page\n        expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n        // Assume jQuery is ready without the ready module\n        isReady: true,\n        error: function(msg) {\n            throw new Error(msg);\n        },\n        noop: function() {\n        },\n        isFunction: function(obj) {\n            return jQuery.type(obj) === \"function\";\n        },\n        isArray: Array.isArray,\n        isWindow: function(obj) {\n            return obj != null && obj === obj.window;\n        },\n        isNumeric: function(obj) {\n            // As of jQuery 3.0, isNumeric is limited to\n            // strings and numbers (primitives or objects)\n            // that can be coerced to finite numbers (gh-2662)\n            var type = jQuery.type(obj);\n            return (type === \"number\" || type === \"string\") &&\n                // parseFloat NaNs numeric-cast false positives (\"\")\n                // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n                // subtraction forces infinities to NaN\n                !isNaN(obj - parseFloat(obj));\n        },\n        isPlainObject: function(obj) {\n            var proto, Ctor;\n\n            // Detect obvious negatives\n            // Use toString instead of jQuery.type to catch host objects\n            if (!obj || toString.call(obj) !== \"[object Object]\") {\n                return false;\n            }\n\n            proto = getProto(obj);\n\n            // Objects with no prototype (e.g., `Object.create( null )`) are plain\n            if (!proto) {\n                return true;\n            }\n\n            // Objects with prototype are plain iff they were constructed by a global Object function\n            Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n            return typeof Ctor === \"function\" &&\n                fnToString.call(Ctor) === ObjectFunctionString;\n        },\n        isEmptyObject: function(obj) {\n            /* eslint-disable no-unused-vars */\n            // See https://github.com/eslint/eslint/issues/6125\n            var name;\n\n            for (name in obj) {\n                return false;\n            }\n            return true;\n        },\n        type: function(obj) {\n            if (obj == null) {\n                return obj + \"\";\n            }\n\n            // Support: Android <=2.3 only (functionish RegExp)\n            return typeof obj === \"object\" || typeof obj === \"function\"\n                ? class2type[toString.call(obj)] || \"object\"\n                : typeof obj;\n        },\n        // Evaluates a script in a global context\n        globalEval: function(code) {\n            DOMEval(code);\n        },\n        // Convert dashed to camelCase; used by the css and data modules\n        // Support: IE <=9 - 11, Edge 12 - 13\n        // Microsoft forgot to hump their vendor prefix (#9572)\n        camelCase: function(string) {\n            return string\n                .replace(rmsPrefix, \"ms-\")\n                .replace(rdashAlpha, fcamelCase);\n        },\n        nodeName: function(elem, name) {\n            return elem.nodeName &&\n                elem.nodeName.toLowerCase() === name.toLowerCase();\n        },\n        each: function(obj, callback) {\n            var length, i = 0;\n\n            if (isArrayLike(obj)) {\n                length = obj.length;\n                for (; i < length; i++) {\n                    if (callback.call(obj[i], i, obj[i]) === false) {\n                        break;\n                    }\n                }\n            } else {\n                for (i in obj) {\n                    if (callback.call(obj[i], i, obj[i]) === false) {\n                        break;\n                    }\n                }\n            }\n\n            return obj;\n        },\n        // Support: Android <=4.0 only\n        trim: function(text) {\n            return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n        },\n        // results is for internal usage only\n        makeArray: function(arr, results) {\n            var ret = results || [];\n\n            if (arr != null) {\n                if (isArrayLike(Object(arr))) {\n                    jQuery.merge(ret, typeof arr === \"string\" ? [ arr ] : arr);\n                } else {\n                    push.call(ret, arr);\n                }\n            }\n\n            return ret;\n        },\n        inArray: function(elem, arr, i) {\n            return arr == null ? -1 : indexOf.call(arr, elem, i);\n        },\n        // Support: Android <=4.0 only, PhantomJS 1 only\n        // push.apply(_, arraylike) throws on ancient WebKit\n        merge: function(first, second) {\n            var len = +second.length, j = 0, i = first.length;\n\n            for (; j < len; j++) {\n                first[i++] = second[j];\n            }\n\n            first.length = i;\n\n            return first;\n        },\n        grep: function(elems, callback, invert) {\n            var callbackInverse,\n                matches = [],\n                i = 0,\n                length = elems.length,\n                callbackExpect = !invert;\n\n            // Go through the array, only saving the items\n            // that pass the validator function\n            for (; i < length; i++) {\n                callbackInverse = !callback(elems[i], i);\n                if (callbackInverse !== callbackExpect) {\n                    matches.push(elems[i]);\n                }\n            }\n\n            return matches;\n        },\n        // arg is for internal usage only\n        map: function(elems, callback, arg) {\n            var length, value, i = 0, ret = [];\n\n            // Go through the array, translating each of the items to their new values\n            if (isArrayLike(elems)) {\n                length = elems.length;\n                for (; i < length; i++) {\n                    value = callback(elems[i], i, arg);\n\n                    if (value != null) {\n                        ret.push(value);\n                    }\n                }\n                // Go through every key on the object,\n            } else {\n                for (i in elems) {\n                    value = callback(elems[i], i, arg);\n\n                    if (value != null) {\n                        ret.push(value);\n                    }\n                }\n            }\n\n            // Flatten any nested arrays\n            return concat.apply([], ret);\n        },\n        // A global GUID counter for objects\n        guid: 1,\n        // Bind a function to a context, optionally partially applying any\n        // arguments.\n        proxy: function(fn, context) {\n            var tmp, args, proxy;\n\n            if (typeof context === \"string\") {\n                tmp = fn[context];\n                context = fn;\n                fn = tmp;\n            }\n\n            // Quick check to determine if target is callable, in the spec\n            // this throws a TypeError, but we will just return undefined.\n            if (!jQuery.isFunction(fn)) {\n                return undefined;\n            }\n\n            // Simulated bind\n            args = slice.call(arguments, 2);\n            proxy = function() {\n                return fn.apply(\n                    context || this,\n                    args.concat(slice.call(arguments))\n                );\n            };\n\n            // Set the guid of unique handler to the same of original handler, so it can be removed\n            proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n            return proxy;\n        },\n        now: Date.now,\n        // jQuery.support is not used in Core but other projects attach their\n        // properties to it so it needs to exist.\n        support: support\n    });\n\n    if (typeof Symbol === \"function\") {\n        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n    }\n\n    // Populate the class2type map\n    jQuery.each(\n        \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\n            \" \"\n        ),\n        function(i, name) {\n            class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n        }\n    );\n\n    function isArrayLike(obj) {\n        // Support: real iOS 8.2 only (not reproducible in simulator)\n        // `in` check used to prevent JIT error (gh-2145)\n        // hasOwn isn't used here due to false negatives\n        // regarding Nodelist length in IE\n        var length = !!obj && \"length\" in obj && obj.length,\n            type = jQuery.type(obj);\n\n        if (type === \"function\" || jQuery.isWindow(obj)) {\n            return false;\n        }\n\n        return type === \"array\" ||\n            length === 0 ||\n            typeof length === \"number\" && length > 0 && length - 1 in obj;\n    }\n    var Sizzle = /*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n    (function(window) {\n        var i,\n            support,\n            Expr,\n            getText,\n            isXML,\n            tokenize,\n            compile,\n            select,\n            outermostContext,\n            sortInput,\n            hasDuplicate,\n            // Local document vars\n            setDocument,\n            document,\n            docElem,\n            documentIsHTML,\n            rbuggyQSA,\n            rbuggyMatches,\n            matches,\n            contains,\n            // Instance-specific data\n            expando = \"sizzle\" + 1 * new Date(),\n            preferredDoc = window.document,\n            dirruns = 0,\n            done = 0,\n            classCache = createCache(),\n            tokenCache = createCache(),\n            compilerCache = createCache(),\n            sortOrder = function(a, b) {\n                if (a === b) {\n                    hasDuplicate = true;\n                }\n                return 0;\n            },\n            // Instance methods\n            hasOwn = ({}).hasOwnProperty,\n            arr = [],\n            pop = arr.pop,\n            push_native = arr.push,\n            push = arr.push,\n            slice = arr.slice,\n            // Use a stripped-down indexOf as it's faster than native\n            // https://jsperf.com/thor-indexof-vs-for/5\n            indexOf = function(list, elem) {\n                var i = 0, len = list.length;\n                for (; i < len; i++) {\n                    if (list[i] === elem) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n            booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n            // Regular expressions\n            // http://www.w3.org/TR/css3-selectors/#whitespace\n            whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n            // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n            identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n            attributes = \"\\\\[\" +\n                whitespace +\n                \"*(\" +\n                identifier +\n                \")(?:\" +\n                whitespace +\n                // Operator (capture 2)\n                \"*([*^$|!~]?=)\" +\n                whitespace +\n                // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n                \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" +\n                identifier +\n                \"))|)\" +\n                whitespace +\n                \"*\\\\]\",\n            pseudos = \":(\" +\n                identifier +\n                \")(?:\\\\((\" +\n                // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n                // 1. quoted (capture 3; capture 4 or capture 5)\n                \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n                // 2. simple (capture 6)\n                \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" +\n                attributes +\n                \")*)|\" +\n                // 3. anything else (capture 2)\n                \".*\" +\n                \")\\\\)|)\",\n            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n            rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n            rtrim = new RegExp(\n                \"^\" +\n                    whitespace +\n                    \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n                    whitespace +\n                    \"+$\",\n                \"g\"\n            ),\n            rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n            rcombinators = new RegExp(\n                \"^\" +\n                    whitespace +\n                    \"*([>+~]|\" +\n                    whitespace +\n                    \")\" +\n                    whitespace +\n                    \"*\"\n            ),\n            rattributeQuotes = new RegExp(\n                \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\",\n                \"g\"\n            ),\n            rpseudo = new RegExp(pseudos),\n            ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n            matchExpr = {\n                ID: new RegExp(\"^#(\" + identifier + \")\"),\n                CLASS: new RegExp(\"^\\\\.(\" + identifier + \")\"),\n                TAG: new RegExp(\"^(\" + identifier + \"|[*])\"),\n                ATTR: new RegExp(\"^\" + attributes),\n                PSEUDO: new RegExp(\"^\" + pseudos),\n                CHILD: new RegExp(\n                    \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n                        whitespace +\n                        \"*(even|odd|(([+-]|)(\\\\d*)n|)\" +\n                        whitespace +\n                        \"*(?:([+-]|)\" +\n                        whitespace +\n                        \"*(\\\\d+)|))\" +\n                        whitespace +\n                        \"*\\\\)|)\",\n                    \"i\"\n                ),\n                bool: new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n                // For use in libraries implementing .is()\n                // We use this for POS matching in `select`\n                needsContext: new RegExp(\n                    \"^\" +\n                        whitespace +\n                        \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n                        whitespace +\n                        \"*((?:-\\\\d)?\\\\d*)\" +\n                        whitespace +\n                        \"*\\\\)|)(?=[^-]|$)\",\n                    \"i\"\n                )\n            },\n            rinputs = /^(?:input|select|textarea|button)$/i,\n            rheader = /^h\\d$/i,\n            rnative = /^[^{]+\\{\\s*\\[native \\w/,\n            // Easily-parseable/retrievable ID or TAG or CLASS selectors\n            rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n            rsibling = /[+~]/,\n            // CSS escapes\n            // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n            runescape = new RegExp(\n                \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\",\n                \"ig\"\n            ),\n            funescape = function(_, escaped, escapedWhitespace) {\n                var high = \"0x\" + escaped - 0x10000;\n                // NaN means non-codepoint\n                // Support: Firefox<24\n                // Workaround erroneous numeric interpretation of +\"0x\"\n                return high !== high || escapedWhitespace\n                    ? escaped\n                    : high < 0 ? // BMP codepoint\n                        String.fromCharCode(\n                            high + 0x10000\n                        ) : // Supplemental Plane codepoint (surrogate pair)\n                        String.fromCharCode(\n                            high >> 10 | 0xD800,\n                            high & 0x3FF | 0xDC00\n                        );\n            },\n            // CSS string/identifier serialization\n            // https://drafts.csswg.org/cssom/#common-serializing-idioms\n            rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n            fcssescape = function(ch, asCodePoint) {\n                if (asCodePoint) {\n                    // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n                    if (ch === \"\\0\") {\n                        return \"\\uFFFD\";\n                    }\n\n                    // Control characters and (dependent upon position) numbers get escaped as code points\n                    return ch.slice(0, -1) +\n                        \"\\\\\" +\n                        ch.charCodeAt(ch.length - 1).toString(16) +\n                        \" \";\n                }\n\n                // Other potentially-special ASCII characters get backslash-escaped\n                return \"\\\\\" + ch;\n            },\n            // Used for iframes\n            // See setDocument()\n            // Removing the function wrapper causes a \"Permission Denied\"\n            // error in IE\n            unloadHandler = function() {\n                setDocument();\n            },\n            disabledAncestor = addCombinator(\n                function(elem) {\n                    return elem.disabled === true &&\n                        (\"form\" in elem || \"label\" in elem);\n                },\n                { dir: \"parentNode\", next: \"legend\" }\n            );\n\n        // Optimize for push.apply( _, NodeList )\n        try {\n            push.apply(\n                arr = slice.call(preferredDoc.childNodes),\n                preferredDoc.childNodes\n            );\n            // Support: Android<4.0\n            // Detect silently failing push.apply\n            arr[preferredDoc.childNodes.length].nodeType;\n        } catch (e) {\n            push = {\n                apply: // Leverage slice if possible\n                // Support: IE<9\n                // Otherwise append directly\n                arr.length ? (function(target, els) {\n                        push_native.apply(target, slice.call(els));\n                    }) : (function(target, els) {\n                        var j = target.length, i = 0;\n                        // Can't trust NodeList.length\n                        while (target[j++] = els[i++]) {\n                        }\n                        target.length = j - 1;\n                    })\n            };\n        }\n\n        function Sizzle(selector, context, results, seed) {\n            var m,\n                i,\n                elem,\n                nid,\n                match,\n                groups,\n                newSelector,\n                newContext = context && context.ownerDocument,\n                // nodeType defaults to 9, since context defaults to document\n                nodeType = context ? context.nodeType : 9;\n\n            results = results || [];\n\n            // Return early from calls with invalid selector or context\n            if (\n                typeof selector !== \"string\" ||\n                    !selector ||\n                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11\n            ) {\n                return results;\n            }\n\n            // Try to shortcut find operations (as opposed to filters) in HTML documents\n            if (!seed) {\n                if (\n                    (context\n                        ? context.ownerDocument || context\n                        : preferredDoc) !==\n                        document\n                ) {\n                    setDocument(context);\n                }\n                context = context || document;\n\n                if (documentIsHTML) {\n                    // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n                    // (excepting DocumentFragment context, where the methods don't exist)\n                    if (\n                        nodeType !== 11 && (match = rquickExpr.exec(selector))\n                    ) {\n                        // ID selector\n                        if (m = match[1]) {\n                            // Document context\n                            if (nodeType === 9) {\n                                if (elem = context.getElementById(m)) {\n                                    // Support: IE, Opera, Webkit\n                                    // TODO: identify versions\n                                    // getElementById can match elements by name instead of ID\n                                    if (elem.id === m) {\n                                        results.push(elem);\n                                        return results;\n                                    }\n                                } else {\n                                    return results;\n                                }\n                                // Element context\n                            } else {\n                                // Support: IE, Opera, Webkit\n                                // TODO: identify versions\n                                // getElementById can match elements by name instead of ID\n                                if (\n                                    newContext &&\n                                        (elem = newContext.getElementById(m)) &&\n                                        contains(context, elem) &&\n                                        elem.id === m\n                                ) {\n                                    results.push(elem);\n                                    return results;\n                                }\n                            }\n                            // Type selector\n                        } else if (match[2]) {\n                            push.apply(\n                                results,\n                                context.getElementsByTagName(selector)\n                            );\n                            return results;\n                            // Class selector\n                        } else if (\n                            (m = match[3]) &&\n                                support.getElementsByClassName &&\n                                context.getElementsByClassName\n                        ) {\n                            push.apply(\n                                results,\n                                context.getElementsByClassName(m)\n                            );\n                            return results;\n                        }\n                    }\n\n                    // Take advantage of querySelectorAll\n                    if (\n                        support.qsa &&\n                            !compilerCache[selector + \" \"] &&\n                            (!rbuggyQSA || !rbuggyQSA.test(selector))\n                    ) {\n                        if (nodeType !== 1) {\n                            newContext = context;\n                            newSelector = selector;\n                            // qSA looks outside Element context, which is not what we want\n                            // Thanks to Andrew Dupont for this workaround technique\n                            // Support: IE <=8\n                            // Exclude object elements\n                        } else if (\n                            context.nodeName.toLowerCase() !== \"object\"\n                        ) {\n                            // Capture the context ID, setting it first if necessary\n                            if (nid = context.getAttribute(\"id\")) {\n                                nid = nid.replace(rcssescape, fcssescape);\n                            } else {\n                                context.setAttribute(\"id\", nid = expando);\n                            }\n\n                            // Prefix every selector in the list\n                            groups = tokenize(selector);\n                            i = groups.length;\n                            while (i--) {\n                                groups[i] = \"#\" +\n                                    nid +\n                                    \" \" +\n                                    toSelector(groups[i]);\n                            }\n                            newSelector = groups.join(\",\");\n\n                            // Expand context for sibling selectors\n                            newContext = rsibling.test(selector) &&\n                                testContext(context.parentNode) ||\n                                context;\n                        }\n\n                        if (newSelector) {\n                            try {\n                                push.apply(\n                                    results,\n                                    newContext.querySelectorAll(newSelector)\n                                );\n                                return results;\n                            } catch (qsaError) {\n                            } finally {\n                                if (nid === expando) {\n                                    context.removeAttribute(\"id\");\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // All others\n            return select(\n                selector.replace(rtrim, \"$1\"),\n                context,\n                results,\n                seed\n            );\n        }\n\n        /**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\n        function createCache() {\n            var keys = [];\n\n            function cache(key, value) {\n                // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n                if (keys.push(key + \" \") > Expr.cacheLength) {\n                    // Only keep the most recent entries\n                    delete cache[keys.shift()];\n                }\n                return cache[key + \" \"] = value;\n            }\n            return cache;\n        }\n\n        /**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\n        function markFunction(fn) {\n            fn[expando] = true;\n            return fn;\n        }\n\n        /**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\n        function assert(fn) {\n            var el = document.createElement(\"fieldset\");\n\n            try {\n                return !!fn(el);\n            } catch (e) {\n                return false;\n            } finally {\n                // Remove from its parent by default\n                if (el.parentNode) {\n                    el.parentNode.removeChild(el);\n                }\n                // release memory in IE\n                el = null;\n            }\n        }\n\n        /**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\n        function addHandle(attrs, handler) {\n            var arr = attrs.split(\"|\"), i = arr.length;\n\n            while (i--) {\n                Expr.attrHandle[arr[i]] = handler;\n            }\n        }\n\n        /**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\n        function siblingCheck(a, b) {\n            var cur = b && a,\n                diff = cur &&\n                    a.nodeType === 1 &&\n                    b.nodeType === 1 &&\n                    a.sourceIndex - b.sourceIndex;\n\n            // Use IE sourceIndex if available on both nodes\n            if (diff) {\n                return diff;\n            }\n\n            // Check if b follows a\n            if (cur) {\n                while (cur = cur.nextSibling) {\n                    if (cur === b) {\n                        return -1;\n                    }\n                }\n            }\n\n            return a ? 1 : -1;\n        }\n\n        /**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\n        function createInputPseudo(type) {\n            return function(elem) {\n                var name = elem.nodeName.toLowerCase();\n                return name === \"input\" && elem.type === type;\n            };\n        }\n\n        /**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\n        function createButtonPseudo(type) {\n            return function(elem) {\n                var name = elem.nodeName.toLowerCase();\n                return (name === \"input\" || name === \"button\") &&\n                    elem.type === type;\n            };\n        }\n\n        /**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\n        function createDisabledPseudo(disabled) {\n            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n            return function(elem) {\n                // Only certain elements can match :enabled or :disabled\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n                if (\"form\" in elem) {\n                    // Check for inherited disabledness on relevant non-disabled elements:\n                    // * listed form-associated elements in a disabled fieldset\n                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n                    // * option elements in a disabled optgroup\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n                    // All such elements have a \"form\" property.\n                    if (elem.parentNode && elem.disabled === false) {\n                        // Option elements defer to a parent optgroup if present\n                        if (\"label\" in elem) {\n                            if (\"label\" in elem.parentNode) {\n                                return elem.parentNode.disabled === disabled;\n                            } else {\n                                return elem.disabled === disabled;\n                            }\n                        }\n\n                        // Support: IE 6 - 11\n                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n                        return elem.isDisabled === disabled ||\n                            // Where there is no isDisabled, check manually\n                            /* jshint -W018 */\n                            elem.isDisabled !== !disabled &&\n                                disabledAncestor(elem) === disabled;\n                    }\n\n                    return elem.disabled === disabled;\n                    // Try to winnow out elements that can't be disabled before trusting the disabled property.\n                    // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n                    // even exist on them, let alone have a boolean value.\n                } else if (\"label\" in elem) {\n                    return elem.disabled === disabled;\n                }\n\n                // Remaining elements are neither :enabled nor :disabled\n                return false;\n            };\n        }\n\n        /**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\n        function createPositionalPseudo(fn) {\n            return markFunction(function(argument) {\n                argument = +argument;\n                return markFunction(function(seed, matches) {\n                    var j,\n                        matchIndexes = fn([], seed.length, argument),\n                        i = matchIndexes.length;\n\n                    // Match elements found at the specified indexes\n                    while (i--) {\n                        if (seed[j = matchIndexes[i]]) {\n                            seed[j] = !(matches[j] = seed[j]);\n                        }\n                    }\n                });\n            });\n        }\n\n        /**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\n        function testContext(context) {\n            return context &&\n                typeof context.getElementsByTagName !== \"undefined\" &&\n                context;\n        }\n\n        // Expose support vars for convenience\n        support = Sizzle.support = {};\n\n        /**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\n        isXML = Sizzle.isXML = function(elem) {\n            // documentElement is verified for cases where it doesn't yet exist\n            // (such as loading iframes in IE - #4833)\n            var documentElement = elem &&\n                (elem.ownerDocument || elem).documentElement;\n            return documentElement\n                ? documentElement.nodeName !== \"HTML\"\n                : false;\n        };\n\n        /**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\n        setDocument = Sizzle.setDocument = function(node) {\n            var hasCompare,\n                subWindow,\n                doc = node ? node.ownerDocument || node : preferredDoc;\n\n            // Return early if doc is invalid or already selected\n            if (\n                doc === document || doc.nodeType !== 9 || !doc.documentElement\n            ) {\n                return document;\n            }\n\n            // Update global variables\n            document = doc;\n            docElem = document.documentElement;\n            documentIsHTML = !isXML(document);\n\n            // Support: IE 9-11, Edge\n            // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n            if (\n                preferredDoc !== document &&\n                    (subWindow = document.defaultView) &&\n                    subWindow.top !== subWindow\n            ) {\n                // Support: IE 11, Edge\n                if (subWindow.addEventListener) {\n                    subWindow.addEventListener(\"unload\", unloadHandler, false);\n                    // Support: IE 9 - 10 only\n                } else if (subWindow.attachEvent) {\n                    subWindow.attachEvent(\"onunload\", unloadHandler);\n                }\n            }\n\n            /* Attributes\n\t---------------------------------------------------------------------- */\n            // Support: IE<8\n            // Verify that getAttribute really returns attributes and not properties\n            // (excepting IE8 booleans)\n            support.attributes = assert(function(el) {\n                el.className = \"i\";\n                return !el.getAttribute(\"className\");\n            });\n\n            /* getElement(s)By*\n\t---------------------------------------------------------------------- */\n            // Check if getElementsByTagName(\"*\") returns only elements\n            support.getElementsByTagName = assert(function(el) {\n                el.appendChild(document.createComment(\"\"));\n                return !el.getElementsByTagName(\"*\").length;\n            });\n\n            // Support: IE<9\n            support.getElementsByClassName = rnative.test(\n                document.getElementsByClassName\n            );\n\n            // Support: IE<10\n            // Check if getElementById returns elements by name\n            // The broken getElementById methods don't pick up programmatically-set names,\n            // so use a roundabout getElementsByName test\n            support.getById = assert(function(el) {\n                docElem.appendChild(el).id = expando;\n                return !document.getElementsByName ||\n                    !document.getElementsByName(expando).length;\n            });\n\n            // ID filter and find\n            if (support.getById) {\n                Expr.filter[\"ID\"] = function(id) {\n                    var attrId = id.replace(runescape, funescape);\n                    return function(elem) {\n                        return elem.getAttribute(\"id\") === attrId;\n                    };\n                };\n                Expr.find[\"ID\"] = function(id, context) {\n                    if (\n                        typeof context.getElementById !== \"undefined\" &&\n                            documentIsHTML\n                    ) {\n                        var elem = context.getElementById(id);\n                        return elem ? [ elem ] : [];\n                    }\n                };\n            } else {\n                Expr.filter[\"ID\"] = function(id) {\n                    var attrId = id.replace(runescape, funescape);\n                    return function(elem) {\n                        var node = typeof elem.getAttributeNode !==\n                            \"undefined\" &&\n                            elem.getAttributeNode(\"id\");\n                        return node && node.value === attrId;\n                    };\n                };\n\n                // Support: IE 6 - 7 only\n                // getElementById is not reliable as a find shortcut\n                Expr.find[\"ID\"] = function(id, context) {\n                    if (\n                        typeof context.getElementById !== \"undefined\" &&\n                            documentIsHTML\n                    ) {\n                        var node, i, elems, elem = context.getElementById(id);\n\n                        if (elem) {\n                            // Verify the id attribute\n                            node = elem.getAttributeNode(\"id\");\n                            if (node && node.value === id) {\n                                return [ elem ];\n                            }\n\n                            // Fall back on getElementsByName\n                            elems = context.getElementsByName(id);\n                            i = 0;\n                            while (elem = elems[i++]) {\n                                node = elem.getAttributeNode(\"id\");\n                                if (node && node.value === id) {\n                                    return [ elem ];\n                                }\n                            }\n                        }\n\n                        return [];\n                    }\n                };\n            }\n\n            // Tag\n            Expr.find[\"TAG\"] = support.getElementsByTagName\n                ? (function(tag, context) {\n                    if (typeof context.getElementsByTagName !== \"undefined\") {\n                        return context.getElementsByTagName(tag);\n                        // DocumentFragment nodes don't have gEBTN\n                    } else if (support.qsa) {\n                        return context.querySelectorAll(tag);\n                    }\n                })\n                : (function(tag, context) {\n                    var elem,\n                        tmp = [],\n                        i = 0,\n                        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n                        results = context.getElementsByTagName(tag);\n\n                    // Filter out possible comments\n                    if (tag === \"*\") {\n                        while (elem = results[i++]) {\n                            if (elem.nodeType === 1) {\n                                tmp.push(elem);\n                            }\n                        }\n\n                        return tmp;\n                    }\n                    return results;\n                });\n\n            // Class\n            Expr.find[\"CLASS\"] = support.getElementsByClassName &&\n                function(className, context) {\n                    if (\n                        typeof context.getElementsByClassName !== \"undefined\" &&\n                            documentIsHTML\n                    ) {\n                        return context.getElementsByClassName(className);\n                    }\n                };\n\n            /* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n            // QSA and matchesSelector support\n            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n            rbuggyMatches = [];\n\n            // qSa(:focus) reports false when true (Chrome 21)\n            // We allow this because of a bug in IE8/9 that throws an error\n            // whenever `document.activeElement` is accessed on an iframe\n            // So, we allow :focus to pass through QSA all the time to avoid the IE error\n            // See https://bugs.jquery.com/ticket/13378\n            rbuggyQSA = [];\n\n            if (support.qsa = rnative.test(document.querySelectorAll)) {\n                // Build QSA regex\n                // Regex strategy adopted from Diego Perini\n                assert(function(el) {\n                    // Select is set to empty string on purpose\n                    // This is to test IE's treatment of not explicitly\n                    // setting a boolean content attribute,\n                    // since its presence should be enough\n                    // https://bugs.jquery.com/ticket/12359\n                    docElem.appendChild(el).innerHTML = \"<a id='\" +\n                        expando +\n                        \"'></a>\" +\n                        \"<select id='\" +\n                        expando +\n                        \"-\\r\\\\' msallowcapture=''>\" +\n                        \"<option selected=''></option></select>\";\n\n                    // Support: IE8, Opera 11-12.16\n                    // Nothing should be selected when empty strings follow ^= or $= or *=\n                    // The test attribute must be unknown in Opera but \"safe\" for WinRT\n                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n                    if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n                        rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n                    }\n\n                    // Support: IE8\n                    // Boolean attributes and \"value\" are not treated correctly\n                    if (!el.querySelectorAll(\"[selected]\").length) {\n                        rbuggyQSA.push(\n                            \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\"\n                        );\n                    }\n\n                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n                    if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n                        rbuggyQSA.push(\"~=\");\n                    }\n\n                    // Webkit/Opera - :checked should return selected option elements\n                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n                    // IE8 throws error here and will not see later tests\n                    if (!el.querySelectorAll(\":checked\").length) {\n                        rbuggyQSA.push(\":checked\");\n                    }\n\n                    // Support: Safari 8+, iOS 8+\n                    // https://bugs.webkit.org/show_bug.cgi?id=136851\n                    // In-page `selector#id sibling-combinator selector` fails\n                    if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n                        rbuggyQSA.push(\".#.+[+~]\");\n                    }\n                });\n\n                assert(function(el) {\n                    el.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n                        \"<select disabled='disabled'><option/></select>\";\n\n                    // Support: Windows 8 Native Apps\n                    // The type and name attributes are restricted during .innerHTML assignment\n                    var input = document.createElement(\"input\");\n                    input.setAttribute(\"type\", \"hidden\");\n                    el.appendChild(input).setAttribute(\"name\", \"D\");\n\n                    // Support: IE8\n                    // Enforce case-sensitivity of name attribute\n                    if (el.querySelectorAll(\"[name=d]\").length) {\n                        rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n                    }\n\n                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n                    // IE8 throws error here and will not see later tests\n                    if (el.querySelectorAll(\":enabled\").length !== 2) {\n                        rbuggyQSA.push(\":enabled\", \":disabled\");\n                    }\n\n                    // Support: IE9-11+\n                    // IE's :disabled selector does not pick up the children of disabled fieldsets\n                    docElem.appendChild(el).disabled = true;\n                    if (el.querySelectorAll(\":disabled\").length !== 2) {\n                        rbuggyQSA.push(\":enabled\", \":disabled\");\n                    }\n\n                    // Opera 10-11 does not throw on post-comma invalid pseudos\n                    el.querySelectorAll(\"*,:x\");\n                    rbuggyQSA.push(\",.*:\");\n                });\n            }\n\n            if (\n                support.matchesSelector = rnative.test(\n                    matches = docElem.matches ||\n                        docElem.webkitMatchesSelector ||\n                        docElem.mozMatchesSelector ||\n                        docElem.oMatchesSelector ||\n                        docElem.msMatchesSelector\n                )\n            ) {\n                assert(function(el) {\n                    // Check to see if it's possible to do matchesSelector\n                    // on a disconnected node (IE 9)\n                    support.disconnectedMatch = matches.call(el, \"*\");\n\n                    // This should fail with an exception\n                    // Gecko does not error, returns false instead\n                    matches.call(el, \"[s!='']:x\");\n                    rbuggyMatches.push(\"!=\", pseudos);\n                });\n            }\n\n            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n            rbuggyMatches = rbuggyMatches.length &&\n                new RegExp(rbuggyMatches.join(\"|\"));\n\n            /* Contains\n\t---------------------------------------------------------------------- */\n            hasCompare = rnative.test(docElem.compareDocumentPosition);\n\n            // Element contains another\n            // Purposefully self-exclusive\n            // As in, an element does not contain itself\n            contains = hasCompare || rnative.test(docElem.contains)\n                ? (function(a, b) {\n                    var adown = a.nodeType === 9 ? a.documentElement : a,\n                        bup = b && b.parentNode;\n                    return a === bup ||\n                        !!(bup &&\n                            bup.nodeType === 1 &&\n                            (adown.contains\n                                ? adown.contains(bup)\n                                : a.compareDocumentPosition &&\n                                    a.compareDocumentPosition(bup) & 16));\n                })\n                : (function(a, b) {\n                    if (b) {\n                        while (b = b.parentNode) {\n                            if (b === a) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                });\n\n            /* Sorting\n\t---------------------------------------------------------------------- */\n            // Document order sorting\n            sortOrder = hasCompare ? (function(a, b) {\n                    // Flag for duplicate removal\n                    if (a === b) {\n                        hasDuplicate = true;\n                        return 0;\n                    }\n\n                    // Sort on method existence if only one input has compareDocumentPosition\n                    var compare = !a.compareDocumentPosition -\n                        !b.compareDocumentPosition;\n                    if (compare) {\n                        return compare;\n                    }\n\n                    // Calculate position if both inputs belong to the same document\n                    compare = (a.ownerDocument || a) === (b.ownerDocument || b)\n                        ? a.compareDocumentPosition(b)\n                        : // Otherwise we know they are disconnected\n                        1;\n\n                    // Disconnected nodes\n                    if (\n                        compare & 1 ||\n                            !support.sortDetached &&\n                                b.compareDocumentPosition(a) === compare\n                    ) {\n                        // Choose the first element that is related to our preferred document\n                        if (\n                            a === document ||\n                                a.ownerDocument === preferredDoc &&\n                                    contains(preferredDoc, a)\n                        ) {\n                            return -1;\n                        }\n                        if (\n                            b === document ||\n                                b.ownerDocument === preferredDoc &&\n                                    contains(preferredDoc, b)\n                        ) {\n                            return 1;\n                        }\n\n                        // Maintain original order\n                        return sortInput\n                            ? indexOf(sortInput, a) - indexOf(sortInput, b)\n                            : 0;\n                    }\n\n                    return compare & 4 ? -1 : 1;\n                }) : (function(a, b) {\n                    // Exit early if the nodes are identical\n                    if (a === b) {\n                        hasDuplicate = true;\n                        return 0;\n                    }\n\n                    var cur,\n                        i = 0,\n                        aup = a.parentNode,\n                        bup = b.parentNode,\n                        ap = [ a ],\n                        bp = [ b ];\n\n                    // Parentless nodes are either documents or disconnected\n                    if (!aup || !bup) {\n                        return a === document\n                            ? -1\n                            : b === document\n                                ? 1\n                                : aup\n                                    ? -1\n                                    : bup\n                                        ? 1\n                                        : sortInput\n                                            ? indexOf(sortInput, a) -\n                                                indexOf(sortInput, b)\n                                            : 0;\n                        // If the nodes are siblings, we can do a quick check\n                    } else if (aup === bup) {\n                        return siblingCheck(a, b);\n                    }\n\n                    // Otherwise we need full lists of their ancestors for comparison\n                    cur = a;\n                    while (cur = cur.parentNode) {\n                        ap.unshift(cur);\n                    }\n                    cur = b;\n                    while (cur = cur.parentNode) {\n                        bp.unshift(cur);\n                    }\n\n                    // Walk down the tree looking for a discrepancy\n                    while (ap[i] === bp[i]) {\n                        i++;\n                    }\n\n                    return i\n                        ? // Do a sibling check if the nodes have a common ancestor\n                        siblingCheck(ap[i], bp[i])\n                        : // Otherwise nodes in our document sort first\n                        ap[i] === preferredDoc\n                            ? -1\n                            : bp[i] === preferredDoc ? 1 : 0;\n                });\n\n            return document;\n        };\n\n        Sizzle.matches = function(expr, elements) {\n            return Sizzle(expr, null, null, elements);\n        };\n\n        Sizzle.matchesSelector = function(elem, expr) {\n            // Set document vars if needed\n            if ((elem.ownerDocument || elem) !== document) {\n                setDocument(elem);\n            }\n\n            // Make sure that attribute selectors are quoted\n            expr = expr.replace(rattributeQuotes, \"='$1']\");\n\n            if (\n                support.matchesSelector &&\n                    documentIsHTML &&\n                    !compilerCache[expr + \" \"] &&\n                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&\n                    (!rbuggyQSA || !rbuggyQSA.test(expr))\n            ) {\n                try {\n                    var ret = matches.call(elem, expr);\n\n                    // IE 9's matchesSelector returns false on disconnected nodes\n                    if (\n                        ret ||\n                            support.disconnectedMatch ||\n                            // As well, disconnected nodes are said to be in a document\n                            // fragment in IE 9\n                            elem.document && elem.document.nodeType !== 11\n                    ) {\n                        return ret;\n                    }\n                } catch (e) {\n                }\n            }\n\n            return Sizzle(expr, document, null, [ elem ]).length > 0;\n        };\n\n        Sizzle.contains = function(context, elem) {\n            // Set document vars if needed\n            if ((context.ownerDocument || context) !== document) {\n                setDocument(context);\n            }\n            return contains(context, elem);\n        };\n\n        Sizzle.attr = function(elem, name) {\n            // Set document vars if needed\n            if ((elem.ownerDocument || elem) !== document) {\n                setDocument(elem);\n            }\n\n            var fn = Expr.attrHandle[name.toLowerCase()],\n                // Don't get fooled by Object.prototype properties (jQuery #13807)\n                val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())\n                    ? fn(elem, name, !documentIsHTML)\n                    : undefined;\n\n            return val !== undefined\n                ? val\n                : support.attributes || !documentIsHTML\n                    ? elem.getAttribute(name)\n                    : (val = elem.getAttributeNode(name)) && val.specified\n                        ? val.value\n                        : null;\n        };\n\n        Sizzle.escape = function(sel) {\n            return (sel + \"\").replace(rcssescape, fcssescape);\n        };\n\n        Sizzle.error = function(msg) {\n            throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n        };\n\n        /**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\n        Sizzle.uniqueSort = function(results) {\n            var elem, duplicates = [], j = 0, i = 0;\n\n            // Unless we *know* we can detect duplicates, assume their presence\n            hasDuplicate = !support.detectDuplicates;\n            sortInput = !support.sortStable && results.slice(0);\n            results.sort(sortOrder);\n\n            if (hasDuplicate) {\n                while (elem = results[i++]) {\n                    if (elem === results[i]) {\n                        j = duplicates.push(i);\n                    }\n                }\n                while (j--) {\n                    results.splice(duplicates[j], 1);\n                }\n            }\n\n            // Clear input after sorting to release objects\n            // See https://github.com/jquery/sizzle/pull/225\n            sortInput = null;\n\n            return results;\n        };\n\n        /**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\n        getText = Sizzle.getText = function(elem) {\n            var node, ret = \"\", i = 0, nodeType = elem.nodeType;\n\n            if (!nodeType) {\n                // If no nodeType, this is expected to be an array\n                while (node = elem[i++]) {\n                    // Do not traverse comment nodes\n                    ret += getText(node);\n                }\n            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n                // Use textContent for elements\n                // innerText usage removed for consistency of new lines (jQuery #11153)\n                if (typeof elem.textContent === \"string\") {\n                    return elem.textContent;\n                } else {\n                    // Traverse its children\n                    for (\n                        elem = elem.firstChild;\n                        elem;\n                        elem = elem.nextSibling\n                    ) {\n                        ret += getText(elem);\n                    }\n                }\n            } else if (nodeType === 3 || nodeType === 4) {\n                return elem.nodeValue;\n            }\n            // Do not include comment or processing instruction nodes\n            return ret;\n        };\n\n        Expr = Sizzle.selectors = {\n            // Can be adjusted by the user\n            cacheLength: 50,\n            createPseudo: markFunction,\n            match: matchExpr,\n            attrHandle: {},\n            find: {},\n            relative: {\n                \">\": { dir: \"parentNode\", first: true },\n                \" \": { dir: \"parentNode\" },\n                \"+\": { dir: \"previousSibling\", first: true },\n                \"~\": { dir: \"previousSibling\" }\n            },\n            preFilter: {\n                ATTR: function(match) {\n                    match[1] = match[1].replace(runescape, funescape);\n\n                    // Move the given value to match[3] whether quoted or unquoted\n                    match[3] = (match[3] || match[4] || match[5] || \"\").replace(\n                        runescape,\n                        funescape\n                    );\n\n                    if (match[2] === \"~=\") {\n                        match[3] = \" \" + match[3] + \" \";\n                    }\n\n                    return match.slice(0, 4);\n                },\n                CHILD: function(match) {\n                    /* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n                    match[1] = match[1].toLowerCase();\n\n                    if (match[1].slice(0, 3) === \"nth\") {\n                        // nth-* requires argument\n                        if (!match[3]) {\n                            Sizzle.error(match[0]);\n                        }\n\n                        // numeric x and y parameters for Expr.filter.CHILD\n                        // remember that false/true cast respectively to 0/1\n                        match[4] = +(match[4]\n                            ? match[5] + (match[6] || 1)\n                            : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n                        match[5] = +(match[7] + match[8] || match[3] === \"odd\");\n                        // other types prohibit arguments\n                    } else if (match[3]) {\n                        Sizzle.error(match[0]);\n                    }\n\n                    return match;\n                },\n                PSEUDO: function(match) {\n                    var excess, unquoted = !match[6] && match[2];\n\n                    if (matchExpr[\"CHILD\"].test(match[0])) {\n                        return null;\n                    }\n\n                    // Accept quoted arguments as-is\n                    if (match[3]) {\n                        match[2] = match[4] || match[5] || \"\";\n                        // Strip excess characters from unquoted arguments\n                    } else if (\n                        unquoted &&\n                            rpseudo.test(unquoted) &&\n                            (excess = tokenize(unquoted, true)) &&\n                            (excess = unquoted.indexOf(\n                                \")\",\n                                unquoted.length - excess\n                            ) -\n                                unquoted.length)\n                    ) {\n                        // excess is a negative index\n                        match[0] = match[0].slice(0, excess);\n                        match[2] = unquoted.slice(0, excess);\n                    }\n\n                    // Return only captures needed by the pseudo filter method (type and argument)\n                    return match.slice(0, 3);\n                }\n            },\n            filter: {\n                TAG: function(nodeNameSelector) {\n                    var nodeName = nodeNameSelector\n                        .replace(runescape, funescape)\n                        .toLowerCase();\n                    return nodeNameSelector === \"*\" ? (function() {\n                            return true;\n                        }) : (function(elem) {\n                            return elem.nodeName &&\n                                elem.nodeName.toLowerCase() === nodeName;\n                        });\n                },\n                CLASS: function(className) {\n                    var pattern = classCache[className + \" \"];\n\n                    return pattern ||\n                        (pattern = new RegExp(\n                            \"(^|\" +\n                                whitespace +\n                                \")\" +\n                                className +\n                                \"(\" +\n                                whitespace +\n                                \"|$)\"\n                        )) &&\n                            classCache(className, function(elem) {\n                                return pattern.test(\n                                    typeof elem.className === \"string\" &&\n                                        elem.className ||\n                                        typeof elem.getAttribute !==\n                                            \"undefined\" &&\n                                            elem.getAttribute(\"class\") ||\n                                        \"\"\n                                );\n                            });\n                },\n                ATTR: function(name, operator, check) {\n                    return function(elem) {\n                        var result = Sizzle.attr(elem, name);\n\n                        if (result == null) {\n                            return operator === \"!=\";\n                        }\n                        if (!operator) {\n                            return true;\n                        }\n\n                        result += \"\";\n\n                        return operator === \"=\"\n                            ? result === check\n                            : operator === \"!=\"\n                                ? result !== check\n                                : operator === \"^=\"\n                                    ? check && result.indexOf(check) === 0\n                                    : operator === \"*=\"\n                                        ? check && result.indexOf(check) > -1\n                                        : operator === \"$=\"\n                                            ? check &&\n                                                result.slice(-check.length) ===\n                                                    check\n                                            : operator === \"~=\"\n                                                ? (\" \" +\n                                                    result.replace(\n                                                        rwhitespace,\n                                                        \" \"\n                                                    ) +\n                                                    \" \").indexOf(check) >\n                                                    -1\n                                                : operator === \"|=\"\n                                                    ? result === check ||\n                                                        result.slice(\n                                                            0,\n                                                            check.length + 1\n                                                        ) ===\n                                                            check + \"-\"\n                                                    : false;\n                    };\n                },\n                CHILD: function(type, what, argument, first, last) {\n                    var simple = type.slice(0, 3) !== \"nth\",\n                        forward = type.slice(-4) !== \"last\",\n                        ofType = what === \"of-type\";\n\n                    return;\n                    // Shortcut for :nth-*(n)\n                    first === 1 && last === 0 ? (function(elem) {\n                            return !!elem.parentNode;\n                        }) : (function(elem, context, xml) {\n                            var cache,\n                                uniqueCache,\n                                outerCache,\n                                node,\n                                nodeIndex,\n                                start,\n                                dir = simple !== forward\n                                    ? \"nextSibling\"\n                                    : \"previousSibling\",\n                                parent = elem.parentNode,\n                                name = ofType && elem.nodeName.toLowerCase(),\n                                useCache = !xml && !ofType,\n                                diff = false;\n\n                            if (parent) {\n                                // :(first|last|only)-(child|of-type)\n                                if (simple) {\n                                    while (dir) {\n                                        node = elem;\n                                        while (node = node[dir]) {\n                                            if (\n                                                ofType\n                                                    ? node.nodeName.toLowerCase() ===\n                                                        name\n                                                    : node.nodeType === 1\n                                            ) {\n                                                return false;\n                                            }\n                                        }\n                                        // Reverse direction for :only-* (if we haven't yet done so)\n                                        start = dir = type === \"only\" &&\n                                            !start &&\n                                            \"nextSibling\";\n                                    }\n                                    return true;\n                                }\n\n                                start = [\n                                    forward\n                                        ? parent.firstChild\n                                        : parent.lastChild\n                                ];\n\n                                // non-xml :nth-child(...) stores cache data on `parent`\n                                if (forward && useCache) {\n                                    // Seek `elem` from a previously-cached index\n                                    // ...in a gzip-friendly way\n                                    node = parent;\n                                    outerCache = node[expando] ||\n                                        (node[expando] = {});\n\n                                    // Support: IE <9 only\n                                    // Defend against cloned attroperties (jQuery gh-1709)\n                                    uniqueCache = outerCache[node.uniqueID] ||\n                                        (outerCache[node.uniqueID] = {});\n\n                                    cache = uniqueCache[type] || [];\n                                    nodeIndex = cache[0] === dirruns &&\n                                        cache[1];\n                                    diff = nodeIndex && cache[2];\n                                    node = nodeIndex &&\n                                        parent.childNodes[nodeIndex];\n\n                                    while (\n                                        node = // Fallback to seeking `elem` from the start\n                                        ++nodeIndex && node && node[dir] ||\n                                            (diff = nodeIndex = 0) ||\n                                            start.pop()\n                                    ) {\n                                        // When found, cache indexes on `parent` and break\n                                        if (\n                                            node.nodeType === 1 &&\n                                                ++diff &&\n                                                node === elem\n                                        ) {\n                                            uniqueCache[type] = [\n                                                dirruns,\n                                                nodeIndex,\n                                                diff\n                                            ];\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    // Use previously-cached element index if available\n                                    if (useCache) {\n                                        // ...in a gzip-friendly way\n                                        node = elem;\n                                        outerCache = node[expando] ||\n                                            (node[expando] = {});\n\n                                        // Support: IE <9 only\n                                        // Defend against cloned attroperties (jQuery gh-1709)\n                                        uniqueCache = outerCache[node.uniqueID] ||\n                                            (outerCache[node.uniqueID] = {});\n\n                                        cache = uniqueCache[type] || [];\n                                        nodeIndex = cache[0] === dirruns &&\n                                            cache[1];\n                                        diff = nodeIndex;\n                                    }\n\n                                    // xml :nth-child(...)\n                                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                                    if (diff === false) {\n                                        // Use the same loop as above to seek `elem` from the start\n                                        while (\n                                            node = ++nodeIndex &&\n                                                node &&\n                                                node[dir] ||\n                                                (diff = nodeIndex = 0) ||\n                                                start.pop()\n                                        ) {\n                                            if (\n                                                (ofType\n                                                    ? node.nodeName.toLowerCase() ===\n                                                        name\n                                                    : node.nodeType === 1) &&\n                                                    ++diff\n                                            ) {\n                                                // Cache the index of each encountered element\n                                                if (useCache) {\n                                                    outerCache = node[expando] ||\n                                                        (node[expando] = {});\n\n                                                    // Support: IE <9 only\n                                                    // Defend against cloned attroperties (jQuery gh-1709)\n                                                    uniqueCache = outerCache[node.uniqueID] ||\n                                                        (outerCache[node.uniqueID] = {});\n\n                                                    uniqueCache[type] = [\n                                                        dirruns,\n                                                        diff\n                                                    ];\n                                                }\n\n                                                if (node === elem) {\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n\n                                // Incorporate the offset, then check against cycle size\n                                diff -= last;\n                                return diff === first ||\n                                    diff % first === 0 && diff / first >= 0;\n                            }\n                        });\n                },\n                PSEUDO: function(pseudo, argument) {\n                    // pseudo-class names are case-insensitive\n                    // http://www.w3.org/TR/selectors/#pseudo-classes\n                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n                    // Remember that setFilters inherits from pseudos\n                    var args,\n                        fn = Expr.pseudos[pseudo] ||\n                            Expr.setFilters[pseudo.toLowerCase()] ||\n                            Sizzle.error(\"unsupported pseudo: \" + pseudo);\n\n                    // The user may use createPseudo to indicate that\n                    // arguments are needed to create the filter function\n                    // just as Sizzle does\n                    if (fn[expando]) {\n                        return fn(argument);\n                    }\n\n                    // But maintain support for old signatures\n                    if (fn.length > 1) {\n                        args = [ pseudo, pseudo, \"\", argument ];\n                        return Expr.setFilters.hasOwnProperty(\n                            pseudo.toLowerCase()\n                        )\n                            ? markFunction(function(seed, matches) {\n                                var idx,\n                                    matched = fn(seed, argument),\n                                    i = matched.length;\n                                while (i--) {\n                                    idx = indexOf(seed, matched[i]);\n                                    seed[idx] = !(matches[idx] = matched[i]);\n                                }\n                            })\n                            : (function(elem) {\n                                return fn(elem, 0, args);\n                            });\n                    }\n\n                    return fn;\n                }\n            },\n            pseudos: {\n                // Potentially complex pseudos\n                not: markFunction(function(selector) {\n                    // Trim the selector passed to compile\n                    // to avoid treating leading and trailing\n                    // spaces as combinators\n                    var input = [],\n                        results = [],\n                        matcher = compile(selector.replace(rtrim, \"$1\"));\n\n                    return matcher[expando]\n                        ? markFunction(function(seed, matches, context, xml) {\n                            var elem,\n                                unmatched = matcher(seed, null, xml, []),\n                                i = seed.length;\n\n                            // Match elements unmatched by `matcher`\n                            while (i--) {\n                                if (elem = unmatched[i]) {\n                                    seed[i] = !(matches[i] = elem);\n                                }\n                            }\n                        })\n                        : (function(elem, context, xml) {\n                            input[0] = elem;\n                            matcher(input, null, xml, results);\n                            // Don't keep the element (issue #299)\n                            input[0] = null;\n                            return !results.pop();\n                        });\n                }),\n                has: markFunction(function(selector) {\n                    return function(elem) {\n                        return Sizzle(selector, elem).length > 0;\n                    };\n                }),\n                contains: markFunction(function(text) {\n                    text = text.replace(runescape, funescape);\n                    return function(elem) {\n                        return (elem.textContent ||\n                            elem.innerText ||\n                            getText(elem)).indexOf(text) >\n                            -1;\n                    };\n                }),\n                // \"Whether an element is represented by a :lang() selector\n                // is based solely on the element's language value\n                // being equal to the identifier C,\n                // or beginning with the identifier C immediately followed by \"-\".\n                // The matching of C against the element's language value is performed case-insensitively.\n                // The identifier C does not have to be a valid language name.\"\n                // http://www.w3.org/TR/selectors/#lang-pseudo\n                lang: markFunction(function(lang) {\n                    // lang value must be a valid identifier\n                    if (!ridentifier.test(lang || \"\")) {\n                        Sizzle.error(\"unsupported lang: \" + lang);\n                    }\n                    lang = lang.replace(runescape, funescape).toLowerCase();\n                    return function(elem) {\n                        var elemLang;\n                        do {\n                            if (\n                                elemLang = documentIsHTML\n                                    ? elem.lang\n                                    : elem.getAttribute(\"xml:lang\") ||\n                                        elem.getAttribute(\"lang\")\n                            ) {\n                                elemLang = elemLang.toLowerCase();\n                                return elemLang === lang ||\n                                    elemLang.indexOf(lang + \"-\") === 0;\n                            }\n                        } while ((elem = elem.parentNode) &&\n                            elem.nodeType === 1);\n                        return false;\n                    };\n                }),\n                // Miscellaneous\n                target: function(elem) {\n                    var hash = window.location && window.location.hash;\n                    return hash && hash.slice(1) === elem.id;\n                },\n                root: function(elem) {\n                    return elem === docElem;\n                },\n                focus: function(elem) {\n                    return elem === document.activeElement &&\n                        (!document.hasFocus || document.hasFocus()) &&\n                        !!(elem.type || elem.href || ~elem.tabIndex);\n                },\n                // Boolean properties\n                enabled: createDisabledPseudo(false),\n                disabled: createDisabledPseudo(true),\n                checked: function(elem) {\n                    // In CSS3, :checked should return both checked and selected elements\n                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n                    var nodeName = elem.nodeName.toLowerCase();\n                    return nodeName === \"input\" && !!elem.checked ||\n                        nodeName === \"option\" && !!elem.selected;\n                },\n                selected: function(elem) {\n                    // Accessing this property makes selected-by-default\n                    // options in Safari work properly\n                    if (elem.parentNode) {\n                        elem.parentNode.selectedIndex;\n                    }\n\n                    return elem.selected === true;\n                },\n                // Contents\n                empty: function(elem) {\n                    // http://www.w3.org/TR/selectors/#empty-pseudo\n                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n                    //   but not by others (comment: 8; processing instruction: 7; etc.)\n                    // nodeType < 6 works because attributes (2) do not appear as children\n                    for (\n                        elem = elem.firstChild;\n                        elem;\n                        elem = elem.nextSibling\n                    ) {\n                        if (elem.nodeType < 6) {\n                            return false;\n                        }\n                    }\n                    return true;\n                },\n                parent: function(elem) {\n                    return !Expr.pseudos[\"empty\"](elem);\n                },\n                // Element/input types\n                header: function(elem) {\n                    return rheader.test(elem.nodeName);\n                },\n                input: function(elem) {\n                    return rinputs.test(elem.nodeName);\n                },\n                button: function(elem) {\n                    var name = elem.nodeName.toLowerCase();\n                    return name === \"input\" && elem.type === \"button\" ||\n                        name === \"button\";\n                },\n                text: function(elem) {\n                    var attr;\n                    return elem.nodeName.toLowerCase() === \"input\" &&\n                        elem.type === \"text\" &&\n                        ((attr = elem.getAttribute(\"type\")) == null ||\n                            attr.toLowerCase() === \"text\");\n                },\n                // Position-in-collection\n                first: createPositionalPseudo(function() {\n                    return [ 0 ];\n                }),\n                last: createPositionalPseudo(function(matchIndexes, length) {\n                    return [ length - 1 ];\n                }),\n                eq: createPositionalPseudo(function(\n                    matchIndexes,\n                    length,\n                    argument\n                ) {\n                    return [ argument < 0 ? argument + length : argument ];\n                }),\n                even: createPositionalPseudo(function(matchIndexes, length) {\n                    var i = 0;\n                    for (; i < length; i += 2) {\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                odd: createPositionalPseudo(function(matchIndexes, length) {\n                    var i = 1;\n                    for (; i < length; i += 2) {\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                lt: createPositionalPseudo(function(\n                    matchIndexes,\n                    length,\n                    argument\n                ) {\n                    var i = argument < 0 ? argument + length : argument;\n                    for (; --i >= 0; ) {\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                gt: createPositionalPseudo(function(\n                    matchIndexes,\n                    length,\n                    argument\n                ) {\n                    var i = argument < 0 ? argument + length : argument;\n                    for (; ++i < length; ) {\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                })\n            }\n        };\n\n        Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n        // Add button/input type pseudos\n        for (i in {\n            radio: true,\n            checkbox: true,\n            file: true,\n            password: true,\n            image: true\n        }) {\n            Expr.pseudos[i] = createInputPseudo(i);\n        }\n        for (i in { submit: true, reset: true }) {\n            Expr.pseudos[i] = createButtonPseudo(i);\n        }\n\n        // Easy API for creating new setFilters\n        function setFilters() {\n        }\n        setFilters.prototype = Expr.filters = Expr.pseudos;\n        Expr.setFilters = new setFilters();\n\n        tokenize = Sizzle.tokenize = function(selector, parseOnly) {\n            var matched,\n                match,\n                tokens,\n                type,\n                soFar,\n                groups,\n                preFilters,\n                cached = tokenCache[selector + \" \"];\n\n            if (cached) {\n                return parseOnly ? 0 : cached.slice(0);\n            }\n\n            soFar = selector;\n            groups = [];\n            preFilters = Expr.preFilter;\n\n            while (soFar) {\n                // Comma and first run\n                if (!matched || (match = rcomma.exec(soFar))) {\n                    if (match) {\n                        // Don't consume trailing commas as valid\n                        soFar = soFar.slice(match[0].length) || soFar;\n                    }\n                    groups.push(tokens = []);\n                }\n\n                matched = false;\n\n                // Combinators\n                if (match = rcombinators.exec(soFar)) {\n                    matched = match.shift();\n                    tokens.push({\n                        value: matched,\n                        // Cast descendant combinators to space\n                        type: match[0].replace(rtrim, \" \")\n                    });\n                    soFar = soFar.slice(matched.length);\n                }\n\n                // Filters\n                for (type in Expr.filter) {\n                    if (\n                        (match = matchExpr[type].exec(soFar)) &&\n                            (!preFilters[type] ||\n                                (match = preFilters[type](match)))\n                    ) {\n                        matched = match.shift();\n                        tokens.push({\n                            value: matched,\n                            type: type,\n                            matches: match\n                        });\n                        soFar = soFar.slice(matched.length);\n                    }\n                }\n\n                if (!matched) {\n                    break;\n                }\n            }\n\n            // Return the length of the invalid excess\n            // if we're just parsing\n            // Otherwise, throw an error or return tokens\n            return parseOnly\n                ? soFar.length\n                : soFar ? Sizzle.error(selector) : // Cache the tokens\n                    tokenCache(selector, groups).slice(0);\n        };\n\n        function toSelector(tokens) {\n            var i = 0, len = tokens.length, selector = \"\";\n            for (; i < len; i++) {\n                selector += tokens[i].value;\n            }\n            return selector;\n        }\n\n        function addCombinator(matcher, combinator, base) {\n            var dir = combinator.dir,\n                skip = combinator.next,\n                key = skip || dir,\n                checkNonElements = base && key === \"parentNode\",\n                doneName = done++;\n\n            return;\n            // Check against closest ancestor/preceding element\n            // Check against all ancestor/preceding elements\n            combinator.first ? (function(elem, context, xml) {\n                    while (elem = elem[dir]) {\n                        if (elem.nodeType === 1 || checkNonElements) {\n                            return matcher(elem, context, xml);\n                        }\n                    }\n                    return false;\n                }) : (function(elem, context, xml) {\n                    var oldCache,\n                        uniqueCache,\n                        outerCache,\n                        newCache = [ dirruns, doneName ];\n\n                    // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n                    if (xml) {\n                        while (elem = elem[dir]) {\n                            if (elem.nodeType === 1 || checkNonElements) {\n                                if (matcher(elem, context, xml)) {\n                                    return true;\n                                }\n                            }\n                        }\n                    } else {\n                        while (elem = elem[dir]) {\n                            if (elem.nodeType === 1 || checkNonElements) {\n                                outerCache = elem[expando] ||\n                                    (elem[expando] = {});\n\n                                // Support: IE <9 only\n                                // Defend against cloned attroperties (jQuery gh-1709)\n                                uniqueCache = outerCache[elem.uniqueID] ||\n                                    (outerCache[elem.uniqueID] = {});\n\n                                if (\n                                    skip && skip === elem.nodeName.toLowerCase()\n                                ) {\n                                    elem = elem[dir] || elem;\n                                } else if (\n                                    (oldCache = uniqueCache[key]) &&\n                                        oldCache[0] === dirruns &&\n                                        oldCache[1] === doneName\n                                ) {\n                                    // Assign to newCache so results back-propagate to previous elements\n                                    return newCache[2] = oldCache[2];\n                                } else {\n                                    // Reuse newcache so results back-propagate to previous elements\n                                    uniqueCache[key] = newCache;\n\n                                    // A match means we're done; a fail means we have to keep checking\n                                    if (\n                                        newCache[2] = matcher(\n                                            elem,\n                                            context,\n                                            xml\n                                        )\n                                    ) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                });\n        }\n\n        function elementMatcher(matchers) {\n            return matchers.length > 1 ? (function(elem, context, xml) {\n                    var i = matchers.length;\n                    while (i--) {\n                        if (!matchers[i](elem, context, xml)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }) : matchers[0];\n        }\n\n        function multipleContexts(selector, contexts, results) {\n            var i = 0, len = contexts.length;\n            for (; i < len; i++) {\n                Sizzle(selector, contexts[i], results);\n            }\n            return results;\n        }\n\n        function condense(unmatched, map, filter, context, xml) {\n            var elem,\n                newUnmatched = [],\n                i = 0,\n                len = unmatched.length,\n                mapped = map != null;\n\n            for (; i < len; i++) {\n                if (elem = unmatched[i]) {\n                    if (!filter || filter(elem, context, xml)) {\n                        newUnmatched.push(elem);\n                        if (mapped) {\n                            map.push(i);\n                        }\n                    }\n                }\n            }\n\n            return newUnmatched;\n        }\n\n        function setMatcher(\n            preFilter,\n            selector,\n            matcher,\n            postFilter,\n            postFinder,\n            postSelector\n        ) {\n            if (postFilter && !postFilter[expando]) {\n                postFilter = setMatcher(postFilter);\n            }\n            if (postFinder && !postFinder[expando]) {\n                postFinder = setMatcher(postFinder, postSelector);\n            }\n            return markFunction(function(seed, results, context, xml) {\n                var temp,\n                    i,\n                    elem,\n                    preMap = [],\n                    postMap = [],\n                    preexisting = results.length,\n                    // Get initial elements from seed or context\n                    elems = seed ||\n                        multipleContexts(\n                            selector || \"*\",\n                            context.nodeType ? [ context ] : context,\n                            []\n                        ),\n                    // Prefilter to get matcher input, preserving a map for seed-results synchronization\n                    matcherIn = preFilter && (seed || !selector)\n                        ? condense(elems, preMap, preFilter, context, xml)\n                        : elems,\n                    matcherOut = matcher\n                        ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n                        postFinder ||\n                            (seed ? preFilter : preexisting || postFilter)\n                            ? // ...intermediate processing is necessary\n                            []\n                            : // ...otherwise use results directly\n                            results\n                        : matcherIn;\n\n                // Find primary matches\n                if (matcher) {\n                    matcher(matcherIn, matcherOut, context, xml);\n                }\n\n                // Apply postFilter\n                if (postFilter) {\n                    temp = condense(matcherOut, postMap);\n                    postFilter(temp, [], context, xml);\n\n                    // Un-match failing elements by moving them back to matcherIn\n                    i = temp.length;\n                    while (i--) {\n                        if (elem = temp[i]) {\n                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n                        }\n                    }\n                }\n\n                if (seed) {\n                    if (postFinder || preFilter) {\n                        if (postFinder) {\n                            // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                            temp = [];\n                            i = matcherOut.length;\n                            while (i--) {\n                                if (elem = matcherOut[i]) {\n                                    // Restore matcherIn since elem is not yet a final match\n                                    temp.push(matcherIn[i] = elem);\n                                }\n                            }\n                            postFinder(null, matcherOut = [], temp, xml);\n                        }\n\n                        // Move matched elements from seed to results to keep them synchronized\n                        i = matcherOut.length;\n                        while (i--) {\n                            if (\n                                (elem = matcherOut[i]) &&\n                                    (temp = postFinder\n                                        ? indexOf(seed, elem)\n                                        : preMap[i]) >\n                                        -1\n                            ) {\n                                seed[temp] = !(results[temp] = elem);\n                            }\n                        }\n                    }\n                    // Add elements to results, through postFinder if defined\n                } else {\n                    matcherOut = condense(\n                        matcherOut === results\n                            ? matcherOut.splice(preexisting, matcherOut.length)\n                            : matcherOut\n                    );\n                    if (postFinder) {\n                        postFinder(null, results, matcherOut, xml);\n                    } else {\n                        push.apply(results, matcherOut);\n                    }\n                }\n            });\n        }\n\n        function matcherFromTokens(tokens) {\n            var checkContext,\n                matcher,\n                j,\n                len = tokens.length,\n                leadingRelative = Expr.relative[tokens[0].type],\n                implicitRelative = leadingRelative || Expr.relative[\" \"],\n                i = leadingRelative ? 1 : 0,\n                // The foundational matcher ensures that elements are reachable from top-level context(s)\n                matchContext = addCombinator(\n                    function(elem) {\n                        return elem === checkContext;\n                    },\n                    implicitRelative,\n                    true\n                ),\n                matchAnyContext = addCombinator(\n                    function(elem) {\n                        return indexOf(checkContext, elem) > -1;\n                    },\n                    implicitRelative,\n                    true\n                ),\n                matchers = [\n                    function(elem, context, xml) {\n                        var ret = !leadingRelative &&\n                            (xml || context !== outermostContext) ||\n                            ((checkContext = context).nodeType\n                                ? matchContext(elem, context, xml)\n                                : matchAnyContext(elem, context, xml));\n                        // Avoid hanging onto element (issue #299)\n                        checkContext = null;\n                        return ret;\n                    }\n                ];\n\n            for (; i < len; i++) {\n                if (matcher = Expr.relative[tokens[i].type]) {\n                    matchers = [\n                        addCombinator(elementMatcher(matchers), matcher)\n                    ];\n                } else {\n                    matcher = Expr.filter[tokens[i].type].apply(\n                        null,\n                        tokens[i].matches\n                    );\n\n                    // Return special upon seeing a positional matcher\n                    if (matcher[expando]) {\n                        // Find the next relative operator (if any) for proper handling\n                        j = ++i;\n                        for (; j < len; j++) {\n                            if (Expr.relative[tokens[j].type]) {\n                                break;\n                            }\n                        }\n                        return setMatcher(\n                            i > 1 && elementMatcher(matchers),\n                            i > 1 && toSelector(\n                                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n                                    tokens\n                                        .slice(0, i - 1)\n                                        .concat({\n                                            value: tokens[i - 2].type === \" \"\n                                                ? \"*\"\n                                                : \"\"\n                                        })\n                                ).replace(rtrim, \"$1\"),\n                            matcher,\n                            i < j && matcherFromTokens(tokens.slice(i, j)),\n                            j < len &&\n                                matcherFromTokens(tokens = tokens.slice(j)),\n                            j < len && toSelector(tokens)\n                        );\n                    }\n                    matchers.push(matcher);\n                }\n            }\n\n            return elementMatcher(matchers);\n        }\n\n        function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n            var bySet = setMatchers.length > 0,\n                byElement = elementMatchers.length > 0,\n                superMatcher = function(\n                    seed,\n                    context,\n                    xml,\n                    results,\n                    outermost\n                ) {\n                    var elem,\n                        j,\n                        matcher,\n                        matchedCount = 0,\n                        i = \"0\",\n                        unmatched = seed && [],\n                        setMatched = [],\n                        contextBackup = outermostContext,\n                        // We must always have either seed elements or outermost context\n                        elems = seed ||\n                            byElement && Expr.find[\"TAG\"](\"*\", outermost),\n                        // Use integer dirruns iff this is the outermost matcher\n                        dirrunsUnique = dirruns += contextBackup == null\n                            ? 1\n                            : Math.random() || 0.1,\n                        len = elems.length;\n\n                    if (outermost) {\n                        outermostContext = context === document ||\n                            context ||\n                            outermost;\n                    }\n\n                    // Add elements passing elementMatchers directly to results\n                    // Support: IE<9, Safari\n                    // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n                    for (; i !== len && (elem = elems[i]) != null; i++) {\n                        if (byElement && elem) {\n                            j = 0;\n                            if (!context && elem.ownerDocument !== document) {\n                                setDocument(elem);\n                                xml = !documentIsHTML;\n                            }\n                            while (matcher = elementMatchers[j++]) {\n                                if (matcher(elem, context || document, xml)) {\n                                    results.push(elem);\n                                    break;\n                                }\n                            }\n                            if (outermost) {\n                                dirruns = dirrunsUnique;\n                            }\n                        }\n\n                        // Track unmatched elements for set filters\n                        if (bySet) {\n                            // They will have gone through all possible matchers\n                            if (elem = !matcher && elem) {\n                                matchedCount--;\n                            }\n\n                            // Lengthen the array for every element, matched or not\n                            if (seed) {\n                                unmatched.push(elem);\n                            }\n                        }\n                    }\n\n                    // `i` is now the count of elements visited above, and adding it to `matchedCount`\n                    // makes the latter nonnegative.\n                    matchedCount += i;\n\n                    // Apply set filters to unmatched elements\n                    // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n                    // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n                    // no element matchers and no seed.\n                    // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n                    // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n                    // numerically zero.\n                    if (bySet && i !== matchedCount) {\n                        j = 0;\n                        while (matcher = setMatchers[j++]) {\n                            matcher(unmatched, setMatched, context, xml);\n                        }\n\n                        if (seed) {\n                            // Reintegrate element matches to eliminate the need for sorting\n                            if (matchedCount > 0) {\n                                while (i--) {\n                                    if (!(unmatched[i] || setMatched[i])) {\n                                        setMatched[i] = pop.call(results);\n                                    }\n                                }\n                            }\n\n                            // Discard index placeholder values to get only actual matches\n                            setMatched = condense(setMatched);\n                        }\n\n                        // Add matches to results\n                        push.apply(results, setMatched);\n\n                        // Seedless set matches succeeding multiple successful matchers stipulate sorting\n                        if (\n                            outermost &&\n                                !seed &&\n                                setMatched.length > 0 &&\n                                matchedCount + setMatchers.length > 1\n                        ) {\n                            Sizzle.uniqueSort(results);\n                        }\n                    }\n\n                    // Override manipulation of globals by nested matchers\n                    if (outermost) {\n                        dirruns = dirrunsUnique;\n                        outermostContext = contextBackup;\n                    }\n\n                    return unmatched;\n                };\n\n            return bySet ? markFunction(superMatcher) : superMatcher;\n        }\n\n        compile = Sizzle.compile = function(\n            selector,\n            match /* Internal Use Only */\n        ) {\n            var i,\n                setMatchers = [],\n                elementMatchers = [],\n                cached = compilerCache[selector + \" \"];\n\n            if (!cached) {\n                // Generate a function of recursive functions that can be used to check each element\n                if (!match) {\n                    match = tokenize(selector);\n                }\n                i = match.length;\n                while (i--) {\n                    cached = matcherFromTokens(match[i]);\n                    if (cached[expando]) {\n                        setMatchers.push(cached);\n                    } else {\n                        elementMatchers.push(cached);\n                    }\n                }\n\n                // Cache the compiled function\n                cached = compilerCache(\n                    selector,\n                    matcherFromGroupMatchers(elementMatchers, setMatchers)\n                );\n\n                // Save selector and tokenization\n                cached.selector = selector;\n            }\n            return cached;\n        };\n\n        /**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\n        select = Sizzle.select = function(selector, context, results, seed) {\n            var i,\n                tokens,\n                token,\n                type,\n                find,\n                compiled = typeof selector === \"function\" && selector,\n                match = !seed &&\n                    tokenize(selector = compiled.selector || selector);\n\n            results = results || [];\n\n            // Try to minimize operations if there is only one selector in the list and no seed\n            // (the latter of which guarantees us context)\n            if (match.length === 1) {\n                // Reduce context if the leading compound selector is an ID\n                tokens = match[0] = match[0].slice(0);\n                if (\n                    tokens.length > 2 &&\n                        (token = tokens[0]).type === \"ID\" &&\n                        context.nodeType === 9 &&\n                        documentIsHTML &&\n                        Expr.relative[tokens[1].type]\n                ) {\n                    context = (Expr.find[\"ID\"](\n                        token.matches[0].replace(runescape, funescape),\n                        context\n                    ) ||\n                        [])[0];\n                    if (!context) {\n                        return results;\n                        // Precompiled matchers will still verify ancestry, so step up a level\n                    } else if (compiled) {\n                        context = context.parentNode;\n                    }\n\n                    selector = selector.slice(tokens.shift().value.length);\n                }\n\n                // Fetch a seed set for right-to-left matching\n                i = matchExpr[\"needsContext\"].test(selector)\n                    ? 0\n                    : tokens.length;\n                while (i--) {\n                    token = tokens[i];\n\n                    // Abort if we hit a combinator\n                    if (Expr.relative[type = token.type]) {\n                        break;\n                    }\n                    if (find = Expr.find[type]) {\n                        // Search, expanding context for leading sibling combinators\n                        if (\n                            seed = find(\n                                token.matches[0].replace(runescape, funescape),\n                                rsibling.test(tokens[0].type) &&\n                                    testContext(context.parentNode) ||\n                                    context\n                            )\n                        ) {\n                            // If seed is empty or no tokens remain, we can return early\n                            tokens.splice(i, 1);\n                            selector = seed.length && toSelector(tokens);\n                            if (!selector) {\n                                push.apply(results, seed);\n                                return results;\n                            }\n\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Compile and execute a filtering function if one is not provided\n            // Provide `match` to avoid retokenization if we modified the selector above\n            (compiled ||\n                compile(\n                    selector,\n                    match\n                ))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n            return results;\n        };\n\n        // One-time assignments\n        // Sort stability\n        support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") ===\n            expando;\n\n        // Support: Chrome 14-35+\n        // Always assume duplicates if they aren't passed to the comparison function\n        support.detectDuplicates = !!hasDuplicate;\n\n        // Initialize against the default document\n        setDocument();\n\n        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n        // Detached nodes confoundingly follow *each other*\n        support.sortDetached = assert(function(el) {\n            // Should return 1, but returns 4 (following)\n            return el.compareDocumentPosition(\n                document.createElement(\"fieldset\")\n            ) &\n                1;\n        });\n\n        // Support: IE<8\n        // Prevent attribute/property \"interpolation\"\n        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n        if (!assert(function(el) {\n                el.innerHTML = \"<a href='#'></a>\";\n                return el.firstChild.getAttribute(\"href\") === \"#\";\n            })) {\n            addHandle(\"type|href|height|width\", function(elem, name, isXML) {\n                if (!isXML) {\n                    return elem.getAttribute(\n                        name,\n                        name.toLowerCase() === \"type\" ? 1 : 2\n                    );\n                }\n            });\n        }\n\n        // Support: IE<9\n        // Use defaultValue in place of getAttribute(\"value\")\n        if (!support.attributes || !assert(function(el) {\n                    el.innerHTML = \"<input/>\";\n                    el.firstChild.setAttribute(\"value\", \"\");\n                    return el.firstChild.getAttribute(\"value\") === \"\";\n                })) {\n            addHandle(\"value\", function(elem, name, isXML) {\n                if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n                    return elem.defaultValue;\n                }\n            });\n        }\n\n        // Support: IE<9\n        // Use getAttributeNode to fetch booleans when getAttribute lies\n        if (!assert(function(el) {\n                return el.getAttribute(\"disabled\") == null;\n            })) {\n            addHandle(booleans, function(elem, name, isXML) {\n                var val;\n                if (!isXML) {\n                    return elem[name] === true\n                        ? name.toLowerCase()\n                        : (val = elem.getAttributeNode(name)) && val.specified\n                            ? val.value\n                            : null;\n                }\n            });\n        }\n\n        return Sizzle;\n    })(window);\n\n    jQuery.find = Sizzle;\n    jQuery.expr = Sizzle.selectors;\n\n    // Deprecated\n    jQuery.expr[\":\"] = jQuery.expr.pseudos;\n    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n    jQuery.text = Sizzle.getText;\n    jQuery.isXMLDoc = Sizzle.isXML;\n    jQuery.contains = Sizzle.contains;\n    jQuery.escapeSelector = Sizzle.escape;\n\n    var dir = function(elem, dir, until) {\n        var matched = [], truncate = until !== undefined;\n\n        while ((elem = elem[dir]) && elem.nodeType !== 9) {\n            if (elem.nodeType === 1) {\n                if (truncate && jQuery(elem).is(until)) {\n                    break;\n                }\n                matched.push(elem);\n            }\n        }\n        return matched;\n    };\n\n    var siblings = function(n, elem) {\n        var matched = [];\n\n        for (; n; n = n.nextSibling) {\n            if (n.nodeType === 1 && n !== elem) {\n                matched.push(n);\n            }\n        }\n\n        return matched;\n    };\n\n    var rneedsContext = jQuery.expr.match.needsContext;\n\n    var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n\n    var risSimple = /^.[^:#\\[\\.,]*$/;\n\n    // Implement the identical functionality for filter and not\n    function winnow(elements, qualifier, not) {\n        if (jQuery.isFunction(qualifier)) {\n            return jQuery.grep(elements, function(elem, i) {\n                return !!qualifier.call(elem, i, elem) !== not;\n            });\n        }\n\n        // Single element\n        if (qualifier.nodeType) {\n            return jQuery.grep(elements, function(elem) {\n                return elem === qualifier !== not;\n            });\n        }\n\n        // Arraylike of elements (jQuery, arguments, Array)\n        if (typeof qualifier !== \"string\") {\n            return jQuery.grep(elements, function(elem) {\n                return indexOf.call(qualifier, elem) > -1 !== not;\n            });\n        }\n\n        // Simple selector that can be filtered directly, removing non-Elements\n        if (risSimple.test(qualifier)) {\n            return jQuery.filter(qualifier, elements, not);\n        }\n\n        // Complex selector, compare the two sets, removing non-Elements\n        qualifier = jQuery.filter(qualifier, elements);\n        return jQuery.grep(elements, function(elem) {\n            return indexOf.call(qualifier, elem) > -1 !== not &&\n                elem.nodeType === 1;\n        });\n    }\n\n    jQuery.filter = function(expr, elems, not) {\n        var elem = elems[0];\n\n        if (not) {\n            expr = \":not(\" + expr + \")\";\n        }\n\n        if (elems.length === 1 && elem.nodeType === 1) {\n            return jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [];\n        }\n\n        return jQuery.find.matches(\n            expr,\n            jQuery.grep(elems, function(elem) {\n                return elem.nodeType === 1;\n            })\n        );\n    };\n\n    jQuery.fn.extend({\n        find: function(selector) {\n            var i, ret, len = this.length, self = this;\n\n            if (typeof selector !== \"string\") {\n                return this.pushStack(\n                    jQuery(selector).filter(function() {\n                        for (i = 0; i < len; i++) {\n                            if (jQuery.contains(self[i], this)) {\n                                return true;\n                            }\n                        }\n                    })\n                );\n            }\n\n            ret = this.pushStack([]);\n\n            for (i = 0; i < len; i++) {\n                jQuery.find(selector, self[i], ret);\n            }\n\n            return len > 1 ? jQuery.uniqueSort(ret) : ret;\n        },\n        filter: function(selector) {\n            return this.pushStack(winnow(this, selector || [], false));\n        },\n        not: function(selector) {\n            return this.pushStack(winnow(this, selector || [], true));\n        },\n        is: function(selector) {\n            return !!winnow(\n                this,\n                // If this is a positional/relative selector, check membership in the returned set\n                // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n                typeof selector === \"string\" && rneedsContext.test(selector)\n                    ? jQuery(selector)\n                    : selector || [],\n                false\n            ).length;\n        }\n    });\n\n    // Initialize a jQuery object\n    // A central reference to the root jQuery(document)\n    var rootjQuery,\n        // A simple way to check for HTML strings\n        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n        // Strict HTML recognition (#11290: must start with <)\n        // Shortcut simple #id case for speed\n        rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n        init = jQuery.fn.init = function(selector, context, root) {\n            var match, elem;\n\n            // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n            if (!selector) {\n                return this;\n            }\n\n            // Method init() accepts an alternate rootjQuery\n            // so migrate can support jQuery.sub (gh-2101)\n            root = root || rootjQuery;\n\n            // Handle HTML strings\n            if (typeof selector === \"string\") {\n                if (\n                    selector[0] === \"<\" &&\n                        selector[selector.length - 1] === \">\" &&\n                        selector.length >= 3\n                ) {\n                    // Assume that strings that start and end with <> are HTML and skip the regex check\n                    match = [ null, selector, null ];\n                } else {\n                    match = rquickExpr.exec(selector);\n                }\n\n                // Match html or make sure no context is specified for #id\n                if (match && (match[1] || !context)) {\n                    // HANDLE: $(html) -> $(array)\n                    if (match[1]) {\n                        context = context instanceof jQuery\n                            ? context[0]\n                            : context;\n\n                        // Option to run scripts is true for back-compat\n                        // Intentionally let the error be thrown if parseHTML is not present\n                        jQuery.merge(\n                            this,\n                            jQuery.parseHTML(\n                                match[1],\n                                context && context.nodeType\n                                    ? context.ownerDocument || context\n                                    : document,\n                                true\n                            )\n                        );\n\n                        // HANDLE: $(html, props)\n                        if (\n                            rsingleTag.test(match[1]) &&\n                                jQuery.isPlainObject(context)\n                        ) {\n                            for (match in context) {\n                                // Properties of context are called as methods if possible\n                                if (jQuery.isFunction(this[match])) {\n                                    this[match](context[match]);\n                                    // ...and otherwise set as attributes\n                                } else {\n                                    this.attr(match, context[match]);\n                                }\n                            }\n                        }\n\n                        return this;\n                        // HANDLE: $(#id)\n                    } else {\n                        elem = document.getElementById(match[2]);\n\n                        if (elem) {\n                            // Inject the element directly into the jQuery object\n                            this[0] = elem;\n                            this.length = 1;\n                        }\n                        return this;\n                    }\n                    // HANDLE: $(expr, $(...))\n                } else if (!context || context.jquery) {\n                    return (context || root).find(selector);\n                    // HANDLE: $(expr, context)\n                    // (which is just equivalent to: $(context).find(expr)\n                } else {\n                    return this.constructor(context).find(selector);\n                }\n                // HANDLE: $(DOMElement)\n            } else if (selector.nodeType) {\n                this[0] = selector;\n                this.length = 1;\n                return this;\n                // HANDLE: $(function)\n                // Shortcut for document ready\n            } else if (jQuery.isFunction(selector)) {\n                return root.ready !== undefined\n                    ? root.ready(selector)\n                    : // Execute immediately if ready is not present\n                    selector(jQuery);\n            }\n\n            return jQuery.makeArray(selector, this);\n        };\n\n    // Give the init function the jQuery prototype for later instantiation\n    init.prototype = jQuery.fn;\n\n    // Initialize central reference\n    rootjQuery = jQuery(document);\n\n    var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n        // Methods guaranteed to produce a unique set when starting from a unique set\n        guaranteedUnique = {\n            children: true,\n            contents: true,\n            next: true,\n            prev: true\n        };\n\n    jQuery.fn.extend({\n        has: function(target) {\n            var targets = jQuery(target, this), l = targets.length;\n\n            return this.filter(function() {\n                var i = 0;\n                for (; i < l; i++) {\n                    if (jQuery.contains(this, targets[i])) {\n                        return true;\n                    }\n                }\n            });\n        },\n        closest: function(selectors, context) {\n            var cur,\n                i = 0,\n                l = this.length,\n                matched = [],\n                targets = typeof selectors !== \"string\" && jQuery(selectors);\n\n            // Positional selectors never match, since there's no _selection_ context\n            if (!rneedsContext.test(selectors)) {\n                for (; i < l; i++) {\n                    for (\n                        cur = this[i];\n                        cur && cur !== context;\n                        cur = cur.parentNode\n                    ) {\n                        // Always skip document fragments\n                        if (\n                            cur.nodeType < 11 &&\n                                (targets\n                                    ? targets.index(cur) > -1\n                                    : // Don't pass non-elements to Sizzle\n                                    cur.nodeType === 1 &&\n                                        jQuery.find.matchesSelector(\n                                            cur,\n                                            selectors\n                                        ))\n                        ) {\n                            matched.push(cur);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return this.pushStack(\n                matched.length > 1 ? jQuery.uniqueSort(matched) : matched\n            );\n        },\n        // Determine the position of an element within the set\n        index: function(elem) {\n            // No argument, return index in parent\n            if (!elem) {\n                return this[0] && this[0].parentNode\n                    ? this.first().prevAll().length\n                    : -1;\n            }\n\n            // Index in selector\n            if (typeof elem === \"string\") {\n                return indexOf.call(jQuery(elem), this[0]);\n            }\n\n            // Locate the position of the desired element\n            return indexOf.call(\n                this,\n                // If it receives a jQuery object, the first element is used\n                elem.jquery ? elem[0] : elem\n            );\n        },\n        add: function(selector, context) {\n            return this.pushStack(\n                jQuery.uniqueSort(\n                    jQuery.merge(this.get(), jQuery(selector, context))\n                )\n            );\n        },\n        addBack: function(selector) {\n            return this.add(\n                selector == null\n                    ? this.prevObject\n                    : this.prevObject.filter(selector)\n            );\n        }\n    });\n\n    function sibling(cur, dir) {\n        while ((cur = cur[dir]) && cur.nodeType !== 1) {\n        }\n        return cur;\n    }\n\n    jQuery.each(\n        {\n            parent: function(elem) {\n                var parent = elem.parentNode;\n                return parent && parent.nodeType !== 11 ? parent : null;\n            },\n            parents: function(elem) {\n                return dir(elem, \"parentNode\");\n            },\n            parentsUntil: function(elem, i, until) {\n                return dir(elem, \"parentNode\", until);\n            },\n            next: function(elem) {\n                return sibling(elem, \"nextSibling\");\n            },\n            prev: function(elem) {\n                return sibling(elem, \"previousSibling\");\n            },\n            nextAll: function(elem) {\n                return dir(elem, \"nextSibling\");\n            },\n            prevAll: function(elem) {\n                return dir(elem, \"previousSibling\");\n            },\n            nextUntil: function(elem, i, until) {\n                return dir(elem, \"nextSibling\", until);\n            },\n            prevUntil: function(elem, i, until) {\n                return dir(elem, \"previousSibling\", until);\n            },\n            siblings: function(elem) {\n                return siblings((elem.parentNode || {}).firstChild, elem);\n            },\n            children: function(elem) {\n                return siblings(elem.firstChild);\n            },\n            contents: function(elem) {\n                return elem.contentDocument ||\n                    jQuery.merge([], elem.childNodes);\n            }\n        },\n        function(name, fn) {\n            jQuery.fn[name] = function(until, selector) {\n                var matched = jQuery.map(this, fn, until);\n\n                if (name.slice(-5) !== \"Until\") {\n                    selector = until;\n                }\n\n                if (selector && typeof selector === \"string\") {\n                    matched = jQuery.filter(selector, matched);\n                }\n\n                if (this.length > 1) {\n                    // Remove duplicates\n                    if (!guaranteedUnique[name]) {\n                        jQuery.uniqueSort(matched);\n                    }\n\n                    // Reverse order for parents* and prev-derivatives\n                    if (rparentsprev.test(name)) {\n                        matched.reverse();\n                    }\n                }\n\n                return this.pushStack(matched);\n            };\n        }\n    );\n    var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n    // Convert String-formatted options into Object-formatted ones\n    function createOptions(options) {\n        var object = {};\n        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {\n            object[flag] = true;\n        });\n        return object;\n    }\n\n    /*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\n    jQuery.Callbacks = function(options) {\n        // Convert options from String-formatted to Object-formatted if needed\n        // (we check in cache first)\n        options = typeof options === \"string\"\n            ? createOptions(options)\n            : jQuery.extend({}, options);\n\n        var // Flag to know if list is currently firing\n        firing,\n            // Last fire value for non-forgettable lists\n            memory,\n            // Flag to know if list was already fired\n            fired,\n            // Flag to prevent firing\n            locked,\n            // Actual callback list\n            list = [],\n            // Queue of execution data for repeatable lists\n            queue = [],\n            // Index of currently firing callback (modified by add/remove as needed)\n            firingIndex = -1,\n            // Fire callbacks\n            fire = function() {\n                // Enforce single-firing\n                locked = options.once;\n\n                // Execute callbacks for all pending executions,\n                // respecting firingIndex overrides and runtime changes\n                fired = firing = true;\n                for (; queue.length; firingIndex = -1) {\n                    memory = queue.shift();\n                    while (++firingIndex < list.length) {\n                        // Run callback and check for early termination\n                        if (\n                            list[firingIndex].apply(memory[0], memory[1]) ===\n                                false &&\n                                options.stopOnFalse\n                        ) {\n                            // Jump to end and forget the data so .add doesn't re-fire\n                            firingIndex = list.length;\n                            memory = false;\n                        }\n                    }\n                }\n\n                // Forget the data if we're done with it\n                if (!options.memory) {\n                    memory = false;\n                }\n\n                firing = false;\n\n                // Clean up if we're done firing for good\n                if (locked) {\n                    // Keep an empty list if we have data for future add calls\n                    if (memory) {\n                        list = [];\n                        // Otherwise, this object is spent\n                    } else {\n                        list = \"\";\n                    }\n                }\n            },\n            // Actual Callbacks object\n            self = {\n                // Add a callback or a collection of callbacks to the list\n                add: function() {\n                    if (list) {\n                        // If we have memory from a past run, we should fire after adding\n                        if (memory && !firing) {\n                            firingIndex = list.length - 1;\n                            queue.push(memory);\n                        }\n\n                        (function add(args) {\n                            jQuery.each(args, function(_, arg) {\n                                if (jQuery.isFunction(arg)) {\n                                    if (!options.unique || !self.has(arg)) {\n                                        list.push(arg);\n                                    }\n                                } else if (\n                                    arg &&\n                                        arg.length &&\n                                        jQuery.type(arg) !== \"string\"\n                                ) {\n                                    // Inspect recursively\n                                    add(arg);\n                                }\n                            });\n                        })(arguments);\n\n                        if (memory && !firing) {\n                            fire();\n                        }\n                    }\n                    return this;\n                },\n                // Remove a callback from the list\n                remove: function() {\n                    jQuery.each(arguments, function(_, arg) {\n                        var index;\n                        while (\n                            (index = jQuery.inArray(arg, list, index)) > -1\n                        ) {\n                            list.splice(index, 1);\n\n                            // Handle firing indexes\n                            if (index <= firingIndex) {\n                                firingIndex--;\n                            }\n                        }\n                    });\n                    return this;\n                },\n                // Check if a given callback is in the list.\n                // If no argument is given, return whether or not list has callbacks attached.\n                has: function(fn) {\n                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n                },\n                // Remove all callbacks from the list\n                empty: function() {\n                    if (list) {\n                        list = [];\n                    }\n                    return this;\n                },\n                // Disable .fire and .add\n                // Abort any current/pending executions\n                // Clear all callbacks and values\n                disable: function() {\n                    locked = queue = [];\n                    list = memory = \"\";\n                    return this;\n                },\n                disabled: function() {\n                    return !list;\n                },\n                // Disable .fire\n                // Also disable .add unless we have memory (since it would have no effect)\n                // Abort any pending executions\n                lock: function() {\n                    locked = queue = [];\n                    if (!memory && !firing) {\n                        list = memory = \"\";\n                    }\n                    return this;\n                },\n                locked: function() {\n                    return !!locked;\n                },\n                // Call all callbacks with the given context and arguments\n                fireWith: function(context, args) {\n                    if (!locked) {\n                        args = args || [];\n                        args = [ context, args.slice ? args.slice() : args ];\n                        queue.push(args);\n                        if (!firing) {\n                            fire();\n                        }\n                    }\n                    return this;\n                },\n                // Call all the callbacks with the given arguments\n                fire: function() {\n                    self.fireWith(this, arguments);\n                    return this;\n                },\n                // To know if the callbacks have already been called at least once\n                fired: function() {\n                    return !!fired;\n                }\n            };\n\n        return self;\n    };\n\n    function Identity(v) {\n        return v;\n    }\n    function Thrower(ex) {\n        throw ex;\n    }\n\n    function adoptValue(value, resolve, reject) {\n        var method;\n\n        try {\n            // Check for promise aspect first to privilege synchronous behavior\n            if (value && jQuery.isFunction(method = value.promise)) {\n                method.call(value).done(resolve).fail(reject);\n                // Other thenables\n            } else if (value && jQuery.isFunction(method = value.then)) {\n                method.call(value, resolve, reject);\n                // Other non-thenables\n            } else {\n                // Support: Android 4.0 only\n                // Strict mode functions invoked without .call/.apply get global-object context\n                resolve.call(undefined, value);\n            }\n            // For Promises/A+, convert exceptions into rejections\n            // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n            // Deferred#then to conditionally suppress rejection.\n        } catch (value) {\n            // Support: Android 4.0 only\n            // Strict mode functions invoked without .call/.apply get global-object context\n            reject.call(undefined, value);\n        }\n    }\n\n    jQuery.extend({\n        Deferred: function(func) {\n            var tuples = [\n                // action, add listener, callbacks,\n                // ... .then handlers, argument index, [final state]\n                [\n                    \"notify\",\n                    \"progress\",\n                    jQuery.Callbacks(\"memory\"),\n                    jQuery.Callbacks(\"memory\"),\n                    2\n                ],\n                [\n                    \"resolve\",\n                    \"done\",\n                    jQuery.Callbacks(\"once memory\"),\n                    jQuery.Callbacks(\"once memory\"),\n                    0,\n                    \"resolved\"\n                ],\n                [\n                    \"reject\",\n                    \"fail\",\n                    jQuery.Callbacks(\"once memory\"),\n                    jQuery.Callbacks(\"once memory\"),\n                    1,\n                    \"rejected\"\n                ]\n            ],\n                state = \"pending\",\n                promise = {\n                    state: function() {\n                        return state;\n                    },\n                    always: function() {\n                        deferred.done(arguments).fail(arguments);\n                        return this;\n                    },\n                    catch: function(fn) {\n                        return promise.then(null, fn);\n                    },\n                    // Keep pipe for back-compat\n                    pipe: function() /* fnDone, fnFail, fnProgress */\n                    {\n                        var fns = arguments;\n\n                        return jQuery.Deferred(function(newDefer) {\n                            jQuery.each(tuples, function(i, tuple) {\n                                // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n                                var fn = jQuery.isFunction(fns[tuple[4]]) &&\n                                    fns[tuple[4]];\n\n                                // deferred.progress(function() { bind to newDefer or newDefer.notify })\n                                // deferred.done(function() { bind to newDefer or newDefer.resolve })\n                                // deferred.fail(function() { bind to newDefer or newDefer.reject })\n                                deferred[tuple[1]](function() {\n                                    var returned = fn &&\n                                        fn.apply(this, arguments);\n                                    if (\n                                        returned &&\n                                            jQuery.isFunction(returned.promise)\n                                    ) {\n                                        returned\n                                            .promise()\n                                            .progress(newDefer.notify)\n                                            .done(newDefer.resolve)\n                                            .fail(newDefer.reject);\n                                    } else {\n                                        newDefer[tuple[0] + \"With\"](\n                                            this,\n                                            fn ? [ returned ] : arguments\n                                        );\n                                    }\n                                });\n                            });\n                            fns = null;\n                        }).promise();\n                    },\n                    then: function(onFulfilled, onRejected, onProgress) {\n                        var maxDepth = 0;\n                        function resolve(depth, deferred, handler, special) {\n                            return function() {\n                                var that = this,\n                                    args = arguments,\n                                    mightThrow = function() {\n                                        var returned, then;\n\n                                        // Support: Promises/A+ section 2.3.3.3.3\n                                        // https://promisesaplus.com/#point-59\n                                        // Ignore double-resolution attempts\n                                        if (depth < maxDepth) {\n                                            return;\n                                        }\n\n                                        returned = handler.apply(that, args);\n\n                                        // Support: Promises/A+ section 2.3.1\n                                        // https://promisesaplus.com/#point-48\n                                        if (returned === deferred.promise()) {\n                                            throw new TypeError(\n                                                \"Thenable self-resolution\"\n                                            );\n                                        }\n\n                                        // Support: Promises/A+ sections 2.3.3.1, 3.5\n                                        // https://promisesaplus.com/#point-54\n                                        // https://promisesaplus.com/#point-75\n                                        // Retrieve `then` only once\n                                        then = // Support: Promises/A+ section 2.3.4\n                                        // https://promisesaplus.com/#point-64\n                                        // Only check objects and functions for thenability\n                                        returned &&\n                                            (typeof returned === \"object\" ||\n                                                typeof returned ===\n                                                    \"function\") &&\n                                            returned.then;\n\n                                        // Handle a returned thenable\n                                        if (jQuery.isFunction(then)) {\n                                            // Special processors (notify) just wait for resolution\n                                            if (special) {\n                                                then.call(\n                                                    returned,\n                                                    resolve(\n                                                        maxDepth,\n                                                        deferred,\n                                                        Identity,\n                                                        special\n                                                    ),\n                                                    resolve(\n                                                        maxDepth,\n                                                        deferred,\n                                                        Thrower,\n                                                        special\n                                                    )\n                                                );\n                                                // Normal processors (resolve) also hook into progress\n                                            } else {\n                                                // ...and disregard older resolution values\n                                                maxDepth++;\n\n                                                then.call(\n                                                    returned,\n                                                    resolve(\n                                                        maxDepth,\n                                                        deferred,\n                                                        Identity,\n                                                        special\n                                                    ),\n                                                    resolve(\n                                                        maxDepth,\n                                                        deferred,\n                                                        Thrower,\n                                                        special\n                                                    ),\n                                                    resolve(\n                                                        maxDepth,\n                                                        deferred,\n                                                        Identity,\n                                                        deferred.notifyWith\n                                                    )\n                                                );\n                                            }\n                                            // Handle all other returned values\n                                        } else {\n                                            // Only substitute handlers pass on context\n                                            // and multiple values (non-spec behavior)\n                                            if (handler !== Identity) {\n                                                that = undefined;\n                                                args = [ returned ];\n                                            }\n\n                                            // Process the value(s)\n                                            // Default process is resolve\n                                            (special ||\n                                                deferred.resolveWith)(that, args);\n                                        }\n                                    },\n                                    // Only normal processors (resolve) catch and reject exceptions\n                                    process = special\n                                        ? mightThrow\n                                        : (function() {\n                                            try {\n                                                mightThrow();\n                                            } catch (e) {\n                                                if (\n                                                    jQuery.Deferred.exceptionHook\n                                                ) {\n                                                    jQuery.Deferred.exceptionHook(\n                                                        e,\n                                                        process.stackTrace\n                                                    );\n                                                }\n\n                                                // Support: Promises/A+ section 2.3.3.3.4.1\n                                                // https://promisesaplus.com/#point-61\n                                                // Ignore post-resolution exceptions\n                                                if (depth + 1 >= maxDepth) {\n                                                    // Only substitute handlers pass on context\n                                                    // and multiple values (non-spec behavior)\n                                                    if (handler !== Thrower) {\n                                                        that = undefined;\n                                                        args = [ e ];\n                                                    }\n\n                                                    deferred.rejectWith(\n                                                        that,\n                                                        args\n                                                    );\n                                                }\n                                            }\n                                        });\n\n                                // Support: Promises/A+ section 2.3.3.3.1\n                                // https://promisesaplus.com/#point-57\n                                // Re-resolve promises immediately to dodge false rejection from\n                                // subsequent errors\n                                if (depth) {\n                                    process();\n                                } else {\n                                    // Call an optional hook to record the stack, in case of exception\n                                    // since it's otherwise lost when execution goes async\n                                    if (jQuery.Deferred.getStackHook) {\n                                        process.stackTrace = jQuery.Deferred.getStackHook();\n                                    }\n                                    window.setTimeout(process);\n                                }\n                            };\n                        }\n\n                        return jQuery.Deferred(function(newDefer) {\n                            // progress_handlers.add( ... )\n                            tuples[0][3].add(\n                                resolve(\n                                    0,\n                                    newDefer,\n                                    jQuery.isFunction(onProgress)\n                                        ? onProgress\n                                        : Identity,\n                                    newDefer.notifyWith\n                                )\n                            );\n\n                            // fulfilled_handlers.add( ... )\n                            tuples[1][3].add(\n                                resolve(\n                                    0,\n                                    newDefer,\n                                    jQuery.isFunction(onFulfilled)\n                                        ? onFulfilled\n                                        : Identity\n                                )\n                            );\n\n                            // rejected_handlers.add( ... )\n                            tuples[2][3].add(\n                                resolve(\n                                    0,\n                                    newDefer,\n                                    jQuery.isFunction(onRejected)\n                                        ? onRejected\n                                        : Thrower\n                                )\n                            );\n                        }).promise();\n                    },\n                    // Get a promise for this deferred\n                    // If obj is provided, the promise aspect is added to the object\n                    promise: function(obj) {\n                        return obj != null\n                            ? jQuery.extend(obj, promise)\n                            : promise;\n                    }\n                },\n                deferred = {};\n\n            // Add list-specific methods\n            jQuery.each(tuples, function(i, tuple) {\n                var list = tuple[2], stateString = tuple[5];\n\n                // promise.progress = list.add\n                // promise.done = list.add\n                // promise.fail = list.add\n                promise[tuple[1]] = list.add;\n\n                // Handle state\n                if (stateString) {\n                    list.add(\n                        function() {\n                            // state = \"resolved\" (i.e., fulfilled)\n                            // state = \"rejected\"\n                            state = stateString;\n                        },\n                        // rejected_callbacks.disable\n                        // fulfilled_callbacks.disable\n                        tuples[3 - i][2].disable,\n                        // progress_callbacks.lock\n                        tuples[0][2].lock\n                    );\n                }\n\n                // progress_handlers.fire\n                // fulfilled_handlers.fire\n                // rejected_handlers.fire\n                list.add(tuple[3].fire);\n\n                // deferred.notify = function() { deferred.notifyWith(...) }\n                // deferred.resolve = function() { deferred.resolveWith(...) }\n                // deferred.reject = function() { deferred.rejectWith(...) }\n                deferred[tuple[0]] = function() {\n                    deferred[tuple[0] +\n                        \"With\"](this === deferred ? undefined : this, arguments);\n                    return this;\n                };\n\n                // deferred.notifyWith = list.fireWith\n                // deferred.resolveWith = list.fireWith\n                // deferred.rejectWith = list.fireWith\n                deferred[tuple[0] + \"With\"] = list.fireWith;\n            });\n\n            // Make the deferred a promise\n            promise.promise(deferred);\n\n            // Call given func if any\n            if (func) {\n                func.call(deferred, deferred);\n            }\n\n            // All done!\n            return deferred;\n        },\n        // Deferred helper\n        when: function(singleValue) {\n            var // count of uncompleted subordinates\n            remaining = arguments.length,\n                // count of unprocessed arguments\n                i = remaining,\n                // subordinate fulfillment data\n                resolveContexts = Array(i),\n                resolveValues = slice.call(arguments),\n                // the master Deferred\n                master = jQuery.Deferred(),\n                // subordinate callback factory\n                updateFunc = function(i) {\n                    return function(value) {\n                        resolveContexts[i] = this;\n                        resolveValues[i] = arguments.length > 1\n                            ? slice.call(arguments)\n                            : value;\n                        if (!--remaining) {\n                            master.resolveWith(resolveContexts, resolveValues);\n                        }\n                    };\n                };\n\n            // Single- and empty arguments are adopted like Promise.resolve\n            if (remaining <= 1) {\n                adoptValue(\n                    singleValue,\n                    master.done(updateFunc(i)).resolve,\n                    master.reject\n                );\n\n                // Use .then() to unwrap secondary thenables (cf. gh-3000)\n                if (\n                    master.state() === \"pending\" ||\n                        jQuery.isFunction(\n                            resolveValues[i] && resolveValues[i].then\n                        )\n                ) {\n                    return master.then();\n                }\n            }\n\n            // Multiple arguments are aggregated like Promise.all array elements\n            while (i--) {\n                adoptValue(resolveValues[i], updateFunc(i), master.reject);\n            }\n\n            return master.promise();\n        }\n    });\n\n    // These usually indicate a programmer mistake during development,\n    // warn about them ASAP rather than swallowing them by default.\n    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n    jQuery.Deferred.exceptionHook = function(error, stack) {\n        // Support: IE 8 - 9 only\n        // Console exists when dev tools are open, which can happen at any time\n        if (\n            window.console &&\n                window.console.warn &&\n                error &&\n                rerrorNames.test(error.name)\n        ) {\n            window.console.warn(\n                \"jQuery.Deferred exception: \" + error.message,\n                error.stack,\n                stack\n            );\n        }\n    };\n\n    jQuery.readyException = function(error) {\n        window.setTimeout(function() {\n            throw error;\n        });\n    };\n\n    // The deferred used on DOM ready\n    var readyList = jQuery.Deferred();\n\n    jQuery.fn.ready = function(fn) {\n        readyList.then(fn).catch(function(error) {\n            jQuery.readyException(error);\n        });\n\n        return this;\n    };\n\n    jQuery.extend({\n        // Is the DOM ready to be used? Set to true once it occurs.\n        isReady: false,\n        // A counter to track how many items to wait for before\n        // the ready event fires. See #6781\n        readyWait: 1,\n        // Hold (or release) the ready event\n        holdReady: function(hold) {\n            if (hold) {\n                jQuery.readyWait++;\n            } else {\n                jQuery.ready(true);\n            }\n        },\n        // Handle when the DOM is ready\n        ready: function(wait) {\n            // Abort if there are pending holds or we're already ready\n            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n                return;\n            }\n\n            // Remember that the DOM is ready\n            jQuery.isReady = true;\n\n            // If a normal DOM Ready event fired, decrement, and wait if need be\n            if (wait !== true && --jQuery.readyWait > 0) {\n                return;\n            }\n\n            // If there are functions bound, to execute\n            readyList.resolveWith(document, [ jQuery ]);\n        }\n    });\n\n    jQuery.ready.then = readyList.then;\n\n    // The ready event handler and self cleanup method\n    function completed() {\n        document.removeEventListener(\"DOMContentLoaded\", completed);\n        window.removeEventListener(\"load\", completed);\n        jQuery.ready();\n    }\n\n    // Catch cases where $(document).ready() is called\n    // after the browser event has already occurred.\n    // Support: IE <=9 - 10 only\n    // Older IE sometimes signals \"interactive\" too soon\n    if (\n        document.readyState === \"complete\" ||\n            document.readyState !== \"loading\" &&\n                !document.documentElement.doScroll\n    ) {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        window.setTimeout(jQuery.ready);\n    } else {\n        // Use the handy event callback\n        document.addEventListener(\"DOMContentLoaded\", completed);\n\n        // A fallback to window.onload, that will always work\n        window.addEventListener(\"load\", completed);\n    }\n\n    // Multifunctional method to get and set values of a collection\n    // The value/s can optionally be executed if it's a function\n    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {\n        var i = 0, len = elems.length, bulk = key == null;\n\n        // Sets many values\n        if (jQuery.type(key) === \"object\") {\n            chainable = true;\n            for (i in key) {\n                access(elems, fn, i, key[i], true, emptyGet, raw);\n            }\n            // Sets one value\n        } else if (value !== undefined) {\n            chainable = true;\n\n            if (!jQuery.isFunction(value)) {\n                raw = true;\n            }\n\n            if (bulk) {\n                // Bulk operations run against the entire set\n                if (raw) {\n                    fn.call(elems, value);\n                    fn = null;\n                    // ...except when executing function values\n                } else {\n                    bulk = fn;\n                    fn = function(elem, key, value) {\n                        return bulk.call(jQuery(elem), value);\n                    };\n                }\n            }\n\n            if (fn) {\n                for (; i < len; i++) {\n                    fn(\n                        elems[i],\n                        key,\n                        raw ? value : value.call(elems[i], i, fn(elems[i], key))\n                    );\n                }\n            }\n        }\n\n        if (chainable) {\n            return elems;\n        }\n\n        // Gets\n        if (bulk) {\n            return fn.call(elems);\n        }\n\n        return len ? fn(elems[0], key) : emptyGet;\n    };\n    var acceptData = function(owner) {\n        // Accepts only:\n        //  - Node\n        //    - Node.ELEMENT_NODE\n        //    - Node.DOCUMENT_NODE\n        //  - Object\n        //    - Any\n        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n    };\n\n    function Data() {\n        this.expando = jQuery.expando + Data.uid++;\n    }\n\n    Data.uid = 1;\n\n    Data.prototype = {\n        cache: function(owner) {\n            // Check if the owner object already has a cache\n            var value = owner[this.expando];\n\n            // If not, create one\n            if (!value) {\n                value = {};\n\n                // We can accept data for non-element nodes in modern browsers,\n                // but we should not, see #8335.\n                // Always return an empty object.\n                if (acceptData(owner)) {\n                    // If it is a node unlikely to be stringify-ed or looped over\n                    // use plain assignment\n                    if (owner.nodeType) {\n                        owner[this.expando] = value;\n                        // Otherwise secure it in a non-enumerable property\n                        // configurable must be true to allow the property to be\n                        // deleted when data is removed\n                    } else {\n                        Object.defineProperty(owner, this.expando, {\n                            value: value,\n                            configurable: true\n                        });\n                    }\n                }\n            }\n\n            return value;\n        },\n        set: function(owner, data, value) {\n            var prop, cache = this.cache(owner);\n\n            // Handle: [ owner, key, value ] args\n            // Always use camelCase key (gh-2257)\n            if (typeof data === \"string\") {\n                cache[jQuery.camelCase(data)] = value;\n                // Handle: [ owner, { properties } ] args\n            } else {\n                // Copy the properties one-by-one to the cache object\n                for (prop in data) {\n                    cache[jQuery.camelCase(prop)] = data[prop];\n                }\n            }\n            return cache;\n        },\n        get: function(owner, key) {\n            return key === undefined\n                ? this.cache(owner)\n                : // Always use camelCase key (gh-2257)\n                owner[this.expando] &&\n                    owner[this.expando][jQuery.camelCase(key)];\n        },\n        access: function(owner, key, value) {\n            // In cases where either:\n            //\n            //   1. No key was specified\n            //   2. A string key was specified, but no value provided\n            //\n            // Take the \"read\" path and allow the get method to determine\n            // which value to return, respectively either:\n            //\n            //   1. The entire cache object\n            //   2. The data stored at the key\n            //\n            if (\n                key === undefined ||\n                    key && typeof key === \"string\" && value === undefined\n            ) {\n                return this.get(owner, key);\n            }\n\n            // When the key is not a string, or both a key and value\n            // are specified, set or extend (existing objects) with either:\n            //\n            //   1. An object of properties\n            //   2. A key and value\n            //\n            this.set(owner, key, value);\n\n            // Since the \"set\" path can have two possible entry points\n            // return the expected data based on which path was taken[*]\n            return value !== undefined ? value : key;\n        },\n        remove: function(owner, key) {\n            var i, cache = owner[this.expando];\n\n            if (cache === undefined) {\n                return;\n            }\n\n            if (key !== undefined) {\n                // Support array or space separated string of keys\n                if (jQuery.isArray(key)) {\n                    // If key is an array of keys...\n                    // We always set camelCase keys, so remove that.\n                    key = key.map(jQuery.camelCase);\n                } else {\n                    key = jQuery.camelCase(key);\n\n                    // If a key with the spaces exists, use it.\n                    // Otherwise, create an array by matching non-whitespace\n                    key = key in cache\n                        ? [ key ]\n                        : key.match(rnothtmlwhite) || [];\n                }\n\n                i = key.length;\n\n                while (i--) {\n                    delete cache[key[i]];\n                }\n            }\n\n            // Remove the expando if there's no more data\n            if (key === undefined || jQuery.isEmptyObject(cache)) {\n                // Support: Chrome <=35 - 45\n                // Webkit & Blink performance suffers when deleting properties\n                // from DOM nodes, so set to undefined instead\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n                if (owner.nodeType) {\n                    owner[this.expando] = undefined;\n                } else {\n                    delete owner[this.expando];\n                }\n            }\n        },\n        hasData: function(owner) {\n            var cache = owner[this.expando];\n            return cache !== undefined && !jQuery.isEmptyObject(cache);\n        }\n    };\n    var dataPriv = new Data();\n\n    var dataUser = new Data();\n\n    //\tImplementation Summary\n    //\n    //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n    //\t2. Improve the module's maintainability by reducing the storage\n    //\t\tpaths to a single mechanism.\n    //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n    //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n    //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n    //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n    var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/, rmultiDash = /[A-Z]/g;\n\n    function getData(data) {\n        if (data === \"true\") {\n            return true;\n        }\n\n        if (data === \"false\") {\n            return false;\n        }\n\n        if (data === \"null\") {\n            return null;\n        }\n\n        // Only convert to a number if it doesn't change the string\n        if (data === +data + \"\") {\n            return +data;\n        }\n\n        if (rbrace.test(data)) {\n            return JSON.parse(data);\n        }\n\n        return data;\n    }\n\n    function dataAttr(elem, key, data) {\n        var name;\n\n        // If nothing was found internally, try to fetch any\n        // data from the HTML5 data-* attribute\n        if (data === undefined && elem.nodeType === 1) {\n            name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n            data = elem.getAttribute(name);\n\n            if (typeof data === \"string\") {\n                try {\n                    data = getData(data);\n                } catch (e) {\n                }\n\n                // Make sure we set the data so it isn't changed later\n                dataUser.set(elem, key, data);\n            } else {\n                data = undefined;\n            }\n        }\n        return data;\n    }\n\n    jQuery.extend({\n        hasData: function(elem) {\n            return dataUser.hasData(elem) || dataPriv.hasData(elem);\n        },\n        data: function(elem, name, data) {\n            return dataUser.access(elem, name, data);\n        },\n        removeData: function(elem, name) {\n            dataUser.remove(elem, name);\n        },\n        // TODO: Now that all calls to _data and _removeData have been replaced\n        // with direct calls to dataPriv methods, these can be deprecated.\n        _data: function(elem, name, data) {\n            return dataPriv.access(elem, name, data);\n        },\n        _removeData: function(elem, name) {\n            dataPriv.remove(elem, name);\n        }\n    });\n\n    jQuery.fn.extend({\n        data: function(key, value) {\n            var i, name, data, elem = this[0], attrs = elem && elem.attributes;\n\n            // Gets all values\n            if (key === undefined) {\n                if (this.length) {\n                    data = dataUser.get(elem);\n\n                    if (\n                        elem.nodeType === 1 &&\n                            !dataPriv.get(elem, \"hasDataAttrs\")\n                    ) {\n                        i = attrs.length;\n                        while (i--) {\n                            // Support: IE 11 only\n                            // The attrs elements can be null (#14894)\n                            if (attrs[i]) {\n                                name = attrs[i].name;\n                                if (name.indexOf(\"data-\") === 0) {\n                                    name = jQuery.camelCase(name.slice(5));\n                                    dataAttr(elem, name, data[name]);\n                                }\n                            }\n                        }\n                        dataPriv.set(elem, \"hasDataAttrs\", true);\n                    }\n                }\n\n                return data;\n            }\n\n            // Sets multiple values\n            if (typeof key === \"object\") {\n                return this.each(function() {\n                    dataUser.set(this, key);\n                });\n            }\n\n            return access(\n                this,\n                function(value) {\n                    var data;\n\n                    // The calling jQuery object (element matches) is not empty\n                    // (and therefore has an element appears at this[ 0 ]) and the\n                    // `value` parameter was not undefined. An empty jQuery object\n                    // will result in `undefined` for elem = this[ 0 ] which will\n                    // throw an exception if an attempt to read a data cache is made.\n                    if (elem && value === undefined) {\n                        // Attempt to get data from the cache\n                        // The key will always be camelCased in Data\n                        data = dataUser.get(elem, key);\n                        if (data !== undefined) {\n                            return data;\n                        }\n\n                        // Attempt to \"discover\" the data in\n                        // HTML5 custom data-* attrs\n                        data = dataAttr(elem, key);\n                        if (data !== undefined) {\n                            return data;\n                        }\n\n                        // We tried really hard, but the data doesn't exist.\n                        return;\n                    }\n\n                    // Set the data...\n                    this.each(function() {\n                        // We always store the camelCased key\n                        dataUser.set(this, key, value);\n                    });\n                },\n                null,\n                value,\n                arguments.length > 1,\n                null,\n                true\n            );\n        },\n        removeData: function(key) {\n            return this.each(function() {\n                dataUser.remove(this, key);\n            });\n        }\n    });\n\n    jQuery.extend({\n        queue: function(elem, type, data) {\n            var queue;\n\n            if (elem) {\n                type = (type || \"fx\") + \"queue\";\n                queue = dataPriv.get(elem, type);\n\n                // Speed up dequeue by getting out quickly if this is just a lookup\n                if (data) {\n                    if (!queue || jQuery.isArray(data)) {\n                        queue = dataPriv.access(\n                            elem,\n                            type,\n                            jQuery.makeArray(data)\n                        );\n                    } else {\n                        queue.push(data);\n                    }\n                }\n                return queue || [];\n            }\n        },\n        dequeue: function(elem, type) {\n            type = type || \"fx\";\n\n            var queue = jQuery.queue(elem, type),\n                startLength = queue.length,\n                fn = queue.shift(),\n                hooks = jQuery._queueHooks(elem, type),\n                next = function() {\n                    jQuery.dequeue(elem, type);\n                };\n\n            // If the fx queue is dequeued, always remove the progress sentinel\n            if (fn === \"inprogress\") {\n                fn = queue.shift();\n                startLength--;\n            }\n\n            if (fn) {\n                // Add a progress sentinel to prevent the fx queue from being\n                // automatically dequeued\n                if (type === \"fx\") {\n                    queue.unshift(\"inprogress\");\n                }\n\n                // Clear up the last queue stop function\n                delete hooks.stop;\n                fn.call(elem, next, hooks);\n            }\n\n            if (!startLength && hooks) {\n                hooks.empty.fire();\n            }\n        },\n        // Not public - generate a queueHooks object, or return the current one\n        _queueHooks: function(elem, type) {\n            var key = type + \"queueHooks\";\n            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n                    empty: jQuery.Callbacks(\"once memory\").add(function() {\n                        dataPriv.remove(elem, [ type + \"queue\", key ]);\n                    })\n                });\n        }\n    });\n\n    jQuery.fn.extend({\n        queue: function(type, data) {\n            var setter = 2;\n\n            if (typeof type !== \"string\") {\n                data = type;\n                type = \"fx\";\n                setter--;\n            }\n\n            if (arguments.length < setter) {\n                return jQuery.queue(this[0], type);\n            }\n\n            return data === undefined ? this : this.each(function() {\n                    var queue = jQuery.queue(this, type, data);\n\n                    // Ensure a hooks for this queue\n                    jQuery._queueHooks(this, type);\n\n                    if (type === \"fx\" && queue[0] !== \"inprogress\") {\n                        jQuery.dequeue(this, type);\n                    }\n                });\n        },\n        dequeue: function(type) {\n            return this.each(function() {\n                jQuery.dequeue(this, type);\n            });\n        },\n        clearQueue: function(type) {\n            return this.queue(type || \"fx\", []);\n        },\n        // Get a promise resolved when queues of a certain type\n        // are emptied (fx is the type by default)\n        promise: function(type, obj) {\n            var tmp,\n                count = 1,\n                defer = jQuery.Deferred(),\n                elements = this,\n                i = this.length,\n                resolve = function() {\n                    if (!--count) {\n                        defer.resolveWith(elements, [ elements ]);\n                    }\n                };\n\n            if (typeof type !== \"string\") {\n                obj = type;\n                type = undefined;\n            }\n            type = type || \"fx\";\n\n            while (i--) {\n                tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n                if (tmp && tmp.empty) {\n                    count++;\n                    tmp.empty.add(resolve);\n                }\n            }\n            resolve();\n            return defer.promise(obj);\n        }\n    });\n    var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n\n    var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n\n    var cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\n    var isHiddenWithinTree = function(elem, el) {\n        // isHiddenWithinTree might be called from jQuery#filter function;\n        // in that case, element will be second argument\n        elem = el || elem;\n\n        // Inline style trumps all\n        return elem.style.display === \"none\" ||\n            elem.style.display === \"\" && // Otherwise, check computed style\n                // Support: Firefox <=43 - 45\n                // Disconnected elements can have computed display: none, so first confirm that elem is\n                // in the document.\n                jQuery.contains(\n                    elem.ownerDocument,\n                    elem\n                ) && jQuery.css(elem, \"display\") === \"none\";\n    };\n\n    var swap = function(elem, options, callback, args) {\n        var ret, name, old = {};\n\n        // Remember the old values, and insert the new ones\n        for (name in options) {\n            old[name] = elem.style[name];\n            elem.style[name] = options[name];\n        }\n\n        ret = callback.apply(elem, args || []);\n\n        // Revert the old values\n        for (name in options) {\n            elem.style[name] = old[name];\n        }\n\n        return ret;\n    };\n\n    function adjustCSS(elem, prop, valueParts, tween) {\n        var adjusted,\n            scale = 1,\n            maxIterations = 20,\n            currentValue = tween ? (function() {\n                    return tween.cur();\n                }) : (function() {\n                    return jQuery.css(elem, prop, \"\");\n                }),\n            initial = currentValue(),\n            unit = valueParts && valueParts[3] ||\n                (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n            // Starting value computation is required for potential unit mismatches\n            initialInUnit = (jQuery.cssNumber[prop] ||\n                unit !== \"px\" && +initial) &&\n                rcssNum.exec(jQuery.css(elem, prop));\n\n        if (initialInUnit && initialInUnit[3] !== unit) {\n            // Trust units reported by jQuery.css\n            unit = unit || initialInUnit[3];\n\n            // Make sure we update the tween properties later on\n            valueParts = valueParts || [];\n\n            // Iteratively approximate from a nonzero starting point\n            initialInUnit = +initial || 1;\n\n            do {\n                // If previous iteration zeroed out, double until we get *something*.\n                // Use string for doubling so we don't accidentally see scale as unchanged below\n                scale = scale || \".5\";\n\n                // Adjust and apply\n                initialInUnit = initialInUnit / scale;\n                jQuery.style(elem, prop, initialInUnit + unit);\n                // Update scale, tolerating zero or NaN from tween.cur()\n                // Break the loop if scale is unchanged or perfect, or if we've just had enough.\n            } while (scale !== (scale = currentValue() / initial) &&\n                scale !== 1 &&\n                --maxIterations);\n        }\n\n        if (valueParts) {\n            initialInUnit = +initialInUnit || +initial || 0;\n\n            // Apply relative offset (+=/-=) if specified\n            adjusted = valueParts[1]\n                ? initialInUnit + (valueParts[1] + 1) * valueParts[2]\n                : +valueParts[2];\n            if (tween) {\n                tween.unit = unit;\n                tween.start = initialInUnit;\n                tween.end = adjusted;\n            }\n        }\n        return adjusted;\n    }\n\n    var defaultDisplayMap = {};\n\n    function getDefaultDisplay(elem) {\n        var temp,\n            doc = elem.ownerDocument,\n            nodeName = elem.nodeName,\n            display = defaultDisplayMap[nodeName];\n\n        if (display) {\n            return display;\n        }\n\n        temp = doc.body.appendChild(doc.createElement(nodeName));\n        display = jQuery.css(temp, \"display\");\n\n        temp.parentNode.removeChild(temp);\n\n        if (display === \"none\") {\n            display = \"block\";\n        }\n        defaultDisplayMap[nodeName] = display;\n\n        return display;\n    }\n\n    function showHide(elements, show) {\n        var display, elem, values = [], index = 0, length = elements.length;\n\n        // Determine new display value for elements that need to change\n        for (; index < length; index++) {\n            elem = elements[index];\n            if (!elem.style) {\n                continue;\n            }\n\n            display = elem.style.display;\n            if (show) {\n                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n                // check is required in this first loop unless we have a nonempty display value (either\n                // inline or about-to-be-restored)\n                if (display === \"none\") {\n                    values[index] = dataPriv.get(elem, \"display\") || null;\n                    if (!values[index]) {\n                        elem.style.display = \"\";\n                    }\n                }\n                if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n                    values[index] = getDefaultDisplay(elem);\n                }\n            } else {\n                if (display !== \"none\") {\n                    values[index] = \"none\";\n\n                    // Remember what we're overwriting\n                    dataPriv.set(elem, \"display\", display);\n                }\n            }\n        }\n\n        // Set the display of the elements in a second loop to avoid constant reflow\n        for (index = 0; index < length; index++) {\n            if (values[index] != null) {\n                elements[index].style.display = values[index];\n            }\n        }\n\n        return elements;\n    }\n\n    jQuery.fn.extend({\n        show: function() {\n            return showHide(this, true);\n        },\n        hide: function() {\n            return showHide(this);\n        },\n        toggle: function(state) {\n            if (typeof state === \"boolean\") {\n                return state ? this.show() : this.hide();\n            }\n\n            return this.each(function() {\n                if (isHiddenWithinTree(this)) {\n                    jQuery(this).show();\n                } else {\n                    jQuery(this).hide();\n                }\n            });\n        }\n    });\n    var rcheckableType = /^(?:checkbox|radio)$/i;\n\n    var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i;\n\n    var rscriptType = /^$|\\/(?:java|ecma)script/i;\n\n    // We have to close these tags to support XHTML (#13200)\n    var wrapMap = {\n        // Support: IE <=9 only\n        option: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n        // XHTML parsers do not magically insert elements in the\n        // same way that tag soup parsers do. So we cannot shorten\n        // this by omitting <tbody> or other required elements.\n        thead: [ 1, \"<table>\", \"</table>\" ],\n        col: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n        tr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n        td: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n        _default: [ 0, \"\", \"\" ]\n    };\n\n    // Support: IE <=9 only\n    wrapMap.optgroup = wrapMap.option;\n\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n    wrapMap.th = wrapMap.td;\n\n    function getAll(context, tag) {\n        // Support: IE <=9 - 11 only\n        // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n        var ret;\n\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n            ret = context.getElementsByTagName(tag || \"*\");\n        } else if (typeof context.querySelectorAll !== \"undefined\") {\n            ret = context.querySelectorAll(tag || \"*\");\n        } else {\n            ret = [];\n        }\n\n        if (tag === undefined || tag && jQuery.nodeName(context, tag)) {\n            return jQuery.merge([ context ], ret);\n        }\n\n        return ret;\n    }\n\n    // Mark scripts as having already been evaluated\n    function setGlobalEval(elems, refElements) {\n        var i = 0, l = elems.length;\n\n        for (; i < l; i++) {\n            dataPriv.set(\n                elems[i],\n                \"globalEval\",\n                !refElements || dataPriv.get(refElements[i], \"globalEval\")\n            );\n        }\n    }\n\n    var rhtml = /<|&#?\\w+;/;\n\n    function buildFragment(elems, context, scripts, selection, ignored) {\n        var elem,\n            tmp,\n            tag,\n            wrap,\n            contains,\n            j,\n            fragment = context.createDocumentFragment(),\n            nodes = [],\n            i = 0,\n            l = elems.length;\n\n        for (; i < l; i++) {\n            elem = elems[i];\n\n            if (elem || elem === 0) {\n                // Add nodes directly\n                if (jQuery.type(elem) === \"object\") {\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // push.apply(_, arraylike) throws on ancient WebKit\n                    jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);\n                    // Convert non-html into a text node\n                } else if (!rhtml.test(elem)) {\n                    nodes.push(context.createTextNode(elem));\n                    // Convert html into DOM nodes\n                } else {\n                    tmp = tmp ||\n                        fragment.appendChild(context.createElement(\"div\"));\n\n                    // Deserialize a standard representation\n                    tag = (rtagName.exec(elem) || [ \"\", \"\" ])[1].toLowerCase();\n                    wrap = wrapMap[tag] || wrapMap._default;\n                    tmp.innerHTML = wrap[1] +\n                        jQuery.htmlPrefilter(elem) +\n                        wrap[2];\n\n                    // Descend through wrappers to the right content\n                    j = wrap[0];\n                    while (j--) {\n                        tmp = tmp.lastChild;\n                    }\n\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // push.apply(_, arraylike) throws on ancient WebKit\n                    jQuery.merge(nodes, tmp.childNodes);\n\n                    // Remember the top-level container\n                    tmp = fragment.firstChild;\n\n                    // Ensure the created nodes are orphaned (#12392)\n                    tmp.textContent = \"\";\n                }\n            }\n        }\n\n        // Remove wrapper from fragment\n        fragment.textContent = \"\";\n\n        i = 0;\n        while (elem = nodes[i++]) {\n            // Skip elements already in the context collection (trac-4087)\n            if (selection && jQuery.inArray(elem, selection) > -1) {\n                if (ignored) {\n                    ignored.push(elem);\n                }\n                continue;\n            }\n\n            contains = jQuery.contains(elem.ownerDocument, elem);\n\n            // Append to fragment\n            tmp = getAll(fragment.appendChild(elem), \"script\");\n\n            // Preserve script evaluation history\n            if (contains) {\n                setGlobalEval(tmp);\n            }\n\n            // Capture executables\n            if (scripts) {\n                j = 0;\n                while (elem = tmp[j++]) {\n                    if (rscriptType.test(elem.type || \"\")) {\n                        scripts.push(elem);\n                    }\n                }\n            }\n        }\n\n        return fragment;\n    }\n\n    (function() {\n        var fragment = document.createDocumentFragment(),\n            div = fragment.appendChild(document.createElement(\"div\")),\n            input = document.createElement(\"input\");\n\n        // Support: Android 4.0 - 4.3 only\n        // Check state lost if the name is set (#11217)\n        // Support: Windows Web Apps (WWA)\n        // `name` and `type` must use .setAttribute for WWA (#14901)\n        input.setAttribute(\"type\", \"radio\");\n        input.setAttribute(\"checked\", \"checked\");\n        input.setAttribute(\"name\", \"t\");\n\n        div.appendChild(input);\n\n        // Support: Android <=4.1 only\n        // Older WebKit doesn't clone checked state correctly in fragments\n        support.checkClone = div\n            .cloneNode(true)\n            .cloneNode(true).lastChild.checked;\n\n        // Support: IE <=11 only\n        // Make sure textarea (and checkbox) defaultValue is properly cloned\n        div.innerHTML = \"<textarea>x</textarea>\";\n        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n    })();\n    var documentElement = document.documentElement;\n\n    var rkeyEvent = /^key/,\n        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n        rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n    function returnTrue() {\n        return true;\n    }\n\n    function returnFalse() {\n        return false;\n    }\n\n    // Support: IE <=9 only\n    // See #13393 for more info\n    function safeActiveElement() {\n        try {\n            return document.activeElement;\n        } catch (err) {\n        }\n    }\n\n    function on(elem, types, selector, data, fn, one) {\n        var origFn, type;\n\n        // Types can be a map of types/handlers\n        if (typeof types === \"object\") {\n            // ( types-Object, selector, data )\n            if (typeof selector !== \"string\") {\n                // ( types-Object, data )\n                data = data || selector;\n                selector = undefined;\n            }\n            for (type in types) {\n                on(elem, type, selector, data, types[type], one);\n            }\n            return elem;\n        }\n\n        if (data == null && fn == null) {\n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n        } else if (fn == null) {\n            if (typeof selector === \"string\") {\n                // ( types, selector, fn )\n                fn = data;\n                data = undefined;\n            } else {\n                // ( types, data, fn )\n                fn = data;\n                data = selector;\n                selector = undefined;\n            }\n        }\n        if (fn === false) {\n            fn = returnFalse;\n        } else if (!fn) {\n            return elem;\n        }\n\n        if (one === 1) {\n            origFn = fn;\n            fn = function(event) {\n                // Can use an empty set, since event contains the info\n                jQuery().off(event);\n                return origFn.apply(this, arguments);\n            };\n\n            // Use same guid so caller can remove using origFn\n            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n        }\n        return elem.each(function() {\n            jQuery.event.add(this, types, fn, data, selector);\n        });\n    }\n\n    /*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\n    jQuery.event = {\n        global: {},\n        add: function(elem, types, handler, data, selector) {\n            var handleObjIn,\n                eventHandle,\n                tmp,\n                events,\n                t,\n                handleObj,\n                special,\n                handlers,\n                type,\n                namespaces,\n                origType,\n                elemData = dataPriv.get(elem);\n\n            // Don't attach events to noData or text/comment nodes (but allow plain objects)\n            if (!elemData) {\n                return;\n            }\n\n            // Caller can pass in an object of custom data in lieu of the handler\n            if (handler.handler) {\n                handleObjIn = handler;\n                handler = handleObjIn.handler;\n                selector = handleObjIn.selector;\n            }\n\n            // Ensure that invalid selectors throw exceptions at attach time\n            // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n            if (selector) {\n                jQuery.find.matchesSelector(documentElement, selector);\n            }\n\n            // Make sure that the handler has a unique ID, used to find/remove it later\n            if (!handler.guid) {\n                handler.guid = jQuery.guid++;\n            }\n\n            // Init the element's event structure and main handler, if this is the first\n            if (!(events = elemData.events)) {\n                events = elemData.events = {};\n            }\n            if (!(eventHandle = elemData.handle)) {\n                eventHandle = elemData.handle = function(e) {\n                    // Discard the second event of a jQuery.event.trigger() and\n                    // when an event is called after a page has unloaded\n                    return typeof jQuery !== \"undefined\" &&\n                        jQuery.event.triggered !== e.type\n                        ? jQuery.event.dispatch.apply(elem, arguments)\n                        : undefined;\n                };\n            }\n\n            // Handle multiple events separated by a space\n            types = (types || \"\").match(rnothtmlwhite) || [ \"\" ];\n            t = types.length;\n            while (t--) {\n                tmp = rtypenamespace.exec(types[t]) || [];\n                type = origType = tmp[1];\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\n\n                // There *must* be a type, no attaching namespace-only handlers\n                if (!type) {\n                    continue;\n                }\n\n                // If event changes its type, use the special event handlers for the changed type\n                special = jQuery.event.special[type] || {};\n\n                // If selector defined, determine special event api type, otherwise given type\n                type = (selector ? special.delegateType : special.bindType) ||\n                    type;\n\n                // Update special based on newly reset type\n                special = jQuery.event.special[type] || {};\n\n                // handleObj is passed to all event handlers\n                handleObj = jQuery.extend(\n                    {\n                        type: type,\n                        origType: origType,\n                        data: data,\n                        handler: handler,\n                        guid: handler.guid,\n                        selector: selector,\n                        needsContext: selector &&\n                            jQuery.expr.match.needsContext.test(selector),\n                        namespace: namespaces.join(\".\")\n                    },\n                    handleObjIn\n                );\n\n                // Init the event handler queue if we're the first\n                if (!(handlers = events[type])) {\n                    handlers = events[type] = [];\n                    handlers.delegateCount = 0;\n\n                    // Only use addEventListener if the special events handler returns false\n                    if (\n                        !special.setup ||\n                            special.setup.call(\n                                elem,\n                                data,\n                                namespaces,\n                                eventHandle\n                            ) ===\n                                false\n                    ) {\n                        if (elem.addEventListener) {\n                            elem.addEventListener(type, eventHandle);\n                        }\n                    }\n                }\n\n                if (special.add) {\n                    special.add.call(elem, handleObj);\n\n                    if (!handleObj.handler.guid) {\n                        handleObj.handler.guid = handler.guid;\n                    }\n                }\n\n                // Add to the element's handler list, delegates in front\n                if (selector) {\n                    handlers.splice((handlers.delegateCount++), 0, handleObj);\n                } else {\n                    handlers.push(handleObj);\n                }\n\n                // Keep track of which events have ever been used, for event optimization\n                jQuery.event.global[type] = true;\n            }\n        },\n        // Detach an event or set of events from an element\n        remove: function(elem, types, handler, selector, mappedTypes) {\n            var j,\n                origCount,\n                tmp,\n                events,\n                t,\n                handleObj,\n                special,\n                handlers,\n                type,\n                namespaces,\n                origType,\n                elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n            if (!elemData || !(events = elemData.events)) {\n                return;\n            }\n\n            // Once for each type.namespace in types; type may be omitted\n            types = (types || \"\").match(rnothtmlwhite) || [ \"\" ];\n            t = types.length;\n            while (t--) {\n                tmp = rtypenamespace.exec(types[t]) || [];\n                type = origType = tmp[1];\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\n\n                // Unbind all events (on this namespace, if provided) for the element\n                if (!type) {\n                    for (type in events) {\n                        jQuery.event.remove(\n                            elem,\n                            type + types[t],\n                            handler,\n                            selector,\n                            true\n                        );\n                    }\n                    continue;\n                }\n\n                special = jQuery.event.special[type] || {};\n                type = (selector ? special.delegateType : special.bindType) ||\n                    type;\n                handlers = events[type] || [];\n                tmp = tmp[2] &&\n                    new RegExp(\n                        \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"\n                    );\n\n                // Remove matching events\n                origCount = j = handlers.length;\n                while (j--) {\n                    handleObj = handlers[j];\n\n                    if (\n                        (mappedTypes || origType === handleObj.origType) &&\n                            (!handler || handler.guid === handleObj.guid) &&\n                            (!tmp || tmp.test(handleObj.namespace)) &&\n                            (!selector ||\n                                selector === handleObj.selector ||\n                                selector === \"**\" && handleObj.selector)\n                    ) {\n                        handlers.splice(j, 1);\n\n                        if (handleObj.selector) {\n                            handlers.delegateCount--;\n                        }\n                        if (special.remove) {\n                            special.remove.call(elem, handleObj);\n                        }\n                    }\n                }\n\n                // Remove generic event handler if we removed something and no more handlers exist\n                // (avoids potential for endless recursion during removal of special event handlers)\n                if (origCount && !handlers.length) {\n                    if (\n                        !special.teardown ||\n                            special.teardown.call(\n                                elem,\n                                namespaces,\n                                elemData.handle\n                            ) ===\n                                false\n                    ) {\n                        jQuery.removeEvent(elem, type, elemData.handle);\n                    }\n\n                    delete events[type];\n                }\n            }\n\n            // Remove data and the expando if it's no longer used\n            if (jQuery.isEmptyObject(events)) {\n                dataPriv.remove(elem, \"handle events\");\n            }\n        },\n        dispatch: function(nativeEvent) {\n            // Make a writable jQuery.Event from the native event object\n            var event = jQuery.event.fix(nativeEvent);\n\n            var i,\n                j,\n                ret,\n                matched,\n                handleObj,\n                handlerQueue,\n                args = new Array(arguments.length),\n                handlers = (dataPriv.get(this, \"events\") || {})[event.type] ||\n                    [],\n                special = jQuery.event.special[event.type] || {};\n\n            // Use the fix-ed jQuery.Event rather than the (read-only) native event\n            args[0] = event;\n\n            for (i = 1; i < arguments.length; i++) {\n                args[i] = arguments[i];\n            }\n\n            event.delegateTarget = this;\n\n            // Call the preDispatch hook for the mapped type, and let it bail if desired\n            if (\n                special.preDispatch &&\n                    special.preDispatch.call(this, event) === false\n            ) {\n                return;\n            }\n\n            // Determine handlers\n            handlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n            // Run delegates first; they may want to stop propagation beneath us\n            i = 0;\n            while (\n                (matched = handlerQueue[i++]) && !event.isPropagationStopped()\n            ) {\n                event.currentTarget = matched.elem;\n\n                j = 0;\n                while (\n                    (handleObj = matched.handlers[j++]) &&\n                        !event.isImmediatePropagationStopped()\n                ) {\n                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)\n                    // a subset or equal to those in the bound event (both can have no namespace).\n                    if (\n                        !event.rnamespace ||\n                            event.rnamespace.test(handleObj.namespace)\n                    ) {\n                        event.handleObj = handleObj;\n                        event.data = handleObj.data;\n\n                        ret = ((jQuery.event.special[handleObj.origType] ||\n                            {}).handle ||\n                            handleObj.handler).apply(matched.elem, args);\n\n                        if (ret !== undefined) {\n                            if ((event.result = ret) === false) {\n                                event.preventDefault();\n                                event.stopPropagation();\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Call the postDispatch hook for the mapped type\n            if (special.postDispatch) {\n                special.postDispatch.call(this, event);\n            }\n\n            return event.result;\n        },\n        handlers: function(event, handlers) {\n            var i,\n                handleObj,\n                sel,\n                matchedHandlers,\n                matchedSelectors,\n                handlerQueue = [],\n                delegateCount = handlers.delegateCount,\n                cur = event.target;\n\n            // Find delegate handlers\n            if (delegateCount && // Support: IE <=9\n                    // Black-hole SVG <use> instance trees (trac-13180)\n                    cur.nodeType && // Support: Firefox <=42\n                    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n                    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n                    // Support: IE 11 only\n                    // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n                    !(event.type === \"click\" && event.button >= 1)) {\n                for (; cur !== this; cur = cur.parentNode || this) {\n                    // Don't check non-elements (#13208)\n                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n                    if (\n                        cur.nodeType === 1 &&\n                            !(event.type === \"click\" && cur.disabled === true)\n                    ) {\n                        matchedHandlers = [];\n                        matchedSelectors = {};\n                        for (i = 0; i < delegateCount; i++) {\n                            handleObj = handlers[i];\n\n                            // Don't conflict with Object.prototype properties (#13203)\n                            sel = handleObj.selector + \" \";\n\n                            if (matchedSelectors[sel] === undefined) {\n                                matchedSelectors[sel] = handleObj.needsContext\n                                    ? jQuery(sel, this).index(cur) > -1\n                                    : jQuery.find(sel, this, null, [\n                                        cur\n                                    ]).length;\n                            }\n                            if (matchedSelectors[sel]) {\n                                matchedHandlers.push(handleObj);\n                            }\n                        }\n                        if (matchedHandlers.length) {\n                            handlerQueue.push({\n                                elem: cur,\n                                handlers: matchedHandlers\n                            });\n                        }\n                    }\n                }\n            }\n\n            // Add the remaining (directly-bound) handlers\n            cur = this;\n            if (delegateCount < handlers.length) {\n                handlerQueue.push({\n                    elem: cur,\n                    handlers: handlers.slice(delegateCount)\n                });\n            }\n\n            return handlerQueue;\n        },\n        addProp: function(name, hook) {\n            Object.defineProperty(jQuery.Event.prototype, name, {\n                enumerable: true,\n                configurable: true,\n                get: jQuery.isFunction(hook) ? (function() {\n                        if (this.originalEvent) {\n                            return hook(this.originalEvent);\n                        }\n                    }) : (function() {\n                        if (this.originalEvent) {\n                            return this.originalEvent[name];\n                        }\n                    }),\n                set: function(value) {\n                    Object.defineProperty(this, name, {\n                        enumerable: true,\n                        configurable: true,\n                        writable: true,\n                        value: value\n                    });\n                }\n            });\n        },\n        fix: function(originalEvent) {\n            return originalEvent[jQuery.expando]\n                ? originalEvent\n                : new jQuery.Event(originalEvent);\n        },\n        special: {\n            load: {\n                // Prevent triggered image.load events from bubbling to window.load\n                noBubble: true\n            },\n            focus: {\n                // Fire native event if possible so blur/focus sequence is correct\n                trigger: function() {\n                    if (this !== safeActiveElement() && this.focus) {\n                        this.focus();\n                        return false;\n                    }\n                },\n                delegateType: \"focusin\"\n            },\n            blur: {\n                trigger: function() {\n                    if (this === safeActiveElement() && this.blur) {\n                        this.blur();\n                        return false;\n                    }\n                },\n                delegateType: \"focusout\"\n            },\n            click: {\n                // For checkbox, fire native event so checked state will be right\n                trigger: function() {\n                    if (\n                        this.type === \"checkbox\" &&\n                            this.click &&\n                            jQuery.nodeName(this, \"input\")\n                    ) {\n                        this.click();\n                        return false;\n                    }\n                },\n                // For cross-browser consistency, don't fire native .click() on links\n                _default: function(event) {\n                    return jQuery.nodeName(event.target, \"a\");\n                }\n            },\n            beforeunload: {\n                postDispatch: function(event) {\n                    // Support: Firefox 20+\n                    // Firefox doesn't alert if the returnValue field is not set.\n                    if (event.result !== undefined && event.originalEvent) {\n                        event.originalEvent.returnValue = event.result;\n                    }\n                }\n            }\n        }\n    };\n\n    jQuery.removeEvent = function(elem, type, handle) {\n        // This \"if\" is needed for plain objects\n        if (elem.removeEventListener) {\n            elem.removeEventListener(type, handle);\n        }\n    };\n\n    jQuery.Event = function(src, props) {\n        // Allow instantiation without the 'new' keyword\n        if (!(this instanceof jQuery.Event)) {\n            return new jQuery.Event(src, props);\n        }\n\n        // Event object\n        if (src && src.type) {\n            this.originalEvent = src;\n            this.type = src.type;\n\n            // Events bubbling up the document may have been marked as prevented\n            // by a handler lower down the tree; reflect the correct value.\n            this.isDefaultPrevented = src.defaultPrevented ||\n                src.defaultPrevented === undefined &&\n                    // Support: Android <=2.3 only\n                    src.returnValue === false\n                ? returnTrue\n                : returnFalse;\n\n            // Create target properties\n            // Support: Safari <=6 - 7 only\n            // Target should not be a text node (#504, #13143)\n            this.target = src.target && src.target.nodeType === 3\n                ? src.target.parentNode\n                : src.target;\n\n            this.currentTarget = src.currentTarget;\n            this.relatedTarget = src.relatedTarget;\n            // Event type\n        } else {\n            this.type = src;\n        }\n\n        // Put explicitly provided properties onto the event object\n        if (props) {\n            jQuery.extend(this, props);\n        }\n\n        // Create a timestamp if incoming event doesn't have one\n        this.timeStamp = src && src.timeStamp || jQuery.now();\n\n        // Mark it as fixed\n        this[jQuery.expando] = true;\n    };\n\n    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n    jQuery.Event.prototype = {\n        constructor: jQuery.Event,\n        isDefaultPrevented: returnFalse,\n        isPropagationStopped: returnFalse,\n        isImmediatePropagationStopped: returnFalse,\n        isSimulated: false,\n        preventDefault: function() {\n            var e = this.originalEvent;\n\n            this.isDefaultPrevented = returnTrue;\n\n            if (e && !this.isSimulated) {\n                e.preventDefault();\n            }\n        },\n        stopPropagation: function() {\n            var e = this.originalEvent;\n\n            this.isPropagationStopped = returnTrue;\n\n            if (e && !this.isSimulated) {\n                e.stopPropagation();\n            }\n        },\n        stopImmediatePropagation: function() {\n            var e = this.originalEvent;\n\n            this.isImmediatePropagationStopped = returnTrue;\n\n            if (e && !this.isSimulated) {\n                e.stopImmediatePropagation();\n            }\n\n            this.stopPropagation();\n        }\n    };\n\n    // Includes all common event props including KeyEvent and MouseEvent specific props\n    jQuery.each(\n        {\n            altKey: true,\n            bubbles: true,\n            cancelable: true,\n            changedTouches: true,\n            ctrlKey: true,\n            detail: true,\n            eventPhase: true,\n            metaKey: true,\n            pageX: true,\n            pageY: true,\n            shiftKey: true,\n            view: true,\n            char: true,\n            charCode: true,\n            key: true,\n            keyCode: true,\n            button: true,\n            buttons: true,\n            clientX: true,\n            clientY: true,\n            offsetX: true,\n            offsetY: true,\n            pointerId: true,\n            pointerType: true,\n            screenX: true,\n            screenY: true,\n            targetTouches: true,\n            toElement: true,\n            touches: true,\n            which: function(event) {\n                var button = event.button;\n\n                // Add which for key events\n                if (event.which == null && rkeyEvent.test(event.type)) {\n                    return event.charCode != null\n                        ? event.charCode\n                        : event.keyCode;\n                }\n\n                // Add which for click: 1 === left; 2 === middle; 3 === right\n                if (\n                    !event.which &&\n                        button !== undefined &&\n                        rmouseEvent.test(event.type)\n                ) {\n                    if (button & 1) {\n                        return 1;\n                    }\n\n                    if (button & 2) {\n                        return 3;\n                    }\n\n                    if (button & 4) {\n                        return 2;\n                    }\n\n                    return 0;\n                }\n\n                return event.which;\n            }\n        },\n        jQuery.event.addProp\n    );\n\n    // Create mouseenter/leave events using mouseover/out and event-time checks\n    // so that event delegation works in jQuery.\n    // Do the same for pointerenter/pointerleave and pointerover/pointerout\n    //\n    // Support: Safari 7 only\n    // Safari sends mouseenter too often; see:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n    // for the description of the bug (it existed in older Chrome versions as well).\n    jQuery.each(\n        {\n            mouseenter: \"mouseover\",\n            mouseleave: \"mouseout\",\n            pointerenter: \"pointerover\",\n            pointerleave: \"pointerout\"\n        },\n        function(orig, fix) {\n            jQuery.event.special[orig] = {\n                delegateType: fix,\n                bindType: fix,\n                handle: function(event) {\n                    var ret,\n                        target = this,\n                        related = event.relatedTarget,\n                        handleObj = event.handleObj;\n\n                    // For mouseenter/leave call the handler if related is outside the target.\n                    // NB: No relatedTarget if the mouse left/entered the browser window\n                    if (\n                        !related ||\n                            related !== target &&\n                                !jQuery.contains(target, related)\n                    ) {\n                        event.type = handleObj.origType;\n                        ret = handleObj.handler.apply(this, arguments);\n                        event.type = fix;\n                    }\n                    return ret;\n                }\n            };\n        }\n    );\n\n    jQuery.fn.extend({\n        on: function(types, selector, data, fn) {\n            return on(this, types, selector, data, fn);\n        },\n        one: function(types, selector, data, fn) {\n            return on(this, types, selector, data, fn, 1);\n        },\n        off: function(types, selector, fn) {\n            var handleObj, type;\n            if (types && types.preventDefault && types.handleObj) {\n                // ( event )  dispatched jQuery.Event\n                handleObj = types.handleObj;\n                jQuery(\n                    types.delegateTarget\n                ).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n                return this;\n            }\n            if (typeof types === \"object\") {\n                // ( types-object [, selector] )\n                for (type in types) {\n                    this.off(type, selector, types[type]);\n                }\n                return this;\n            }\n            if (selector === false || typeof selector === \"function\") {\n                // ( types [, fn] )\n                fn = selector;\n                selector = undefined;\n            }\n            if (fn === false) {\n                fn = returnFalse;\n            }\n            return this.each(function() {\n                jQuery.event.remove(this, types, fn, selector);\n            });\n        }\n    });\n\n    var /* eslint-disable max-len */\n    // See https://github.com/eslint/eslint/issues/3229\n    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n        /* eslint-enable */\n        // Support: IE <=10 - 11, Edge 12 - 13\n        // In IE/Edge using regex groups here causes severe slowdowns.\n        // See https://connect.microsoft.com/IE/feedback/details/1736512/\n        rnoInnerhtml = /<script|<style|<link/i,\n        // checked=\"checked\" or checked\n        rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n        rscriptTypeMasked = /^true\\/(.*)/,\n        rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n    function manipulationTarget(elem, content) {\n        if (\n            jQuery.nodeName(elem, \"table\") &&\n                jQuery.nodeName(\n                    content.nodeType !== 11 ? content : content.firstChild,\n                    \"tr\"\n                )\n        ) {\n            return elem.getElementsByTagName(\"tbody\")[0] || elem;\n        }\n\n        return elem;\n    }\n\n    // Replace/restore the type attribute of script elements for safe DOM manipulation\n    function disableScript(elem) {\n        elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n        return elem;\n    }\n    function restoreScript(elem) {\n        var match = rscriptTypeMasked.exec(elem.type);\n\n        if (match) {\n            elem.type = match[1];\n        } else {\n            elem.removeAttribute(\"type\");\n        }\n\n        return elem;\n    }\n\n    function cloneCopyEvent(src, dest) {\n        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n        if (dest.nodeType !== 1) {\n            return;\n        }\n\n        // 1. Copy private data: events, handlers, etc.\n        if (dataPriv.hasData(src)) {\n            pdataOld = dataPriv.access(src);\n            pdataCur = dataPriv.set(dest, pdataOld);\n            events = pdataOld.events;\n\n            if (events) {\n                delete pdataCur.handle;\n                pdataCur.events = {};\n\n                for (type in events) {\n                    for (i = 0, l = events[type].length; i < l; i++) {\n                        jQuery.event.add(dest, type, events[type][i]);\n                    }\n                }\n            }\n        }\n\n        // 2. Copy user data\n        if (dataUser.hasData(src)) {\n            udataOld = dataUser.access(src);\n            udataCur = jQuery.extend({}, udataOld);\n\n            dataUser.set(dest, udataCur);\n        }\n    }\n\n    // Fix IE bugs, see support tests\n    function fixInput(src, dest) {\n        var nodeName = dest.nodeName.toLowerCase();\n\n        // Fails to persist the checked state of a cloned checkbox or radio button.\n        if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n            dest.checked = src.checked;\n            // Fails to return the selected option to the default selected state when cloning options\n        } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n            dest.defaultValue = src.defaultValue;\n        }\n    }\n\n    function domManip(collection, args, callback, ignored) {\n        // Flatten any nested arrays\n        args = concat.apply([], args);\n\n        var fragment,\n            first,\n            scripts,\n            hasScripts,\n            node,\n            doc,\n            i = 0,\n            l = collection.length,\n            iNoClone = l - 1,\n            value = args[0],\n            isFunction = jQuery.isFunction(value);\n\n        // We can't cloneNode fragments that contain checked, in WebKit\n        if (\n            isFunction ||\n                l > 1 &&\n                    typeof value === \"string\" &&\n                    !support.checkClone &&\n                    rchecked.test(value)\n        ) {\n            return collection.each(function(index) {\n                var self = collection.eq(index);\n                if (isFunction) {\n                    args[0] = value.call(this, index, self.html());\n                }\n                domManip(self, args, callback, ignored);\n            });\n        }\n\n        if (l) {\n            fragment = buildFragment(\n                args,\n                collection[0].ownerDocument,\n                false,\n                collection,\n                ignored\n            );\n            first = fragment.firstChild;\n\n            if (fragment.childNodes.length === 1) {\n                fragment = first;\n            }\n\n            // Require either new content or an interest in ignored elements to invoke the callback\n            if (first || ignored) {\n                scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n                hasScripts = scripts.length;\n\n                // Use the original fragment for the last item\n                // instead of the first because it can end up\n                // being emptied incorrectly in certain situations (#8070).\n                for (; i < l; i++) {\n                    node = fragment;\n\n                    if (i !== iNoClone) {\n                        node = jQuery.clone(node, true, true);\n\n                        // Keep references to cloned scripts for later restoration\n                        if (hasScripts) {\n                            // Support: Android <=4.0 only, PhantomJS 1 only\n                            // push.apply(_, arraylike) throws on ancient WebKit\n                            jQuery.merge(scripts, getAll(node, \"script\"));\n                        }\n                    }\n\n                    callback.call(collection[i], node, i);\n                }\n\n                if (hasScripts) {\n                    doc = scripts[scripts.length - 1].ownerDocument;\n\n                    // Reenable scripts\n                    jQuery.map(scripts, restoreScript);\n\n                    // Evaluate executable scripts on first document insertion\n                    for (i = 0; i < hasScripts; i++) {\n                        node = scripts[i];\n                        if (\n                            rscriptType.test(node.type || \"\") &&\n                                !dataPriv.access(node, \"globalEval\") &&\n                                jQuery.contains(doc, node)\n                        ) {\n                            if (node.src) {\n                                // Optional AJAX dependency, but won't run scripts if not present\n                                if (jQuery._evalUrl) {\n                                    jQuery._evalUrl(node.src);\n                                }\n                            } else {\n                                DOMEval(\n                                    node.textContent.replace(rcleanScript, \"\"),\n                                    doc\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return collection;\n    }\n\n    function remove(elem, selector, keepData) {\n        var node,\n            nodes = selector ? jQuery.filter(selector, elem) : elem,\n            i = 0;\n\n        for (; (node = nodes[i]) != null; i++) {\n            if (!keepData && node.nodeType === 1) {\n                jQuery.cleanData(getAll(node));\n            }\n\n            if (node.parentNode) {\n                if (keepData && jQuery.contains(node.ownerDocument, node)) {\n                    setGlobalEval(getAll(node, \"script\"));\n                }\n                node.parentNode.removeChild(node);\n            }\n        }\n\n        return elem;\n    }\n\n    jQuery.extend({\n        htmlPrefilter: function(html) {\n            return html.replace(rxhtmlTag, \"<$1></$2>\");\n        },\n        clone: function(elem, dataAndEvents, deepDataAndEvents) {\n            var i,\n                l,\n                srcElements,\n                destElements,\n                clone = elem.cloneNode(true),\n                inPage = jQuery.contains(elem.ownerDocument, elem);\n\n            // Fix IE cloning issues\n            if (\n                !support.noCloneChecked &&\n                    (elem.nodeType === 1 || elem.nodeType === 11) &&\n                    !jQuery.isXMLDoc(elem)\n            ) {\n                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n                destElements = getAll(clone);\n                srcElements = getAll(elem);\n\n                for (i = 0, l = srcElements.length; i < l; i++) {\n                    fixInput(srcElements[i], destElements[i]);\n                }\n            }\n\n            // Copy the events from the original to the clone\n            if (dataAndEvents) {\n                if (deepDataAndEvents) {\n                    srcElements = srcElements || getAll(elem);\n                    destElements = destElements || getAll(clone);\n\n                    for (i = 0, l = srcElements.length; i < l; i++) {\n                        cloneCopyEvent(srcElements[i], destElements[i]);\n                    }\n                } else {\n                    cloneCopyEvent(elem, clone);\n                }\n            }\n\n            // Preserve script evaluation history\n            destElements = getAll(clone, \"script\");\n            if (destElements.length > 0) {\n                setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n            }\n\n            // Return the cloned set\n            return clone;\n        },\n        cleanData: function(elems) {\n            var data, elem, type, special = jQuery.event.special, i = 0;\n\n            for (; (elem = elems[i]) !== undefined; i++) {\n                if (acceptData(elem)) {\n                    if (data = elem[dataPriv.expando]) {\n                        if (data.events) {\n                            for (type in data.events) {\n                                if (special[type]) {\n                                    jQuery.event.remove(elem, type);\n                                    // This is a shortcut to avoid jQuery.event.remove's overhead\n                                } else {\n                                    jQuery.removeEvent(elem, type, data.handle);\n                                }\n                            }\n                        }\n\n                        // Support: Chrome <=35 - 45+\n                        // Assign undefined instead of using delete, see Data#remove\n                        elem[dataPriv.expando] = undefined;\n                    }\n                    if (elem[dataUser.expando]) {\n                        // Support: Chrome <=35 - 45+\n                        // Assign undefined instead of using delete, see Data#remove\n                        elem[dataUser.expando] = undefined;\n                    }\n                }\n            }\n        }\n    });\n\n    jQuery.fn.extend({\n        detach: function(selector) {\n            return remove(this, selector, true);\n        },\n        remove: function(selector) {\n            return remove(this, selector);\n        },\n        text: function(value) {\n            return access(\n                this,\n                function(value) {\n                    return value === undefined\n                        ? jQuery.text(this)\n                        : this.empty().each(function() {\n                            if (\n                                this.nodeType === 1 ||\n                                    this.nodeType === 11 ||\n                                    this.nodeType === 9\n                            ) {\n                                this.textContent = value;\n                            }\n                        });\n                },\n                null,\n                value,\n                arguments.length\n            );\n        },\n        append: function() {\n            return domManip(this, arguments, function(elem) {\n                if (\n                    this.nodeType === 1 ||\n                        this.nodeType === 11 ||\n                        this.nodeType === 9\n                ) {\n                    var target = manipulationTarget(this, elem);\n                    target.appendChild(elem);\n                }\n            });\n        },\n        prepend: function() {\n            return domManip(this, arguments, function(elem) {\n                if (\n                    this.nodeType === 1 ||\n                        this.nodeType === 11 ||\n                        this.nodeType === 9\n                ) {\n                    var target = manipulationTarget(this, elem);\n                    target.insertBefore(elem, target.firstChild);\n                }\n            });\n        },\n        before: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.parentNode) {\n                    this.parentNode.insertBefore(elem, this);\n                }\n            });\n        },\n        after: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.parentNode) {\n                    this.parentNode.insertBefore(elem, this.nextSibling);\n                }\n            });\n        },\n        empty: function() {\n            var elem, i = 0;\n\n            for (; (elem = this[i]) != null; i++) {\n                if (elem.nodeType === 1) {\n                    // Prevent memory leaks\n                    jQuery.cleanData(getAll(elem, false));\n\n                    // Remove any remaining nodes\n                    elem.textContent = \"\";\n                }\n            }\n\n            return this;\n        },\n        clone: function(dataAndEvents, deepDataAndEvents) {\n            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n            deepDataAndEvents = deepDataAndEvents == null\n                ? dataAndEvents\n                : deepDataAndEvents;\n\n            return this.map(function() {\n                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n            });\n        },\n        html: function(value) {\n            return access(\n                this,\n                function(value) {\n                    var elem = this[0] || {}, i = 0, l = this.length;\n\n                    if (value === undefined && elem.nodeType === 1) {\n                        return elem.innerHTML;\n                    }\n\n                    // See if we can take a shortcut and just use innerHTML\n                    if (\n                        typeof value === \"string\" &&\n                            !rnoInnerhtml.test(value) &&\n                            !wrapMap[(rtagName.exec(value) ||\n                                [ \"\", \"\" ])[1].toLowerCase()]\n                    ) {\n                        value = jQuery.htmlPrefilter(value);\n\n                        try {\n                            for (; i < l; i++) {\n                                elem = this[i] || {};\n\n                                // Remove element nodes and prevent memory leaks\n                                if (elem.nodeType === 1) {\n                                    jQuery.cleanData(getAll(elem, false));\n                                    elem.innerHTML = value;\n                                }\n                            }\n\n                            elem = 0;\n                            // If using innerHTML throws an exception, use the fallback method\n                        } catch (e) {\n                        }\n                    }\n\n                    if (elem) {\n                        this.empty().append(value);\n                    }\n                },\n                null,\n                value,\n                arguments.length\n            );\n        },\n        replaceWith: function() {\n            var ignored = [];\n\n            // Make the changes, replacing each non-ignored context element with the new content\n            return domManip(\n                this,\n                arguments,\n                function(elem) {\n                    var parent = this.parentNode;\n\n                    if (jQuery.inArray(this, ignored) < 0) {\n                        jQuery.cleanData(getAll(this));\n                        if (parent) {\n                            parent.replaceChild(elem, this);\n                        }\n                    }\n                    // Force callback invocation\n                },\n                ignored\n            );\n        }\n    });\n\n    jQuery.each(\n        {\n            appendTo: \"append\",\n            prependTo: \"prepend\",\n            insertBefore: \"before\",\n            insertAfter: \"after\",\n            replaceAll: \"replaceWith\"\n        },\n        function(name, original) {\n            jQuery.fn[name] = function(selector) {\n                var elems,\n                    ret = [],\n                    insert = jQuery(selector),\n                    last = insert.length - 1,\n                    i = 0;\n\n                for (; i <= last; i++) {\n                    elems = i === last ? this : this.clone(true);\n                    jQuery(insert[i])[original](elems);\n\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // .get() because push.apply(_, arraylike) throws on ancient WebKit\n                    push.apply(ret, elems.get());\n                }\n\n                return this.pushStack(ret);\n            };\n        }\n    );\n    var rmargin = /^margin/;\n\n    var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n    var getStyles = function(elem) {\n        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n        // IE throws on elements created in popups\n        // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n        var view = elem.ownerDocument.defaultView;\n\n        if (!view || !view.opener) {\n            view = window;\n        }\n\n        return view.getComputedStyle(elem);\n    };\n\n    (function() {\n        // Executing both pixelPosition & boxSizingReliable tests require only one layout\n        // so they're executed at the same time to save the second computation.\n        function computeStyleTests() {\n            // This is a singleton, we need to execute it only once\n            if (!div) {\n                return;\n            }\n\n            div.style.cssText = \"box-sizing:border-box;\" +\n                \"position:relative;display:block;\" +\n                \"margin:auto;border:1px;padding:1px;\" +\n                \"top:1%;width:50%\";\n            div.innerHTML = \"\";\n            documentElement.appendChild(container);\n\n            var divStyle = window.getComputedStyle(div);\n            pixelPositionVal = divStyle.top !== \"1%\";\n\n            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n            reliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n            boxSizingReliableVal = divStyle.width === \"4px\";\n\n            // Support: Android 4.0 - 4.3 only\n            // Some styles come back with percentage values, even though they shouldn't\n            div.style.marginRight = \"50%\";\n            pixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n            documentElement.removeChild(container);\n\n            // Nullify the div so it wouldn't be stored in the memory and\n            // it will also be a sign that checks already performed\n            div = null;\n        }\n\n        var pixelPositionVal,\n            boxSizingReliableVal,\n            pixelMarginRightVal,\n            reliableMarginLeftVal,\n            container = document.createElement(\"div\"),\n            div = document.createElement(\"div\");\n\n        // Finish early in limited (non-browser) environments\n        if (!div.style) {\n            return;\n        }\n\n        // Support: IE <=9 - 11 only\n        // Style of cloned element affects source element cloned (#8908)\n        div.style.backgroundClip = \"content-box\";\n        div.cloneNode(true).style.backgroundClip = \"\";\n        support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n        container.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n            \"padding:0;margin-top:1px;position:absolute\";\n        container.appendChild(div);\n\n        jQuery.extend(support, {\n            pixelPosition: function() {\n                computeStyleTests();\n                return pixelPositionVal;\n            },\n            boxSizingReliable: function() {\n                computeStyleTests();\n                return boxSizingReliableVal;\n            },\n            pixelMarginRight: function() {\n                computeStyleTests();\n                return pixelMarginRightVal;\n            },\n            reliableMarginLeft: function() {\n                computeStyleTests();\n                return reliableMarginLeftVal;\n            }\n        });\n    })();\n\n    function curCSS(elem, name, computed) {\n        var width, minWidth, maxWidth, ret, style = elem.style;\n\n        computed = computed || getStyles(elem);\n\n        // Support: IE <=9 only\n        // getPropertyValue is only needed for .css('filter') (#12537)\n        if (computed) {\n            ret = computed.getPropertyValue(name) || computed[name];\n\n            if (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n                ret = jQuery.style(elem, name);\n            }\n\n            // A tribute to the \"awesome hack by Dean Edwards\"\n            // Android Browser returns percentage for some values,\n            // but width seems to be reliably pixels.\n            // This is against the CSSOM draft spec:\n            // https://drafts.csswg.org/cssom/#resolved-values\n            if (\n                !support.pixelMarginRight() &&\n                    rnumnonpx.test(ret) &&\n                    rmargin.test(name)\n            ) {\n                // Remember the original values\n                width = style.width;\n                minWidth = style.minWidth;\n                maxWidth = style.maxWidth;\n\n                // Put in the new values to get a computed value out\n                style.minWidth = style.maxWidth = style.width = ret;\n                ret = computed.width;\n\n                // Revert the changed values\n                style.width = width;\n                style.minWidth = minWidth;\n                style.maxWidth = maxWidth;\n            }\n        }\n\n        return ret !== undefined ? // Support: IE <=9 - 11 only\n            // IE returns zIndex value as an integer.\n            ret + \"\" : ret;\n    }\n\n    function addGetHookIf(conditionFn, hookFn) {\n        // Define the hook, we'll check on the first run if it's really needed.\n        return {\n            get: function() {\n                if (conditionFn()) {\n                    // Hook not needed (or it's not possible to use it due\n                    // to missing dependency), remove it.\n                    delete this.get;\n                    return;\n                }\n\n                // Hook needed; redefine it so that the support test is not executed again.\n                return (this.get = hookFn).apply(this, arguments);\n            }\n        };\n    }\n\n    var // Swappable if display is none or starts with table\n    // except \"table\", \"table-cell\", or \"table-caption\"\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n        cssShow = {\n            position: \"absolute\",\n            visibility: \"hidden\",\n            display: \"block\"\n        },\n        cssNormalTransform = { letterSpacing: \"0\", fontWeight: \"400\" },\n        cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n        emptyStyle = document.createElement(\"div\").style;\n\n    // Return a css property mapped to a potentially vendor prefixed property\n    function vendorPropName(name) {\n        // Shortcut for names that are not vendor prefixed\n        if (name in emptyStyle) {\n            return name;\n        }\n\n        // Check for vendor prefixed names\n        var capName = name[0].toUpperCase() + name.slice(1),\n            i = cssPrefixes.length;\n\n        while (i--) {\n            name = cssPrefixes[i] + capName;\n            if (name in emptyStyle) {\n                return name;\n            }\n        }\n    }\n\n    function setPositiveNumber(elem, value, subtract) {\n        // Any relative (+/-) values have already been\n        // normalized at this point\n        var matches = rcssNum.exec(value);\n        return matches\n            ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\")\n            : value;\n    }\n\n    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n        var i, val = 0;\n\n        // If we already have the right measurement, avoid augmentation\n        if (extra === (isBorderBox ? \"border\" : \"content\")) {\n            i = 4;\n            // Otherwise initialize for horizontal or vertical properties\n        } else {\n            i = name === \"width\" ? 1 : 0;\n        }\n\n        for (; i < 4; i += 2) {\n            // Both box models exclude margin, so add it if we want it\n            if (extra === \"margin\") {\n                val += jQuery.css(elem, extra + cssExpand[i], true, styles);\n            }\n\n            if (isBorderBox) {\n                // border-box includes padding, so remove it if we want content\n                if (extra === \"content\") {\n                    val -= jQuery.css(\n                        elem,\n                        \"padding\" + cssExpand[i],\n                        true,\n                        styles\n                    );\n                }\n\n                // At this point, extra isn't border nor margin, so remove border\n                if (extra !== \"margin\") {\n                    val -= jQuery.css(\n                        elem,\n                        \"border\" + cssExpand[i] + \"Width\",\n                        true,\n                        styles\n                    );\n                }\n            } else {\n                // At this point, extra isn't content, so add padding\n                val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\n                // At this point, extra isn't content nor padding, so add border\n                if (extra !== \"padding\") {\n                    val += jQuery.css(\n                        elem,\n                        \"border\" + cssExpand[i] + \"Width\",\n                        true,\n                        styles\n                    );\n                }\n            }\n        }\n\n        return val;\n    }\n\n    function getWidthOrHeight(elem, name, extra) {\n        // Start with offset property, which is equivalent to the border-box value\n        var val,\n            valueIsBorderBox = true,\n            styles = getStyles(elem),\n            isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) ===\n                \"border-box\";\n\n        // Support: IE <=11 only\n        // Running getBoundingClientRect on a disconnected node\n        // in IE throws an error.\n        if (elem.getClientRects().length) {\n            val = elem.getBoundingClientRect()[name];\n        }\n\n        // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n        if (val <= 0 || val == null) {\n            // Fall back to computed then uncomputed css if necessary\n            val = curCSS(elem, name, styles);\n            if (val < 0 || val == null) {\n                val = elem.style[name];\n            }\n\n            // Computed unit is not pixels. Stop here and return.\n            if (rnumnonpx.test(val)) {\n                return val;\n            }\n\n            // Check for style in case a browser which returns unreliable values\n            // for getComputedStyle silently falls back to the reliable elem.style\n            valueIsBorderBox = isBorderBox &&\n                (support.boxSizingReliable() || val === elem.style[name]);\n\n            // Normalize \"\", auto, and prepare for extra\n            val = parseFloat(val) || 0;\n        }\n\n        // Use the active box-sizing model to add/subtract irrelevant styles\n        return val +\n            augmentWidthOrHeight(\n                elem,\n                name,\n                extra || (isBorderBox ? \"border\" : \"content\"),\n                valueIsBorderBox,\n                styles\n            ) +\n            \"px\";\n    }\n\n    jQuery.extend({\n        // Add in style property hooks for overriding the default\n        // behavior of getting and setting a style property\n        cssHooks: {\n            opacity: {\n                get: function(elem, computed) {\n                    if (computed) {\n                        // We should always get a number back from opacity\n                        var ret = curCSS(elem, \"opacity\");\n                        return ret === \"\" ? \"1\" : ret;\n                    }\n                }\n            }\n        },\n        // Don't automatically add \"px\" to these possibly-unitless properties\n        cssNumber: {\n            animationIterationCount: true,\n            columnCount: true,\n            fillOpacity: true,\n            flexGrow: true,\n            flexShrink: true,\n            fontWeight: true,\n            lineHeight: true,\n            opacity: true,\n            order: true,\n            orphans: true,\n            widows: true,\n            zIndex: true,\n            zoom: true\n        },\n        // Add in properties whose names you wish to fix before\n        // setting or getting the value\n        cssProps: { float: \"cssFloat\" },\n        // Get and set the style property on a DOM Node\n        style: function(elem, name, value, extra) {\n            // Don't set styles on text and comment nodes\n            if (\n                !elem ||\n                    elem.nodeType === 3 ||\n                    elem.nodeType === 8 ||\n                    !elem.style\n            ) {\n                return;\n            }\n\n            // Make sure that we're working with the right name\n            var ret,\n                type,\n                hooks,\n                origName = jQuery.camelCase(name),\n                style = elem.style;\n\n            name = jQuery.cssProps[origName] ||\n                (jQuery.cssProps[origName] = vendorPropName(origName) ||\n                    origName);\n\n            // Gets hook for the prefixed version, then unprefixed version\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n            // Check if we're setting a value\n            if (value !== undefined) {\n                type = typeof value;\n\n                // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n                if (\n                    type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]\n                ) {\n                    value = adjustCSS(elem, name, ret);\n\n                    // Fixes bug #9237\n                    type = \"number\";\n                }\n\n                // Make sure that null and NaN values aren't set (#7116)\n                if (value == null || value !== value) {\n                    return;\n                }\n\n                // If a number was passed in, add the unit (except for certain CSS properties)\n                if (type === \"number\") {\n                    value += ret && ret[3] ||\n                        (jQuery.cssNumber[origName] ? \"\" : \"px\");\n                }\n\n                // background-* props affect original clone's values\n                if (\n                    !support.clearCloneStyle &&\n                        value === \"\" &&\n                        name.indexOf(\"background\") === 0\n                ) {\n                    style[name] = \"inherit\";\n                }\n\n                // If a hook was provided, use that value, otherwise just set the specified value\n                if (\n                    !hooks ||\n                        !(\"set\" in hooks) ||\n                        (value = hooks.set(elem, value, extra)) !== undefined\n                ) {\n                    style[name] = value;\n                }\n            } else {\n                // If a hook was provided get the non-computed value from there\n                if (\n                    hooks &&\n                        \"get\" in hooks &&\n                        (ret = hooks.get(elem, false, extra)) !== undefined\n                ) {\n                    return ret;\n                }\n\n                // Otherwise just get the value from the style object\n                return style[name];\n            }\n        },\n        css: function(elem, name, extra, styles) {\n            var val, num, hooks, origName = jQuery.camelCase(name);\n\n            // Make sure that we're working with the right name\n            name = jQuery.cssProps[origName] ||\n                (jQuery.cssProps[origName] = vendorPropName(origName) ||\n                    origName);\n\n            // Try prefixed name followed by the unprefixed name\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n            // If a hook was provided get the computed value from there\n            if (hooks && \"get\" in hooks) {\n                val = hooks.get(elem, true, extra);\n            }\n\n            // Otherwise, if a way to get the computed value exists, use that\n            if (val === undefined) {\n                val = curCSS(elem, name, styles);\n            }\n\n            // Convert \"normal\" to computed value\n            if (val === \"normal\" && name in cssNormalTransform) {\n                val = cssNormalTransform[name];\n            }\n\n            // Make numeric if forced or a qualifier was provided and val looks numeric\n            if (extra === \"\" || extra) {\n                num = parseFloat(val);\n                return extra === true || isFinite(num) ? num || 0 : val;\n            }\n            return val;\n        }\n    });\n\n    jQuery.each([ \"height\", \"width\" ], function(i, name) {\n        jQuery.cssHooks[name] = {\n            get: function(elem, computed, extra) {\n                if (computed) {\n                    // Certain elements can have dimension info if we invisibly show them\n                    // but it must have a current display style that would benefit\n                    return;\n                    // Support: Safari 8+\n                    // Table columns in Safari have non-zero offsetWidth & zero\n                    // getBoundingClientRect().width unless display is changed.\n                    // Support: IE <=11 only\n                    // Running getBoundingClientRect on a disconnected node\n                    // in IE throws an error.\n                    rdisplayswap.test(jQuery.css(elem, \"display\")) &&\n                        (!elem.getClientRects().length ||\n                            !elem.getBoundingClientRect().width)\n                        ? swap(elem, cssShow, function() {\n                            return getWidthOrHeight(elem, name, extra);\n                        })\n                        : getWidthOrHeight(elem, name, extra);\n                }\n            },\n            set: function(elem, value, extra) {\n                var matches,\n                    styles = extra && getStyles(elem),\n                    subtract = extra &&\n                        augmentWidthOrHeight(\n                            elem,\n                            name,\n                            extra,\n                            jQuery.css(elem, \"boxSizing\", false, styles) ===\n                                \"border-box\",\n                            styles\n                        );\n\n                // Convert to pixels if value adjustment is needed\n                if (\n                    subtract &&\n                        (matches = rcssNum.exec(value)) &&\n                        (matches[3] || \"px\") !== \"px\"\n                ) {\n                    elem.style[name] = value;\n                    value = jQuery.css(elem, name);\n                }\n\n                return setPositiveNumber(elem, value, subtract);\n            }\n        };\n    });\n\n    jQuery.cssHooks.marginLeft = addGetHookIf(\n        support.reliableMarginLeft,\n        function(elem, computed) {\n            if (computed) {\n                return (parseFloat(curCSS(elem, \"marginLeft\")) ||\n                    elem.getBoundingClientRect().left -\n                        swap(elem, { marginLeft: 0 }, function() {\n                            return elem.getBoundingClientRect().left;\n                        })) +\n                    \"px\";\n            }\n        }\n    );\n\n    // These hooks are used by animate to expand properties\n    jQuery.each({ margin: \"\", padding: \"\", border: \"Width\" }, function(\n        prefix,\n        suffix\n    ) {\n        jQuery.cssHooks[prefix + suffix] = {\n            expand: function(value) {\n                var i = 0,\n                    expanded = {},\n                    // Assumes a single number if not a string\n                    parts = typeof value === \"string\"\n                        ? value.split(\" \")\n                        : [ value ];\n\n                for (; i < 4; i++) {\n                    expanded[prefix + cssExpand[i] + suffix] = parts[i] ||\n                        parts[i - 2] ||\n                        parts[0];\n                }\n\n                return expanded;\n            }\n        };\n\n        if (!rmargin.test(prefix)) {\n            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n        }\n    });\n\n    jQuery.fn.extend({\n        css: function(name, value) {\n            return access(\n                this,\n                function(elem, name, value) {\n                    var styles, len, map = {}, i = 0;\n\n                    if (jQuery.isArray(name)) {\n                        styles = getStyles(elem);\n                        len = name.length;\n\n                        for (; i < len; i++) {\n                            map[name[i]] = jQuery.css(\n                                elem,\n                                name[i],\n                                false,\n                                styles\n                            );\n                        }\n\n                        return map;\n                    }\n\n                    return value !== undefined\n                        ? jQuery.style(elem, name, value)\n                        : jQuery.css(elem, name);\n                },\n                name,\n                value,\n                arguments.length > 1\n            );\n        }\n    });\n\n    function Tween(elem, options, prop, end, easing) {\n        return new Tween.prototype.init(elem, options, prop, end, easing);\n    }\n    jQuery.Tween = Tween;\n\n    Tween.prototype = {\n        constructor: Tween,\n        init: function(elem, options, prop, end, easing, unit) {\n            this.elem = elem;\n            this.prop = prop;\n            this.easing = easing || jQuery.easing._default;\n            this.options = options;\n            this.start = this.now = this.cur();\n            this.end = end;\n            this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n        },\n        cur: function() {\n            var hooks = Tween.propHooks[this.prop];\n\n            return hooks && hooks.get\n                ? hooks.get(this)\n                : Tween.propHooks._default.get(this);\n        },\n        run: function(percent) {\n            var eased, hooks = Tween.propHooks[this.prop];\n\n            if (this.options.duration) {\n                this.pos = eased = jQuery.easing[this.easing](\n                    percent,\n                    this.options.duration * percent,\n                    0,\n                    1,\n                    this.options.duration\n                );\n            } else {\n                this.pos = eased = percent;\n            }\n            this.now = (this.end - this.start) * eased + this.start;\n\n            if (this.options.step) {\n                this.options.step.call(this.elem, this.now, this);\n            }\n\n            if (hooks && hooks.set) {\n                hooks.set(this);\n            } else {\n                Tween.propHooks._default.set(this);\n            }\n            return this;\n        }\n    };\n\n    Tween.prototype.init.prototype = Tween.prototype;\n\n    Tween.propHooks = {\n        _default: {\n            get: function(tween) {\n                var result;\n\n                // Use a property on the element directly when it is not a DOM element,\n                // or when there is no matching style property that exists.\n                if (\n                    tween.elem.nodeType !== 1 ||\n                        tween.elem[tween.prop] != null &&\n                            tween.elem.style[tween.prop] == null\n                ) {\n                    return tween.elem[tween.prop];\n                }\n\n                // Passing an empty string as a 3rd parameter to .css will automatically\n                // attempt a parseFloat and fallback to a string if the parse fails.\n                // Simple values such as \"10px\" are parsed to Float;\n                // complex values such as \"rotate(1rad)\" are returned as-is.\n                result = jQuery.css(tween.elem, tween.prop, \"\");\n\n                // Empty strings, null, undefined and \"auto\" are converted to 0.\n                return !result || result === \"auto\" ? 0 : result;\n            },\n            set: function(tween) {\n                // Use step hook for back compat.\n                // Use cssHook if its there.\n                // Use .style if available and use plain properties where available.\n                if (jQuery.fx.step[tween.prop]) {\n                    jQuery.fx.step[tween.prop](tween);\n                } else if (\n                    tween.elem.nodeType === 1 &&\n                        (tween.elem.style[jQuery.cssProps[tween.prop]] !=\n                            null ||\n                            jQuery.cssHooks[tween.prop])\n                ) {\n                    jQuery.style(\n                        tween.elem,\n                        tween.prop,\n                        tween.now + tween.unit\n                    );\n                } else {\n                    tween.elem[tween.prop] = tween.now;\n                }\n            }\n        }\n    };\n\n    // Support: IE <=9 only\n    // Panic based approach to setting things on disconnected nodes\n    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n        set: function(tween) {\n            if (tween.elem.nodeType && tween.elem.parentNode) {\n                tween.elem[tween.prop] = tween.now;\n            }\n        }\n    };\n\n    jQuery.easing = {\n        linear: function(p) {\n            return p;\n        },\n        swing: function(p) {\n            return 0.5 - Math.cos(p * Math.PI) / 2;\n        },\n        _default: \"swing\"\n    };\n\n    jQuery.fx = Tween.prototype.init;\n\n    // Back compat <1.8 extension point\n    jQuery.fx.step = {};\n\n    var fxNow,\n        timerId,\n        rfxtypes = /^(?:toggle|show|hide)$/,\n        rrun = /queueHooks$/;\n\n    function raf() {\n        if (timerId) {\n            window.requestAnimationFrame(raf);\n            jQuery.fx.tick();\n        }\n    }\n\n    // Animations created synchronously will run synchronously\n    function createFxNow() {\n        window.setTimeout(function() {\n            fxNow = undefined;\n        });\n        return fxNow = jQuery.now();\n    }\n\n    // Generate parameters to create a standard animation\n    function genFx(type, includeWidth) {\n        var which, i = 0, attrs = { height: type };\n\n        // If we include width, step value is 1 to do all cssExpand values,\n        // otherwise step value is 2 to skip over Left and Right\n        includeWidth = includeWidth ? 1 : 0;\n        for (; i < 4; i += 2 - includeWidth) {\n            which = cssExpand[i];\n            attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n        }\n\n        if (includeWidth) {\n            attrs.opacity = attrs.width = type;\n        }\n\n        return attrs;\n    }\n\n    function createTween(value, prop, animation) {\n        var tween,\n            collection = (Animation.tweeners[prop] || []).concat(\n                Animation.tweeners[\"*\"]\n            ),\n            index = 0,\n            length = collection.length;\n        for (; index < length; index++) {\n            if (tween = collection[index].call(animation, prop, value)) {\n                // We're done with this property\n                return tween;\n            }\n        }\n    }\n\n    function defaultPrefilter(elem, props, opts) {\n        var prop,\n            value,\n            toggle,\n            hooks,\n            oldfire,\n            propTween,\n            restoreDisplay,\n            display,\n            isBox = \"width\" in props || \"height\" in props,\n            anim = this,\n            orig = {},\n            style = elem.style,\n            hidden = elem.nodeType && isHiddenWithinTree(elem),\n            dataShow = dataPriv.get(elem, \"fxshow\");\n\n        // Queue-skipping animations hijack the fx hooks\n        if (!opts.queue) {\n            hooks = jQuery._queueHooks(elem, \"fx\");\n            if (hooks.unqueued == null) {\n                hooks.unqueued = 0;\n                oldfire = hooks.empty.fire;\n                hooks.empty.fire = function() {\n                    if (!hooks.unqueued) {\n                        oldfire();\n                    }\n                };\n            }\n            hooks.unqueued++;\n\n            anim.always(function() {\n                // Ensure the complete handler is called before this completes\n                anim.always(function() {\n                    hooks.unqueued--;\n                    if (!jQuery.queue(elem, \"fx\").length) {\n                        hooks.empty.fire();\n                    }\n                });\n            });\n        }\n\n        // Detect show/hide animations\n        for (prop in props) {\n            value = props[prop];\n            if (rfxtypes.test(value)) {\n                delete props[prop];\n                toggle = toggle || value === \"toggle\";\n                if (value === (hidden ? \"hide\" : \"show\")) {\n                    // Pretend to be hidden if this is a \"show\" and\n                    // there is still data from a stopped show/hide\n                    if (\n                        value === \"show\" &&\n                            dataShow &&\n                            dataShow[prop] !== undefined\n                    ) {\n                        hidden = true;\n                        // Ignore all other no-op show/hide data\n                    } else {\n                        continue;\n                    }\n                }\n                orig[prop] = dataShow && dataShow[prop] ||\n                    jQuery.style(elem, prop);\n            }\n        }\n\n        // Bail out if this is a no-op like .hide().hide()\n        propTween = !jQuery.isEmptyObject(props);\n        if (!propTween && jQuery.isEmptyObject(orig)) {\n            return;\n        }\n\n        // Restrict \"overflow\" and \"display\" styles during box animations\n        if (isBox && elem.nodeType === 1) {\n            // Support: IE <=9 - 11, Edge 12 - 13\n            // Record all 3 overflow attributes because IE does not infer the shorthand\n            // from identically-valued overflowX and overflowY\n            opts.overflow = [\n                style.overflow,\n                style.overflowX,\n                style.overflowY\n            ];\n\n            // Identify a display type, preferring old show/hide data over the CSS cascade\n            restoreDisplay = dataShow && dataShow.display;\n            if (restoreDisplay == null) {\n                restoreDisplay = dataPriv.get(elem, \"display\");\n            }\n            display = jQuery.css(elem, \"display\");\n            if (display === \"none\") {\n                if (restoreDisplay) {\n                    display = restoreDisplay;\n                } else {\n                    // Get nonempty value(s) by temporarily forcing visibility\n                    showHide([ elem ], true);\n                    restoreDisplay = elem.style.display || restoreDisplay;\n                    display = jQuery.css(elem, \"display\");\n                    showHide([ elem ]);\n                }\n            }\n\n            // Animate inline elements as inline-block\n            if (\n                display === \"inline\" ||\n                    display === \"inline-block\" && restoreDisplay != null\n            ) {\n                if (jQuery.css(elem, \"float\") === \"none\") {\n                    // Restore the original display value at the end of pure show/hide animations\n                    if (!propTween) {\n                        anim.done(function() {\n                            style.display = restoreDisplay;\n                        });\n                        if (restoreDisplay == null) {\n                            display = style.display;\n                            restoreDisplay = display === \"none\" ? \"\" : display;\n                        }\n                    }\n                    style.display = \"inline-block\";\n                }\n            }\n        }\n\n        if (opts.overflow) {\n            style.overflow = \"hidden\";\n            anim.always(function() {\n                style.overflow = opts.overflow[0];\n                style.overflowX = opts.overflow[1];\n                style.overflowY = opts.overflow[2];\n            });\n        }\n\n        // Implement show/hide animations\n        propTween = false;\n        for (prop in orig) {\n            // General show/hide setup for this element animation\n            if (!propTween) {\n                if (dataShow) {\n                    if (\"hidden\" in dataShow) {\n                        hidden = dataShow.hidden;\n                    }\n                } else {\n                    dataShow = dataPriv.access(elem, \"fxshow\", {\n                        display: restoreDisplay\n                    });\n                }\n\n                // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n                if (toggle) {\n                    dataShow.hidden = !hidden;\n                }\n\n                // Show elements before animating them\n                if (hidden) {\n                    showHide([ elem ], true);\n                }\n\n                /* eslint-disable no-loop-func */\n                anim.done(function() {\n                    /* eslint-enable no-loop-func */\n                    // The final step of a \"hide\" animation is actually hiding the element\n                    if (!hidden) {\n                        showHide([ elem ]);\n                    }\n                    dataPriv.remove(elem, \"fxshow\");\n                    for (prop in orig) {\n                        jQuery.style(elem, prop, orig[prop]);\n                    }\n                });\n            }\n\n            // Per-property setup\n            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n            if (!(prop in dataShow)) {\n                dataShow[prop] = propTween.start;\n                if (hidden) {\n                    propTween.end = propTween.start;\n                    propTween.start = 0;\n                }\n            }\n        }\n    }\n\n    function propFilter(props, specialEasing) {\n        var index, name, easing, value, hooks;\n\n        // camelCase, specialEasing and expand cssHook pass\n        for (index in props) {\n            name = jQuery.camelCase(index);\n            easing = specialEasing[name];\n            value = props[index];\n            if (jQuery.isArray(value)) {\n                easing = value[1];\n                value = props[index] = value[0];\n            }\n\n            if (index !== name) {\n                props[name] = value;\n                delete props[index];\n            }\n\n            hooks = jQuery.cssHooks[name];\n            if (hooks && \"expand\" in hooks) {\n                value = hooks.expand(value);\n                delete props[name];\n\n                // Not quite $.extend, this won't overwrite existing keys.\n                // Reusing 'index' because we have the correct \"name\"\n                for (index in value) {\n                    if (!(index in props)) {\n                        props[index] = value[index];\n                        specialEasing[index] = easing;\n                    }\n                }\n            } else {\n                specialEasing[name] = easing;\n            }\n        }\n    }\n\n    function Animation(elem, properties, options) {\n        var result,\n            stopped,\n            index = 0,\n            length = Animation.prefilters.length,\n            deferred = jQuery.Deferred().always(function() {\n                // Don't match elem in the :animated selector\n                delete tick.elem;\n            }),\n            tick = function() {\n                if (stopped) {\n                    return false;\n                }\n                var currentTime = fxNow || createFxNow(),\n                    remaining = Math.max(\n                        0,\n                        animation.startTime + animation.duration - currentTime\n                    ),\n                    // Support: Android 2.3 only\n                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n                    temp = remaining / animation.duration || 0,\n                    percent = 1 - temp,\n                    index = 0,\n                    length = animation.tweens.length;\n\n                for (; index < length; index++) {\n                    animation.tweens[index].run(percent);\n                }\n\n                deferred.notifyWith(elem, [ animation, percent, remaining ]);\n\n                if (percent < 1 && length) {\n                    return remaining;\n                } else {\n                    deferred.resolveWith(elem, [ animation ]);\n                    return false;\n                }\n            },\n            animation = deferred.promise({\n                elem: elem,\n                props: jQuery.extend({}, properties),\n                opts: jQuery.extend(\n                    true,\n                    { specialEasing: {}, easing: jQuery.easing._default },\n                    options\n                ),\n                originalProperties: properties,\n                originalOptions: options,\n                startTime: fxNow || createFxNow(),\n                duration: options.duration,\n                tweens: [],\n                createTween: function(prop, end) {\n                    var tween = jQuery.Tween(\n                        elem,\n                        animation.opts,\n                        prop,\n                        end,\n                        animation.opts.specialEasing[prop] ||\n                            animation.opts.easing\n                    );\n                    animation.tweens.push(tween);\n                    return tween;\n                },\n                stop: function(gotoEnd) {\n                    var index = 0,\n                        // If we are going to the end, we want to run all the tweens\n                        // otherwise we skip this part\n                        length = gotoEnd ? animation.tweens.length : 0;\n                    if (stopped) {\n                        return this;\n                    }\n                    stopped = true;\n                    for (; index < length; index++) {\n                        animation.tweens[index].run(1);\n                    }\n\n                    // Resolve when we played the last frame; otherwise, reject\n                    if (gotoEnd) {\n                        deferred.notifyWith(elem, [ animation, 1, 0 ]);\n                        deferred.resolveWith(elem, [ animation, gotoEnd ]);\n                    } else {\n                        deferred.rejectWith(elem, [ animation, gotoEnd ]);\n                    }\n                    return this;\n                }\n            }),\n            props = animation.props;\n\n        propFilter(props, animation.opts.specialEasing);\n\n        for (; index < length; index++) {\n            result = Animation.prefilters[index].call(\n                animation,\n                elem,\n                props,\n                animation.opts\n            );\n            if (result) {\n                if (jQuery.isFunction(result.stop)) {\n                    jQuery._queueHooks(\n                        animation.elem,\n                        animation.opts.queue\n                    ).stop = jQuery.proxy(result.stop, result);\n                }\n                return result;\n            }\n        }\n\n        jQuery.map(props, createTween, animation);\n\n        if (jQuery.isFunction(animation.opts.start)) {\n            animation.opts.start.call(elem, animation);\n        }\n\n        jQuery.fx.timer(\n            jQuery.extend(tick, {\n                elem: elem,\n                anim: animation,\n                queue: animation.opts.queue\n            })\n        );\n\n        // attach callbacks from options\n        return animation\n            .progress(animation.opts.progress)\n            .done(animation.opts.done, animation.opts.complete)\n            .fail(animation.opts.fail)\n            .always(animation.opts.always);\n    }\n\n    jQuery.Animation = jQuery.extend(Animation, {\n        tweeners: {\n            \"*\": [\n                function(prop, value) {\n                    var tween = this.createTween(prop, value);\n                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n                    return tween;\n                }\n            ]\n        },\n        tweener: function(props, callback) {\n            if (jQuery.isFunction(props)) {\n                callback = props;\n                props = [ \"*\" ];\n            } else {\n                props = props.match(rnothtmlwhite);\n            }\n\n            var prop, index = 0, length = props.length;\n\n            for (; index < length; index++) {\n                prop = props[index];\n                Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n                Animation.tweeners[prop].unshift(callback);\n            }\n        },\n        prefilters: [ defaultPrefilter ],\n        prefilter: function(callback, prepend) {\n            if (prepend) {\n                Animation.prefilters.unshift(callback);\n            } else {\n                Animation.prefilters.push(callback);\n            }\n        }\n    });\n\n    jQuery.speed = function(speed, easing, fn) {\n        var opt = speed && typeof speed === \"object\"\n            ? jQuery.extend({}, speed)\n            : {\n                complete: fn ||\n                    !fn && easing ||\n                    jQuery.isFunction(speed) && speed,\n                duration: speed,\n                easing: fn && easing ||\n                    easing && !jQuery.isFunction(easing) && easing\n            };\n\n        // Go to the end state if fx are off or if document is hidden\n        if (jQuery.fx.off || document.hidden) {\n            opt.duration = 0;\n        } else {\n            if (typeof opt.duration !== \"number\") {\n                if (opt.duration in jQuery.fx.speeds) {\n                    opt.duration = jQuery.fx.speeds[opt.duration];\n                } else {\n                    opt.duration = jQuery.fx.speeds._default;\n                }\n            }\n        }\n\n        // Normalize opt.queue - true/undefined/null -> \"fx\"\n        if (opt.queue == null || opt.queue === true) {\n            opt.queue = \"fx\";\n        }\n\n        // Queueing\n        opt.old = opt.complete;\n\n        opt.complete = function() {\n            if (jQuery.isFunction(opt.old)) {\n                opt.old.call(this);\n            }\n\n            if (opt.queue) {\n                jQuery.dequeue(this, opt.queue);\n            }\n        };\n\n        return opt;\n    };\n\n    jQuery.fn.extend({\n        fadeTo: function(speed, to, easing, callback) {\n            // Show any hidden elements after setting opacity to 0\n            return this\n                .filter(isHiddenWithinTree)\n                .css(\"opacity\", 0)\n                .show()\n                .end()\n                .animate({ opacity: to }, speed, easing, callback);\n        },\n        animate: function(prop, speed, easing, callback) {\n            var empty = jQuery.isEmptyObject(prop),\n                optall = jQuery.speed(speed, easing, callback),\n                doAnimation = function() {\n                    // Operate on a copy of prop so per-property easing won't be lost\n                    var anim = Animation(this, jQuery.extend({}, prop), optall);\n\n                    // Empty animations, or finishing resolves immediately\n                    if (empty || dataPriv.get(this, \"finish\")) {\n                        anim.stop(true);\n                    }\n                };\n            doAnimation.finish = doAnimation;\n\n            return empty || optall.queue === false\n                ? this.each(doAnimation)\n                : this.queue(optall.queue, doAnimation);\n        },\n        stop: function(type, clearQueue, gotoEnd) {\n            var stopQueue = function(hooks) {\n                var stop = hooks.stop;\n                delete hooks.stop;\n                stop(gotoEnd);\n            };\n\n            if (typeof type !== \"string\") {\n                gotoEnd = clearQueue;\n                clearQueue = type;\n                type = undefined;\n            }\n            if (clearQueue && type !== false) {\n                this.queue(type || \"fx\", []);\n            }\n\n            return this.each(function() {\n                var dequeue = true,\n                    index = type != null && type + \"queueHooks\",\n                    timers = jQuery.timers,\n                    data = dataPriv.get(this);\n\n                if (index) {\n                    if (data[index] && data[index].stop) {\n                        stopQueue(data[index]);\n                    }\n                } else {\n                    for (index in data) {\n                        if (\n                            data[index] && data[index].stop && rrun.test(index)\n                        ) {\n                            stopQueue(data[index]);\n                        }\n                    }\n                }\n\n                for (index = timers.length; index--; ) {\n                    if (\n                        timers[index].elem === this &&\n                            (type == null || timers[index].queue === type)\n                    ) {\n                        timers[index].anim.stop(gotoEnd);\n                        dequeue = false;\n                        timers.splice(index, 1);\n                    }\n                }\n\n                // Start the next in the queue if the last step wasn't forced.\n                // Timers currently will call their complete callbacks, which\n                // will dequeue but only if they were gotoEnd.\n                if (dequeue || !gotoEnd) {\n                    jQuery.dequeue(this, type);\n                }\n            });\n        },\n        finish: function(type) {\n            if (type !== false) {\n                type = type || \"fx\";\n            }\n            return this.each(function() {\n                var index,\n                    data = dataPriv.get(this),\n                    queue = data[type + \"queue\"],\n                    hooks = data[type + \"queueHooks\"],\n                    timers = jQuery.timers,\n                    length = queue ? queue.length : 0;\n\n                // Enable finishing flag on private data\n                data.finish = true;\n\n                // Empty the queue first\n                jQuery.queue(this, type, []);\n\n                if (hooks && hooks.stop) {\n                    hooks.stop.call(this, true);\n                }\n\n                // Look for any active animations, and finish them\n                for (index = timers.length; index--; ) {\n                    if (\n                        timers[index].elem === this &&\n                            timers[index].queue === type\n                    ) {\n                        timers[index].anim.stop(true);\n                        timers.splice(index, 1);\n                    }\n                }\n\n                // Look for any animations in the old queue and finish them\n                for (index = 0; index < length; index++) {\n                    if (queue[index] && queue[index].finish) {\n                        queue[index].finish.call(this);\n                    }\n                }\n\n                // Turn off finishing flag\n                delete data.finish;\n            });\n        }\n    });\n\n    jQuery.each([ \"toggle\", \"show\", \"hide\" ], function(i, name) {\n        var cssFn = jQuery.fn[name];\n        jQuery.fn[name] = function(speed, easing, callback) {\n            return speed == null || typeof speed === \"boolean\"\n                ? cssFn.apply(this, arguments)\n                : this.animate(genFx(name, true), speed, easing, callback);\n        };\n    });\n\n    // Generate shortcuts for custom animations\n    jQuery.each(\n        {\n            slideDown: genFx(\"show\"),\n            slideUp: genFx(\"hide\"),\n            slideToggle: genFx(\"toggle\"),\n            fadeIn: { opacity: \"show\" },\n            fadeOut: { opacity: \"hide\" },\n            fadeToggle: { opacity: \"toggle\" }\n        },\n        function(name, props) {\n            jQuery.fn[name] = function(speed, easing, callback) {\n                return this.animate(props, speed, easing, callback);\n            };\n        }\n    );\n\n    jQuery.timers = [];\n    jQuery.fx.tick = function() {\n        var timer, i = 0, timers = jQuery.timers;\n\n        fxNow = jQuery.now();\n\n        for (; i < timers.length; i++) {\n            timer = timers[i];\n\n            // Checks the timer has not already been removed\n            if (!timer() && timers[i] === timer) {\n                timers.splice((i--), 1);\n            }\n        }\n\n        if (!timers.length) {\n            jQuery.fx.stop();\n        }\n        fxNow = undefined;\n    };\n\n    jQuery.fx.timer = function(timer) {\n        jQuery.timers.push(timer);\n        if (timer()) {\n            jQuery.fx.start();\n        } else {\n            jQuery.timers.pop();\n        }\n    };\n\n    jQuery.fx.interval = 13;\n    jQuery.fx.start = function() {\n        if (!timerId) {\n            timerId = window.requestAnimationFrame\n                ? window.requestAnimationFrame(raf)\n                : window.setInterval(jQuery.fx.tick, jQuery.fx.interval);\n        }\n    };\n\n    jQuery.fx.stop = function() {\n        if (window.cancelAnimationFrame) {\n            window.cancelAnimationFrame(timerId);\n        } else {\n            window.clearInterval(timerId);\n        }\n\n        timerId = null;\n    };\n\n    jQuery.fx.speeds = {\n        slow: 600,\n        fast: 200,\n        // Default speed\n        _default: 400\n    };\n\n    // Based off of the plugin by Clint Helfers, with permission.\n    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n    jQuery.fn.delay = function(time, type) {\n        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n        type = type || \"fx\";\n\n        return this.queue(type, function(next, hooks) {\n            var timeout = window.setTimeout(next, time);\n            hooks.stop = function() {\n                window.clearTimeout(timeout);\n            };\n        });\n    };\n\n    (function() {\n        var input = document.createElement(\"input\"),\n            select = document.createElement(\"select\"),\n            opt = select.appendChild(document.createElement(\"option\"));\n\n        input.type = \"checkbox\";\n\n        // Support: Android <=4.3 only\n        // Default value for a checkbox should be \"on\"\n        support.checkOn = input.value !== \"\";\n\n        // Support: IE <=11 only\n        // Must access selectedIndex to make default options select\n        support.optSelected = opt.selected;\n\n        // Support: IE <=11 only\n        // An input loses its value after becoming a radio\n        input = document.createElement(\"input\");\n        input.value = \"t\";\n        input.type = \"radio\";\n        support.radioValue = input.value === \"t\";\n    })();\n\n    var boolHook, attrHandle = jQuery.expr.attrHandle;\n\n    jQuery.fn.extend({\n        attr: function(name, value) {\n            return access(this, jQuery.attr, name, value, arguments.length > 1);\n        },\n        removeAttr: function(name) {\n            return this.each(function() {\n                jQuery.removeAttr(this, name);\n            });\n        }\n    });\n\n    jQuery.extend({\n        attr: function(elem, name, value) {\n            var ret, hooks, nType = elem.nodeType;\n\n            // Don't get/set attributes on text, comment and attribute nodes\n            if (nType === 3 || nType === 8 || nType === 2) {\n                return;\n            }\n\n            // Fallback to prop when attributes are not supported\n            if (typeof elem.getAttribute === \"undefined\") {\n                return jQuery.prop(elem, name, value);\n            }\n\n            // Attribute hooks are determined by the lowercase version\n            // Grab necessary hook if one is defined\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                hooks = jQuery.attrHooks[name.toLowerCase()] ||\n                    (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n            }\n\n            if (value !== undefined) {\n                if (value === null) {\n                    jQuery.removeAttr(elem, name);\n                    return;\n                }\n\n                if (\n                    hooks &&\n                        \"set\" in hooks &&\n                        (ret = hooks.set(elem, value, name)) !== undefined\n                ) {\n                    return ret;\n                }\n\n                elem.setAttribute(name, value + \"\");\n                return value;\n            }\n\n            if (\n                hooks &&\n                    \"get\" in hooks &&\n                    (ret = hooks.get(elem, name)) !== null\n            ) {\n                return ret;\n            }\n\n            ret = jQuery.find.attr(elem, name);\n\n            // Non-existent attributes return null, we normalize to undefined\n            return ret == null ? undefined : ret;\n        },\n        attrHooks: {\n            type: {\n                set: function(elem, value) {\n                    if (\n                        !support.radioValue &&\n                            value === \"radio\" &&\n                            jQuery.nodeName(elem, \"input\")\n                    ) {\n                        var val = elem.value;\n                        elem.setAttribute(\"type\", value);\n                        if (val) {\n                            elem.value = val;\n                        }\n                        return value;\n                    }\n                }\n            }\n        },\n        removeAttr: function(elem, value) {\n            var name,\n                i = 0,\n                // Attribute names can contain non-HTML whitespace characters\n                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n                attrNames = value && value.match(rnothtmlwhite);\n\n            if (attrNames && elem.nodeType === 1) {\n                while (name = attrNames[i++]) {\n                    elem.removeAttribute(name);\n                }\n            }\n        }\n    });\n\n    // Hooks for boolean attributes\n    boolHook = {\n        set: function(elem, value, name) {\n            if (value === false) {\n                // Remove boolean attributes when set to false\n                jQuery.removeAttr(elem, name);\n            } else {\n                elem.setAttribute(name, name);\n            }\n            return name;\n        }\n    };\n\n    jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function(i, name) {\n        var getter = attrHandle[name] || jQuery.find.attr;\n\n        attrHandle[name] = function(elem, name, isXML) {\n            var ret, handle, lowercaseName = name.toLowerCase();\n\n            if (!isXML) {\n                // Avoid an infinite loop by temporarily removing this function from the getter\n                handle = attrHandle[lowercaseName];\n                attrHandle[lowercaseName] = ret;\n                ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n                attrHandle[lowercaseName] = handle;\n            }\n            return ret;\n        };\n    });\n\n    var rfocusable = /^(?:input|select|textarea|button)$/i,\n        rclickable = /^(?:a|area)$/i;\n\n    jQuery.fn.extend({\n        prop: function(name, value) {\n            return access(this, jQuery.prop, name, value, arguments.length > 1);\n        },\n        removeProp: function(name) {\n            return this.each(function() {\n                delete this[jQuery.propFix[name] || name];\n            });\n        }\n    });\n\n    jQuery.extend({\n        prop: function(elem, name, value) {\n            var ret, hooks, nType = elem.nodeType;\n\n            // Don't get/set properties on text, comment and attribute nodes\n            if (nType === 3 || nType === 8 || nType === 2) {\n                return;\n            }\n\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                // Fix name and attach hooks\n                name = jQuery.propFix[name] || name;\n                hooks = jQuery.propHooks[name];\n            }\n\n            if (value !== undefined) {\n                if (\n                    hooks &&\n                        \"set\" in hooks &&\n                        (ret = hooks.set(elem, value, name)) !== undefined\n                ) {\n                    return ret;\n                }\n\n                return elem[name] = value;\n            }\n\n            if (\n                hooks &&\n                    \"get\" in hooks &&\n                    (ret = hooks.get(elem, name)) !== null\n            ) {\n                return ret;\n            }\n\n            return elem[name];\n        },\n        propHooks: {\n            tabIndex: {\n                get: function(elem) {\n                    // Support: IE <=9 - 11 only\n                    // elem.tabIndex doesn't always return the\n                    // correct value when it hasn't been explicitly set\n                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n                    // Use proper attribute retrieval(#12072)\n                    var tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n                    if (tabindex) {\n                        return parseInt(tabindex, 10);\n                    }\n\n                    if (\n                        rfocusable.test(elem.nodeName) ||\n                            rclickable.test(elem.nodeName) && elem.href\n                    ) {\n                        return 0;\n                    }\n\n                    return -1;\n                }\n            }\n        },\n        propFix: { for: \"htmlFor\", class: \"className\" }\n    });\n\n    // Support: IE <=11 only\n    // Accessing the selectedIndex property\n    // forces the browser to respect setting selected\n    // on the option\n    // The getter ensures a default option is selected\n    // when in an optgroup\n    // eslint rule \"no-unused-expressions\" is disabled for this code\n    // since it considers such accessions noop\n    if (!support.optSelected) {\n        jQuery.propHooks.selected = {\n            get: function(elem) {\n                /* eslint no-unused-expressions: \"off\" */\n                var parent = elem.parentNode;\n                if (parent && parent.parentNode) {\n                    parent.parentNode.selectedIndex;\n                }\n                return null;\n            },\n            set: function(elem) {\n                /* eslint no-unused-expressions: \"off\" */\n                var parent = elem.parentNode;\n                if (parent) {\n                    parent.selectedIndex;\n\n                    if (parent.parentNode) {\n                        parent.parentNode.selectedIndex;\n                    }\n                }\n            }\n        };\n    }\n\n    jQuery.each(\n        [\n            \"tabIndex\",\n            \"readOnly\",\n            \"maxLength\",\n            \"cellSpacing\",\n            \"cellPadding\",\n            \"rowSpan\",\n            \"colSpan\",\n            \"useMap\",\n            \"frameBorder\",\n            \"contentEditable\"\n        ],\n        function() {\n            jQuery.propFix[this.toLowerCase()] = this;\n        }\n    );\n\n    // Strip and collapse whitespace according to HTML spec\n    // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n    function stripAndCollapse(value) {\n        var tokens = value.match(rnothtmlwhite) || [];\n        return tokens.join(\" \");\n    }\n\n    function getClass(elem) {\n        return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n    }\n\n    jQuery.fn.extend({\n        addClass: function(value) {\n            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;\n\n            if (jQuery.isFunction(value)) {\n                return this.each(function(j) {\n                    jQuery(this).addClass(value.call(this, j, getClass(this)));\n                });\n            }\n\n            if (typeof value === \"string\" && value) {\n                classes = value.match(rnothtmlwhite) || [];\n\n                while (elem = this[i++]) {\n                    curValue = getClass(elem);\n                    cur = elem.nodeType === 1 &&\n                        \" \" + stripAndCollapse(curValue) + \" \";\n\n                    if (cur) {\n                        j = 0;\n                        while (clazz = classes[j++]) {\n                            if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                                cur += clazz + \" \";\n                            }\n                        }\n\n                        // Only assign if different to avoid unneeded rendering.\n                        finalValue = stripAndCollapse(cur);\n                        if (curValue !== finalValue) {\n                            elem.setAttribute(\"class\", finalValue);\n                        }\n                    }\n                }\n            }\n\n            return this;\n        },\n        removeClass: function(value) {\n            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;\n\n            if (jQuery.isFunction(value)) {\n                return this.each(function(j) {\n                    jQuery(\n                        this\n                    ).removeClass(value.call(this, j, getClass(this)));\n                });\n            }\n\n            if (!arguments.length) {\n                return this.attr(\"class\", \"\");\n            }\n\n            if (typeof value === \"string\" && value) {\n                classes = value.match(rnothtmlwhite) || [];\n\n                while (elem = this[i++]) {\n                    curValue = getClass(elem);\n\n                    // This expression is here for better compressibility (see addClass)\n                    cur = elem.nodeType === 1 &&\n                        \" \" + stripAndCollapse(curValue) + \" \";\n\n                    if (cur) {\n                        j = 0;\n                        while (clazz = classes[j++]) {\n                            // Remove *all* instances\n                            while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                                cur = cur.replace(\" \" + clazz + \" \", \" \");\n                            }\n                        }\n\n                        // Only assign if different to avoid unneeded rendering.\n                        finalValue = stripAndCollapse(cur);\n                        if (curValue !== finalValue) {\n                            elem.setAttribute(\"class\", finalValue);\n                        }\n                    }\n                }\n            }\n\n            return this;\n        },\n        toggleClass: function(value, stateVal) {\n            var type = typeof value;\n\n            if (typeof stateVal === \"boolean\" && type === \"string\") {\n                return stateVal\n                    ? this.addClass(value)\n                    : this.removeClass(value);\n            }\n\n            if (jQuery.isFunction(value)) {\n                return this.each(function(i) {\n                    jQuery(\n                        this\n                    ).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n                });\n            }\n\n            return this.each(function() {\n                var className, i, self, classNames;\n\n                if (type === \"string\") {\n                    // Toggle individual class names\n                    i = 0;\n                    self = jQuery(this);\n                    classNames = value.match(rnothtmlwhite) || [];\n\n                    while (className = classNames[i++]) {\n                        // Check each className given, space separated list\n                        if (self.hasClass(className)) {\n                            self.removeClass(className);\n                        } else {\n                            self.addClass(className);\n                        }\n                    }\n                    // Toggle whole class name\n                } else if (value === undefined || type === \"boolean\") {\n                    className = getClass(this);\n                    if (className) {\n                        // Store className if set\n                        dataPriv.set(this, \"__className__\", className);\n                    }\n\n                    // If the element has a class name or if we're passed `false`,\n                    // then remove the whole classname (if there was one, the above saved it).\n                    // Otherwise bring back whatever was previously saved (if anything),\n                    // falling back to the empty string if nothing was stored.\n                    if (this.setAttribute) {\n                        this.setAttribute(\n                            \"class\",\n                            className || value === false\n                                ? \"\"\n                                : dataPriv.get(this, \"__className__\") || \"\"\n                        );\n                    }\n                }\n            });\n        },\n        hasClass: function(selector) {\n            var className, elem, i = 0;\n\n            className = \" \" + selector + \" \";\n            while (elem = this[i++]) {\n                if (\n                    elem.nodeType === 1 &&\n                        (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(\n                            className\n                        ) >\n                            -1\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    });\n\n    var rreturn = /\\r/g;\n\n    jQuery.fn.extend({\n        val: function(value) {\n            var hooks, ret, isFunction, elem = this[0];\n\n            if (!arguments.length) {\n                if (elem) {\n                    hooks = jQuery.valHooks[elem.type] ||\n                        jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n                    if (\n                        hooks &&\n                            \"get\" in hooks &&\n                            (ret = hooks.get(elem, \"value\")) !== undefined\n                    ) {\n                        return ret;\n                    }\n\n                    ret = elem.value;\n\n                    // Handle most common string cases\n                    if (typeof ret === \"string\") {\n                        return ret.replace(rreturn, \"\");\n                    }\n\n                    // Handle cases where value is null/undef or number\n                    return ret == null ? \"\" : ret;\n                }\n\n                return;\n            }\n\n            isFunction = jQuery.isFunction(value);\n\n            return this.each(function(i) {\n                var val;\n\n                if (this.nodeType !== 1) {\n                    return;\n                }\n\n                if (isFunction) {\n                    val = value.call(this, i, jQuery(this).val());\n                } else {\n                    val = value;\n                }\n\n                // Treat null/undefined as \"\"; convert numbers to string\n                if (val == null) {\n                    val = \"\";\n                } else if (typeof val === \"number\") {\n                    val += \"\";\n                } else if (jQuery.isArray(val)) {\n                    val = jQuery.map(val, function(value) {\n                        return value == null ? \"\" : value + \"\";\n                    });\n                }\n\n                hooks = jQuery.valHooks[this.type] ||\n                    jQuery.valHooks[this.nodeName.toLowerCase()];\n\n                // If set returns undefined, fall back to normal setting\n                if (\n                    !hooks ||\n                        !(\"set\" in hooks) ||\n                        hooks.set(this, val, \"value\") === undefined\n                ) {\n                    this.value = val;\n                }\n            });\n        }\n    });\n\n    jQuery.extend({\n        valHooks: {\n            option: {\n                get: function(elem) {\n                    var val = jQuery.find.attr(elem, \"value\");\n                    return val != null ? val : // Support: IE <=10 - 11 only\n                        // option.text throws exceptions (#14686, #14858)\n                        // Strip and collapse whitespace\n                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n                        stripAndCollapse(jQuery.text(elem));\n                }\n            },\n            select: {\n                get: function(elem) {\n                    var value,\n                        option,\n                        i,\n                        options = elem.options,\n                        index = elem.selectedIndex,\n                        one = elem.type === \"select-one\",\n                        values = one ? null : [],\n                        max = one ? index + 1 : options.length;\n\n                    if (index < 0) {\n                        i = max;\n                    } else {\n                        i = one ? index : 0;\n                    }\n\n                    // Loop through all the selected options\n                    for (; i < max; i++) {\n                        option = options[i];\n\n                        // Support: IE <=9 only\n                        // IE8-9 doesn't update selected after form reset (#2551)\n                        if (\n                            (option.selected || i === index) &&\n                                // Don't return options that are disabled or in a disabled optgroup\n                                !option.disabled &&\n                                (!option.parentNode.disabled ||\n                                    !jQuery.nodeName(\n                                        option.parentNode,\n                                        \"optgroup\"\n                                    ))\n                        ) {\n                            // Get the specific value for the option\n                            value = jQuery(option).val();\n\n                            // We don't need an array for one selects\n                            if (one) {\n                                return value;\n                            }\n\n                            // Multi-Selects return an array\n                            values.push(value);\n                        }\n                    }\n\n                    return values;\n                },\n                set: function(elem, value) {\n                    var optionSet,\n                        option,\n                        options = elem.options,\n                        values = jQuery.makeArray(value),\n                        i = options.length;\n\n                    while (i--) {\n                        option = options[i];\n\n                        /* eslint-disable no-cond-assign */\n                        if (\n                            option.selected = jQuery.inArray(\n                                jQuery.valHooks.option.get(option),\n                                values\n                            ) >\n                                -1\n                        ) {\n                            optionSet = true;\n                        }\n                        /* eslint-enable no-cond-assign */\n                    }\n\n                    // Force browsers to behave consistently when non-matching value is set\n                    if (!optionSet) {\n                        elem.selectedIndex = -1;\n                    }\n                    return values;\n                }\n            }\n        }\n    });\n\n    // Radios and checkboxes getter/setter\n    jQuery.each([ \"radio\", \"checkbox\" ], function() {\n        jQuery.valHooks[this] = {\n            set: function(elem, value) {\n                if (jQuery.isArray(value)) {\n                    return elem.checked = jQuery.inArray(\n                        jQuery(elem).val(),\n                        value\n                    ) >\n                        -1;\n                }\n            }\n        };\n        if (!support.checkOn) {\n            jQuery.valHooks[this].get = function(elem) {\n                return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n            };\n        }\n    });\n\n    // Return jQuery for attributes-only inclusion\n    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\n    jQuery.extend(jQuery.event, {\n        trigger: function(event, data, elem, onlyHandlers) {\n            var i,\n                cur,\n                tmp,\n                bubbleType,\n                ontype,\n                handle,\n                special,\n                eventPath = [ elem || document ],\n                type = hasOwn.call(event, \"type\") ? event.type : event,\n                namespaces = hasOwn.call(event, \"namespace\")\n                    ? event.namespace.split(\".\")\n                    : [];\n\n            cur = tmp = elem = elem || document;\n\n            // Don't do events on text and comment nodes\n            if (elem.nodeType === 3 || elem.nodeType === 8) {\n                return;\n            }\n\n            // focus/blur morphs to focusin/out; ensure we're not firing them right now\n            if (rfocusMorph.test(type + jQuery.event.triggered)) {\n                return;\n            }\n\n            if (type.indexOf(\".\") > -1) {\n                // Namespaced trigger; create a regexp to match event type in handle()\n                namespaces = type.split(\".\");\n                type = namespaces.shift();\n                namespaces.sort();\n            }\n            ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n            // Caller can pass in a jQuery.Event object, Object, or just an event type string\n            event = event[jQuery.expando]\n                ? event\n                : new jQuery.Event(type, typeof event === \"object\" && event);\n\n            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n            event.isTrigger = onlyHandlers ? 2 : 3;\n            event.namespace = namespaces.join(\".\");\n            event.rnamespace = event.namespace\n                ? new RegExp(\n                    \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"\n                )\n                : null;\n\n            // Clean up the event in case it is being reused\n            event.result = undefined;\n            if (!event.target) {\n                event.target = elem;\n            }\n\n            // Clone any incoming data and prepend the event, creating the handler arg list\n            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);\n\n            // Allow special events to draw outside the lines\n            special = jQuery.event.special[type] || {};\n            if (\n                !onlyHandlers &&\n                    special.trigger &&\n                    special.trigger.apply(elem, data) === false\n            ) {\n                return;\n            }\n\n            // Determine event propagation path in advance, per W3C events spec (#9951)\n            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n                bubbleType = special.delegateType || type;\n                if (!rfocusMorph.test(bubbleType + type)) {\n                    cur = cur.parentNode;\n                }\n                for (; cur; cur = cur.parentNode) {\n                    eventPath.push(cur);\n                    tmp = cur;\n                }\n\n                // Only add window if we got to document (e.g., not plain obj or detached DOM)\n                if (tmp === (elem.ownerDocument || document)) {\n                    eventPath.push(\n                        tmp.defaultView || tmp.parentWindow || window\n                    );\n                }\n            }\n\n            // Fire handlers on the event path\n            i = 0;\n            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n                event.type = i > 1 ? bubbleType : special.bindType || type;\n\n                // jQuery handler\n                handle = (dataPriv.get(cur, \"events\") || {})[event.type] &&\n                    dataPriv.get(cur, \"handle\");\n                if (handle) {\n                    handle.apply(cur, data);\n                }\n\n                // Native handler\n                handle = ontype && cur[ontype];\n                if (handle && handle.apply && acceptData(cur)) {\n                    event.result = handle.apply(cur, data);\n                    if (event.result === false) {\n                        event.preventDefault();\n                    }\n                }\n            }\n            event.type = type;\n\n            // If nobody prevented the default action, do it now\n            if (!onlyHandlers && !event.isDefaultPrevented()) {\n                if (\n                    (!special._default ||\n                        special._default.apply(eventPath.pop(), data) ===\n                            false) &&\n                        acceptData(elem)\n                ) {\n                    // Call a native DOM method on the target with the same name as the event.\n                    // Don't do default actions on window, that's where global variables be (#6170)\n                    if (\n                        ontype &&\n                            jQuery.isFunction(elem[type]) &&\n                            !jQuery.isWindow(elem)\n                    ) {\n                        // Don't re-trigger an onFOO event when we call its FOO() method\n                        tmp = elem[ontype];\n\n                        if (tmp) {\n                            elem[ontype] = null;\n                        }\n\n                        // Prevent re-triggering of the same event, since we already bubbled it above\n                        jQuery.event.triggered = type;\n                        elem[type]();\n                        jQuery.event.triggered = undefined;\n\n                        if (tmp) {\n                            elem[ontype] = tmp;\n                        }\n                    }\n                }\n            }\n\n            return event.result;\n        },\n        // Piggyback on a donor event to simulate a different one\n        // Used only for `focus(in | out)` events\n        simulate: function(type, elem, event) {\n            var e = jQuery.extend(new jQuery.Event(), event, {\n                type: type,\n                isSimulated: true\n            });\n\n            jQuery.event.trigger(e, null, elem);\n        }\n    });\n\n    jQuery.fn.extend({\n        trigger: function(type, data) {\n            return this.each(function() {\n                jQuery.event.trigger(type, data, this);\n            });\n        },\n        triggerHandler: function(type, data) {\n            var elem = this[0];\n            if (elem) {\n                return jQuery.event.trigger(type, data, elem, true);\n            }\n        }\n    });\n\n    jQuery.each(\n        (\"blur focus focusin focusout resize scroll click dblclick \" +\n            \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n            \"change select submit keydown keypress keyup contextmenu\").split(\n            \" \"\n        ),\n        function(i, name) {\n            // Handle event binding\n            jQuery.fn[name] = function(data, fn) {\n                return arguments.length > 0\n                    ? this.on(name, null, data, fn)\n                    : this.trigger(name);\n            };\n        }\n    );\n\n    jQuery.fn.extend({\n        hover: function(fnOver, fnOut) {\n            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n        }\n    });\n\n    support.focusin = \"onfocusin\" in window;\n\n    // Support: Firefox <=44\n    // Firefox doesn't have focus(in | out) events\n    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n    //\n    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n    // focus(in | out) events fire after focus & blur events,\n    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n    if (!support.focusin) {\n        jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function(\n            orig,\n            fix\n        ) {\n            // Attach a single capturing handler on the document while someone wants focusin/focusout\n            var handler = function(event) {\n                jQuery.event.simulate(\n                    fix,\n                    event.target,\n                    jQuery.event.fix(event)\n                );\n            };\n\n            jQuery.event.special[fix] = {\n                setup: function() {\n                    var doc = this.ownerDocument || this,\n                        attaches = dataPriv.access(doc, fix);\n\n                    if (!attaches) {\n                        doc.addEventListener(orig, handler, true);\n                    }\n                    dataPriv.access(doc, fix, (attaches || 0) + 1);\n                },\n                teardown: function() {\n                    var doc = this.ownerDocument || this,\n                        attaches = dataPriv.access(doc, fix) - 1;\n\n                    if (!attaches) {\n                        doc.removeEventListener(orig, handler, true);\n                        dataPriv.remove(doc, fix);\n                    } else {\n                        dataPriv.access(doc, fix, attaches);\n                    }\n                }\n            };\n        });\n    }\n    var location = window.location;\n\n    var nonce = jQuery.now();\n\n    var rquery = /\\?/;\n\n    // Cross-browser xml parsing\n    jQuery.parseXML = function(data) {\n        var xml;\n        if (!data || typeof data !== \"string\") {\n            return null;\n        }\n\n        // Support: IE 9 - 11 only\n        // IE throws on parseFromString with invalid input.\n        try {\n            xml = new window.DOMParser().parseFromString(data, \"text/xml\");\n        } catch (e) {\n            xml = undefined;\n        }\n\n        if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n            jQuery.error(\"Invalid XML: \" + data);\n        }\n        return xml;\n    };\n\n    var rbracket = /\\[\\]$/,\n        rCRLF = /\\r?\\n/g,\n        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n        rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n    function buildParams(prefix, obj, traditional, add) {\n        var name;\n\n        if (jQuery.isArray(obj)) {\n            // Serialize array item.\n            jQuery.each(obj, function(i, v) {\n                if (traditional || rbracket.test(prefix)) {\n                    // Treat each array item as a scalar.\n                    add(prefix, v);\n                } else {\n                    // Item is non-scalar (array or object), encode its numeric index.\n                    buildParams(\n                        prefix +\n                            \"[\" +\n                            (typeof v === \"object\" && v != null ? i : \"\") +\n                            \"]\",\n                        v,\n                        traditional,\n                        add\n                    );\n                }\n            });\n        } else if (!traditional && jQuery.type(obj) === \"object\") {\n            // Serialize object item.\n            for (name in obj) {\n                buildParams(\n                    prefix + \"[\" + name + \"]\",\n                    obj[name],\n                    traditional,\n                    add\n                );\n            }\n        } else {\n            // Serialize scalar item.\n            add(prefix, obj);\n        }\n    }\n\n    // Serialize an array of form elements or a set of\n    // key/values into a query string\n    jQuery.param = function(a, traditional) {\n        var prefix,\n            s = [],\n            add = function(key, valueOrFunction) {\n                // If value is a function, invoke it and use its return value\n                var value = jQuery.isFunction(valueOrFunction)\n                    ? valueOrFunction()\n                    : valueOrFunction;\n\n                s[s.length] = encodeURIComponent(key) +\n                    \"=\" +\n                    encodeURIComponent(value == null ? \"\" : value);\n            };\n\n        // If an array was passed in, assume that it is an array of form elements.\n        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n            // Serialize the form elements\n            jQuery.each(a, function() {\n                add(this.name, this.value);\n            });\n        } else {\n            // If traditional, encode the \"old\" way (the way 1.3.2 or older\n            // did it), otherwise encode params recursively.\n            for (prefix in a) {\n                buildParams(prefix, a[prefix], traditional, add);\n            }\n        }\n\n        // Return the resulting serialization\n        return s.join(\"&\");\n    };\n\n    jQuery.fn.extend({\n        serialize: function() {\n            return jQuery.param(this.serializeArray());\n        },\n        serializeArray: function() {\n            return this\n                .map(function() {\n                    // Can add propHook for \"elements\" to filter or add form elements\n                    var elements = jQuery.prop(this, \"elements\");\n                    return elements ? jQuery.makeArray(elements) : this;\n                })\n                .filter(function() {\n                    var type = this.type;\n\n                    // Use .is( \":disabled\" ) so that fieldset[disabled] works\n                    return this.name &&\n                        !jQuery(this).is(\":disabled\") &&\n                        rsubmittable.test(this.nodeName) &&\n                        !rsubmitterTypes.test(type) &&\n                        (this.checked || !rcheckableType.test(type));\n                })\n                .map(function(i, elem) {\n                    var val = jQuery(this).val();\n\n                    if (val == null) {\n                        return null;\n                    }\n\n                    if (jQuery.isArray(val)) {\n                        return jQuery.map(val, function(val) {\n                            return {\n                                name: elem.name,\n                                value: val.replace(rCRLF, \"\\r\\n\")\n                            };\n                        });\n                    }\n\n                    return {\n                        name: elem.name,\n                        value: val.replace(rCRLF, \"\\r\\n\")\n                    };\n                })\n                .get();\n        }\n    });\n\n    var r20 = /%20/g,\n        rhash = /#.*$/,\n        rantiCache = /([?&])_=[^&]*/,\n        rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n        // #7653, #8125, #8152: local protocol detection\n        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n        rnoContent = /^(?:GET|HEAD)$/,\n        rprotocol = /^\\/\\//,\n        /* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n        prefilters = {},\n        /* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n        transports = {},\n        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n        allTypes = \"*/\".concat(\"*\"),\n        // Anchor tag for parsing the document origin\n        originAnchor = document.createElement(\"a\");\n    originAnchor.href = location.href;\n\n    // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n    function addToPrefiltersOrTransports(structure) {\n        // dataTypeExpression is optional and defaults to \"*\"\n        return function(dataTypeExpression, func) {\n            if (typeof dataTypeExpression !== \"string\") {\n                func = dataTypeExpression;\n                dataTypeExpression = \"*\";\n            }\n\n            var dataType,\n                i = 0,\n                dataTypes = dataTypeExpression\n                    .toLowerCase()\n                    .match(rnothtmlwhite) ||\n                    [];\n\n            if (jQuery.isFunction(func)) {\n                // For each dataType in the dataTypeExpression\n                while (dataType = dataTypes[i++]) {\n                    // Prepend if requested\n                    if (dataType[0] === \"+\") {\n                        dataType = dataType.slice(1) || \"*\";\n                        (structure[dataType] = structure[dataType] ||\n                            []).unshift(func);\n                        // Otherwise append\n                    } else {\n                        (structure[dataType] = structure[dataType] ||\n                            []).push(func);\n                    }\n                }\n            }\n        };\n    }\n\n    // Base inspection function for prefilters and transports\n    function inspectPrefiltersOrTransports(\n        structure,\n        options,\n        originalOptions,\n        jqXHR\n    ) {\n        var inspected = {}, seekingTransport = structure === transports;\n\n        function inspect(dataType) {\n            var selected;\n            inspected[dataType] = true;\n            jQuery.each(structure[dataType] || [], function(\n                _,\n                prefilterOrFactory\n            ) {\n                var dataTypeOrTransport = prefilterOrFactory(\n                    options,\n                    originalOptions,\n                    jqXHR\n                );\n                if (\n                    typeof dataTypeOrTransport === \"string\" &&\n                        !seekingTransport &&\n                        !inspected[dataTypeOrTransport]\n                ) {\n                    options.dataTypes.unshift(dataTypeOrTransport);\n                    inspect(dataTypeOrTransport);\n                    return false;\n                } else if (seekingTransport) {\n                    return !(selected = dataTypeOrTransport);\n                }\n            });\n            return selected;\n        }\n\n        return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n    }\n\n    // A special extend for ajax options\n    // that takes \"flat\" options (not to be deep extended)\n    // Fixes #9887\n    function ajaxExtend(target, src) {\n        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n        for (key in src) {\n            if (src[key] !== undefined) {\n                (flatOptions[key]\n                    ? target\n                    : deep || (deep = {}))[key] = src[key];\n            }\n        }\n        if (deep) {\n            jQuery.extend(true, target, deep);\n        }\n\n        return target;\n    }\n\n    /* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\n    function ajaxHandleResponses(s, jqXHR, responses) {\n        var ct,\n            type,\n            finalDataType,\n            firstDataType,\n            contents = s.contents,\n            dataTypes = s.dataTypes;\n\n        // Remove auto dataType and get content-type in the process\n        while (dataTypes[0] === \"*\") {\n            dataTypes.shift();\n            if (ct === undefined) {\n                ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n            }\n        }\n\n        // Check if we're dealing with a known content-type\n        if (ct) {\n            for (type in contents) {\n                if (contents[type] && contents[type].test(ct)) {\n                    dataTypes.unshift(type);\n                    break;\n                }\n            }\n        }\n\n        // Check to see if we have a response for the expected dataType\n        if (dataTypes[0] in responses) {\n            finalDataType = dataTypes[0];\n        } else {\n            // Try convertible dataTypes\n            for (type in responses) {\n                if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n                    finalDataType = type;\n                    break;\n                }\n                if (!firstDataType) {\n                    firstDataType = type;\n                }\n            }\n\n            // Or just use first one\n            finalDataType = finalDataType || firstDataType;\n        }\n\n        // If we found a dataType\n        // We add the dataType to the list if needed\n        // and return the corresponding response\n        if (finalDataType) {\n            if (finalDataType !== dataTypes[0]) {\n                dataTypes.unshift(finalDataType);\n            }\n            return responses[finalDataType];\n        }\n    }\n\n    /* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\n    function ajaxConvert(s, response, jqXHR, isSuccess) {\n        var conv2,\n            current,\n            conv,\n            tmp,\n            prev,\n            converters = {},\n            // Work with a copy of dataTypes in case we need to modify it for conversion\n            dataTypes = s.dataTypes.slice();\n\n        // Create converters map with lowercased keys\n        if (dataTypes[1]) {\n            for (conv in s.converters) {\n                converters[conv.toLowerCase()] = s.converters[conv];\n            }\n        }\n\n        current = dataTypes.shift();\n\n        // Convert to each sequential dataType\n        while (current) {\n            if (s.responseFields[current]) {\n                jqXHR[s.responseFields[current]] = response;\n            }\n\n            // Apply the dataFilter if provided\n            if (!prev && isSuccess && s.dataFilter) {\n                response = s.dataFilter(response, s.dataType);\n            }\n\n            prev = current;\n            current = dataTypes.shift();\n\n            if (current) {\n                // There's only work to do if current dataType is non-auto\n                if (current === \"*\") {\n                    current = prev;\n                    // Convert response if prev dataType is non-auto and differs from current\n                } else if (prev !== \"*\" && prev !== current) {\n                    // Seek a direct converter\n                    conv = converters[prev + \" \" + current] ||\n                        converters[\"* \" + current];\n\n                    // If none found, seek a pair\n                    if (!conv) {\n                        for (conv2 in converters) {\n                            // If conv2 outputs current\n                            tmp = conv2.split(\" \");\n                            if (tmp[1] === current) {\n                                // If prev can be converted to accepted input\n                                conv = converters[prev + \" \" + tmp[0]] ||\n                                    converters[\"* \" + tmp[0]];\n                                if (conv) {\n                                    // Condense equivalence converters\n                                    if (conv === true) {\n                                        conv = converters[conv2];\n                                        // Otherwise, insert the intermediate dataType\n                                    } else if (converters[conv2] !== true) {\n                                        current = tmp[0];\n                                        dataTypes.unshift(tmp[1]);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    // Apply converter (if not an equivalence)\n                    if (conv !== true) {\n                        // Unless errors are allowed to bubble, catch and return them\n                        if (conv && s.throws) {\n                            response = conv(response);\n                        } else {\n                            try {\n                                response = conv(response);\n                            } catch (e) {\n                                return {\n                                    state: \"parsererror\",\n                                    error: conv\n                                        ? e\n                                        : \"No conversion from \" +\n                                            prev +\n                                            \" to \" +\n                                            current\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return { state: \"success\", data: response };\n    }\n\n    jQuery.extend({\n        // Counter for holding the number of active queries\n        active: 0,\n        // Last-Modified header cache for next request\n        lastModified: {},\n        etag: {},\n        ajaxSettings: {\n            url: location.href,\n            type: \"GET\",\n            isLocal: rlocalProtocol.test(location.protocol),\n            global: true,\n            processData: true,\n            async: true,\n            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n            /*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n            accepts: {\n                \"*\": allTypes,\n                text: \"text/plain\",\n                html: \"text/html\",\n                xml: \"application/xml, text/xml\",\n                json: \"application/json, text/javascript\"\n            },\n            contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ },\n            responseFields: {\n                xml: \"responseXML\",\n                text: \"responseText\",\n                json: \"responseJSON\"\n            },\n            // Data converters\n            // Keys separate source (or catchall \"*\") and destination types with a single space\n            converters: {\n                // Convert anything to text\n                \"* text\": String,\n                // Text to html (true = no transformation)\n                \"text html\": true,\n                // Evaluate text as a json expression\n                \"text json\": JSON.parse,\n                // Parse text as xml\n                \"text xml\": jQuery.parseXML\n            },\n            // For options that shouldn't be deep extended:\n            // you can add your own custom options here if\n            // and when you create one that shouldn't be\n            // deep extended (see ajaxExtend)\n            flatOptions: { url: true, context: true }\n        },\n        // Creates a full fledged settings object into target\n        // with both ajaxSettings and settings fields.\n        // If target is omitted, writes into ajaxSettings.\n        ajaxSetup: function(target, settings) {\n            return settings ? // Building a settings object\n                ajaxExtend(\n                    ajaxExtend(target, jQuery.ajaxSettings),\n                    settings\n                ) : // Extending ajaxSettings\n                ajaxExtend(jQuery.ajaxSettings, target);\n        },\n        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n        ajaxTransport: addToPrefiltersOrTransports(transports),\n        // Main method\n        ajax: function(url, options) {\n            // If url is an object, simulate pre-1.5 signature\n            if (typeof url === \"object\") {\n                options = url;\n                url = undefined;\n            }\n\n            // Force options to be an object\n            options = options || {};\n\n            var transport,\n                // URL without anti-cache param\n                cacheURL,\n                // Response headers\n                responseHeadersString,\n                responseHeaders,\n                // timeout handle\n                timeoutTimer,\n                // Url cleanup var\n                urlAnchor,\n                // Request state (becomes false upon send and true upon completion)\n                completed,\n                // To know if global events are to be dispatched\n                fireGlobals,\n                // Loop variable\n                i,\n                // uncached part of the url\n                uncached,\n                // Create the final options object\n                s = jQuery.ajaxSetup({}, options),\n                // Callbacks context\n                callbackContext = s.context || s,\n                // Context for global events is callbackContext if it is a DOM node or jQuery collection\n                globalEventContext = s.context &&\n                    (callbackContext.nodeType || callbackContext.jquery)\n                    ? jQuery(callbackContext)\n                    : jQuery.event,\n                // Deferreds\n                deferred = jQuery.Deferred(),\n                completeDeferred = jQuery.Callbacks(\"once memory\"),\n                // Status-dependent callbacks\n                statusCode = s.statusCode || {},\n                // Headers (they are sent all at once)\n                requestHeaders = {},\n                requestHeadersNames = {},\n                // Default abort message\n                strAbort = \"canceled\",\n                // Fake xhr\n                jqXHR = {\n                    readyState: 0,\n                    // Builds headers hashtable if needed\n                    getResponseHeader: function(key) {\n                        var match;\n                        if (completed) {\n                            if (!responseHeaders) {\n                                responseHeaders = {};\n                                while (\n                                    match = rheaders.exec(responseHeadersString)\n                                ) {\n                                    responseHeaders[match[1].toLowerCase()] = match[2];\n                                }\n                            }\n                            match = responseHeaders[key.toLowerCase()];\n                        }\n                        return match == null ? null : match;\n                    },\n                    // Raw string\n                    getAllResponseHeaders: function() {\n                        return completed ? responseHeadersString : null;\n                    },\n                    // Caches the header\n                    setRequestHeader: function(name, value) {\n                        if (completed == null) {\n                            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] ||\n                                name;\n                            requestHeaders[name] = value;\n                        }\n                        return this;\n                    },\n                    // Overrides response content-type header\n                    overrideMimeType: function(type) {\n                        if (completed == null) {\n                            s.mimeType = type;\n                        }\n                        return this;\n                    },\n                    // Status-dependent callbacks\n                    statusCode: function(map) {\n                        var code;\n                        if (map) {\n                            if (completed) {\n                                // Execute the appropriate callbacks\n                                jqXHR.always(map[jqXHR.status]);\n                            } else {\n                                // Lazy-add the new callbacks in a way that preserves old ones\n                                for (code in map) {\n                                    statusCode[code] = [\n                                        statusCode[code],\n                                        map[code]\n                                    ];\n                                }\n                            }\n                        }\n                        return this;\n                    },\n                    // Cancel the request\n                    abort: function(statusText) {\n                        var finalText = statusText || strAbort;\n                        if (transport) {\n                            transport.abort(finalText);\n                        }\n                        done(0, finalText);\n                        return this;\n                    }\n                };\n\n            // Attach deferreds\n            deferred.promise(jqXHR);\n\n            // Add protocol if not provided (prefilters might expect it)\n            // Handle falsy url in the settings object (#10093: consistency with old signature)\n            // We also use the url parameter if available\n            s.url = ((url || s.url || location.href) + \"\").replace(\n                rprotocol,\n                location.protocol + \"//\"\n            );\n\n            // Alias method option to type as per ticket #12004\n            s.type = options.method || options.type || s.method || s.type;\n\n            // Extract dataTypes list\n            s.dataTypes = (s.dataType || \"*\")\n                .toLowerCase()\n                .match(rnothtmlwhite) ||\n                [ \"\" ];\n\n            // A cross-domain request is in order when the origin doesn't match the current origin.\n            if (s.crossDomain == null) {\n                urlAnchor = document.createElement(\"a\");\n\n                // Support: IE <=8 - 11, Edge 12 - 13\n                // IE throws exception on accessing the href property if url is malformed,\n                // e.g. http://example.com:80x/\n                try {\n                    urlAnchor.href = s.url;\n\n                    // Support: IE <=8 - 11 only\n                    // Anchor's host property isn't correctly set when s.url is relative\n                    urlAnchor.href = urlAnchor.href;\n                    s.crossDomain = originAnchor.protocol +\n                        \"//\" +\n                        originAnchor.host !==\n                        urlAnchor.protocol + \"//\" + urlAnchor.host;\n                } catch (e) {\n                    // If there is an error parsing the URL, assume it is crossDomain,\n                    // it can be rejected by the transport if it is invalid\n                    s.crossDomain = true;\n                }\n            }\n\n            // Convert data if not already a string\n            if (s.data && s.processData && typeof s.data !== \"string\") {\n                s.data = jQuery.param(s.data, s.traditional);\n            }\n\n            // Apply prefilters\n            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n\n            // If request was aborted inside a prefilter, stop there\n            if (completed) {\n                return jqXHR;\n            }\n\n            // We can fire global events as of now if asked to\n            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n            fireGlobals = jQuery.event && s.global;\n\n            // Watch for a new set of requests\n            if (fireGlobals && jQuery.active++ === 0) {\n                jQuery.event.trigger(\"ajaxStart\");\n            }\n\n            // Uppercase the type\n            s.type = s.type.toUpperCase();\n\n            // Determine if request has content\n            s.hasContent = !rnoContent.test(s.type);\n\n            // Save the URL in case we're toying with the If-Modified-Since\n            // and/or If-None-Match header later on\n            // Remove hash to simplify url manipulation\n            cacheURL = s.url.replace(rhash, \"\");\n\n            // More options handling for requests with no content\n            if (!s.hasContent) {\n                // Remember the hash so we can put it back\n                uncached = s.url.slice(cacheURL.length);\n\n                // If data is available, append data to url\n                if (s.data) {\n                    cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n\n                    // #9682: remove data so that it's not used in an eventual retry\n                    delete s.data;\n                }\n\n                // Add or update anti-cache param if needed\n                if (s.cache === false) {\n                    cacheURL = cacheURL.replace(rantiCache, \"$1\");\n                    uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") +\n                        \"_=\" +\n                        nonce++ +\n                        uncached;\n                }\n\n                // Put hash and anti-cache on the URL that will be requested (gh-1732)\n                s.url = cacheURL + uncached;\n                // Change '%20' to '+' if this is encoded form body content (gh-2658)\n            } else if (\n                s.data &&\n                    s.processData &&\n                    (s.contentType || \"\").indexOf(\n                        \"application/x-www-form-urlencoded\"\n                    ) ===\n                        0\n            ) {\n                s.data = s.data.replace(r20, \"+\");\n            }\n\n            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n            if (s.ifModified) {\n                if (jQuery.lastModified[cacheURL]) {\n                    jqXHR.setRequestHeader(\n                        \"If-Modified-Since\",\n                        jQuery.lastModified[cacheURL]\n                    );\n                }\n                if (jQuery.etag[cacheURL]) {\n                    jqXHR.setRequestHeader(\n                        \"If-None-Match\",\n                        jQuery.etag[cacheURL]\n                    );\n                }\n            }\n\n            // Set the correct header, if data is being sent\n            if (\n                s.data && s.hasContent && s.contentType !== false ||\n                    options.contentType\n            ) {\n                jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n            }\n\n            // Set the Accepts header for the server, depending on the dataType\n            jqXHR.setRequestHeader(\n                \"Accept\",\n                s.dataTypes[0] && s.accepts[s.dataTypes[0]]\n                    ? s.accepts[s.dataTypes[0]] +\n                        (s.dataTypes[0] !== \"*\"\n                            ? \", \" + allTypes + \"; q=0.01\"\n                            : \"\")\n                    : s.accepts[\"*\"]\n            );\n\n            // Check for headers option\n            for (i in s.headers) {\n                jqXHR.setRequestHeader(i, s.headers[i]);\n            }\n\n            // Allow custom headers/mimetypes and early abort\n            if (\n                s.beforeSend &&\n                    (s.beforeSend.call(callbackContext, jqXHR, s) === false ||\n                        completed)\n            ) {\n                // Abort if not done already and return\n                return jqXHR.abort();\n            }\n\n            // Aborting is no longer a cancellation\n            strAbort = \"abort\";\n\n            // Install callbacks on deferreds\n            completeDeferred.add(s.complete);\n            jqXHR.done(s.success);\n            jqXHR.fail(s.error);\n\n            // Get transport\n            transport = inspectPrefiltersOrTransports(\n                transports,\n                s,\n                options,\n                jqXHR\n            );\n\n            // If no transport, we auto-abort\n            if (!transport) {\n                done(-1, \"No Transport\");\n            } else {\n                jqXHR.readyState = 1;\n\n                // Send global event\n                if (fireGlobals) {\n                    globalEventContext.trigger(\"ajaxSend\", [ jqXHR, s ]);\n                }\n\n                // If request was aborted inside ajaxSend, stop there\n                if (completed) {\n                    return jqXHR;\n                }\n\n                // Timeout\n                if (s.async && s.timeout > 0) {\n                    timeoutTimer = window.setTimeout(\n                        function() {\n                            jqXHR.abort(\"timeout\");\n                        },\n                        s.timeout\n                    );\n                }\n\n                try {\n                    completed = false;\n                    transport.send(requestHeaders, done);\n                } catch (e) {\n                    // Rethrow post-completion exceptions\n                    if (completed) {\n                        throw e;\n                    }\n\n                    // Propagate others as results\n                    done(-1, e);\n                }\n            }\n\n            // Callback for when everything is done\n            function done(status, nativeStatusText, responses, headers) {\n                var isSuccess,\n                    success,\n                    error,\n                    response,\n                    modified,\n                    statusText = nativeStatusText;\n\n                // Ignore repeat invocations\n                if (completed) {\n                    return;\n                }\n\n                completed = true;\n\n                // Clear timeout if it exists\n                if (timeoutTimer) {\n                    window.clearTimeout(timeoutTimer);\n                }\n\n                // Dereference transport for early garbage collection\n                // (no matter how long the jqXHR object will be used)\n                transport = undefined;\n\n                // Cache response headers\n                responseHeadersString = headers || \"\";\n\n                // Set readyState\n                jqXHR.readyState = status > 0 ? 4 : 0;\n\n                // Determine if successful\n                isSuccess = status >= 200 && status < 300 || status === 304;\n\n                // Get response data\n                if (responses) {\n                    response = ajaxHandleResponses(s, jqXHR, responses);\n                }\n\n                // Convert no matter what (that way responseXXX fields are always set)\n                response = ajaxConvert(s, response, jqXHR, isSuccess);\n\n                // If successful, handle type chaining\n                if (isSuccess) {\n                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n                    if (s.ifModified) {\n                        modified = jqXHR.getResponseHeader(\"Last-Modified\");\n                        if (modified) {\n                            jQuery.lastModified[cacheURL] = modified;\n                        }\n                        modified = jqXHR.getResponseHeader(\"etag\");\n                        if (modified) {\n                            jQuery.etag[cacheURL] = modified;\n                        }\n                    }\n\n                    // if no content\n                    if (status === 204 || s.type === \"HEAD\") {\n                        statusText = \"nocontent\";\n                        // if not modified\n                    } else if (status === 304) {\n                        statusText = \"notmodified\";\n                        // If we have data, let's convert it\n                    } else {\n                        statusText = response.state;\n                        success = response.data;\n                        error = response.error;\n                        isSuccess = !error;\n                    }\n                } else {\n                    // Extract error from statusText and normalize for non-aborts\n                    error = statusText;\n                    if (status || !statusText) {\n                        statusText = \"error\";\n                        if (status < 0) {\n                            status = 0;\n                        }\n                    }\n                }\n\n                // Set data for the fake xhr object\n                jqXHR.status = status;\n                jqXHR.statusText = (nativeStatusText || statusText) + \"\";\n\n                // Success/Error\n                if (isSuccess) {\n                    deferred.resolveWith(callbackContext, [\n                        success,\n                        statusText,\n                        jqXHR\n                    ]);\n                } else {\n                    deferred.rejectWith(callbackContext, [\n                        jqXHR,\n                        statusText,\n                        error\n                    ]);\n                }\n\n                // Status-dependent callbacks\n                jqXHR.statusCode(statusCode);\n                statusCode = undefined;\n\n                if (fireGlobals) {\n                    globalEventContext.trigger(\n                        isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n                        [ jqXHR, s, isSuccess ? success : error ]\n                    );\n                }\n\n                // Complete\n                completeDeferred.fireWith(callbackContext, [\n                    jqXHR,\n                    statusText\n                ]);\n\n                if (fireGlobals) {\n                    globalEventContext.trigger(\"ajaxComplete\", [ jqXHR, s ]);\n\n                    // Handle the global AJAX counter\n                    if (!--jQuery.active) {\n                        jQuery.event.trigger(\"ajaxStop\");\n                    }\n                }\n            }\n\n            return jqXHR;\n        },\n        getJSON: function(url, data, callback) {\n            return jQuery.get(url, data, callback, \"json\");\n        },\n        getScript: function(url, callback) {\n            return jQuery.get(url, undefined, callback, \"script\");\n        }\n    });\n\n    jQuery.each([ \"get\", \"post\" ], function(i, method) {\n        jQuery[method] = function(url, data, callback, type) {\n            // Shift arguments if data argument was omitted\n            if (jQuery.isFunction(data)) {\n                type = type || callback;\n                callback = data;\n                data = undefined;\n            }\n\n            // The url can be an options object (which then must have .url)\n            return jQuery.ajax(\n                jQuery.extend(\n                    {\n                        url: url,\n                        type: method,\n                        dataType: type,\n                        data: data,\n                        success: callback\n                    },\n                    jQuery.isPlainObject(url) && url\n                )\n            );\n        };\n    });\n\n    jQuery._evalUrl = function(url) {\n        return jQuery.ajax({\n            url: url,\n            // Make this explicit, since user can override this through ajaxSetup (#11264)\n            type: \"GET\",\n            dataType: \"script\",\n            cache: true,\n            async: false,\n            global: false,\n            throws: true\n        });\n    };\n\n    jQuery.fn.extend({\n        wrapAll: function(html) {\n            var wrap;\n\n            if (this[0]) {\n                if (jQuery.isFunction(html)) {\n                    html = html.call(this[0]);\n                }\n\n                // The elements to wrap the target around\n                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n                if (this[0].parentNode) {\n                    wrap.insertBefore(this[0]);\n                }\n\n                wrap.map(function() {\n                    var elem = this;\n\n                    while (elem.firstElementChild) {\n                        elem = elem.firstElementChild;\n                    }\n\n                    return elem;\n                }).append(this);\n            }\n\n            return this;\n        },\n        wrapInner: function(html) {\n            if (jQuery.isFunction(html)) {\n                return this.each(function(i) {\n                    jQuery(this).wrapInner(html.call(this, i));\n                });\n            }\n\n            return this.each(function() {\n                var self = jQuery(this), contents = self.contents();\n\n                if (contents.length) {\n                    contents.wrapAll(html);\n                } else {\n                    self.append(html);\n                }\n            });\n        },\n        wrap: function(html) {\n            var isFunction = jQuery.isFunction(html);\n\n            return this.each(function(i) {\n                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n            });\n        },\n        unwrap: function(selector) {\n            this.parent(selector).not(\"body\").each(function() {\n                jQuery(this).replaceWith(this.childNodes);\n            });\n            return this;\n        }\n    });\n\n    jQuery.expr.pseudos.hidden = function(elem) {\n        return !jQuery.expr.pseudos.visible(elem);\n    };\n    jQuery.expr.pseudos.visible = function(elem) {\n        return !!(elem.offsetWidth ||\n            elem.offsetHeight ||\n            elem.getClientRects().length);\n    };\n\n    jQuery.ajaxSettings.xhr = function() {\n        try {\n            return new window.XMLHttpRequest();\n        } catch (e) {\n        }\n    };\n\n    var xhrSuccessStatus = {\n        // File protocol always yields status code 0, assume 200\n        0: 200,\n        // Support: IE <=9 only\n        // #1450: sometimes IE returns 1223 when it should be 204\n        1223: 204\n    },\n        xhrSupported = jQuery.ajaxSettings.xhr();\n\n    support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n    support.ajax = xhrSupported = !!xhrSupported;\n\n    jQuery.ajaxTransport(function(options) {\n        var callback, errorCallback;\n\n        // Cross domain only allowed if supported through XMLHttpRequest\n        if (support.cors || xhrSupported && !options.crossDomain) {\n            return {\n                send: function(headers, complete) {\n                    var i, xhr = options.xhr();\n\n                    xhr.open(\n                        options.type,\n                        options.url,\n                        options.async,\n                        options.username,\n                        options.password\n                    );\n\n                    // Apply custom fields if provided\n                    if (options.xhrFields) {\n                        for (i in options.xhrFields) {\n                            xhr[i] = options.xhrFields[i];\n                        }\n                    }\n\n                    // Override mime type if needed\n                    if (options.mimeType && xhr.overrideMimeType) {\n                        xhr.overrideMimeType(options.mimeType);\n                    }\n\n                    // X-Requested-With header\n                    // For cross-domain requests, seeing as conditions for a preflight are\n                    // akin to a jigsaw puzzle, we simply never set it to be sure.\n                    // (it can always be set on a per-request basis or even using ajaxSetup)\n                    // For same-domain requests, won't change header if already provided.\n                    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n                        headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n                    }\n\n                    // Set headers\n                    for (i in headers) {\n                        xhr.setRequestHeader(i, headers[i]);\n                    }\n\n                    // Callback\n                    callback = function(type) {\n                        return function() {\n                            if (callback) {\n                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n                                if (type === \"abort\") {\n                                    xhr.abort();\n                                } else if (type === \"error\") {\n                                    // Support: IE <=9 only\n                                    // On a manual native abort, IE9 throws\n                                    // errors on any property access that is not readyState\n                                    if (typeof xhr.status !== \"number\") {\n                                        complete(0, \"error\");\n                                    } else {\n                                        complete(\n                                            // File: protocol always yields status 0; see #8605, #14207\n                                            xhr.status,\n                                            xhr.statusText\n                                        );\n                                    }\n                                } else {\n                                    complete(\n                                        xhrSuccessStatus[xhr.status] ||\n                                            xhr.status,\n                                        xhr.statusText,\n                                        // Support: IE <=9 only\n                                        // IE9 has no XHR2 but throws on binary (trac-11426)\n                                        // For XHR2 non-text, let the caller handle it (gh-2498)\n                                        (xhr.responseType || \"text\") !==\n                                            \"text\" ||\n                                            typeof xhr.responseText !== \"string\"\n                                            ? { binary: xhr.response }\n                                            : { text: xhr.responseText },\n                                        xhr.getAllResponseHeaders()\n                                    );\n                                }\n                            }\n                        };\n                    };\n\n                    // Listen to events\n                    xhr.onload = callback();\n                    errorCallback = xhr.onerror = callback(\"error\");\n\n                    // Support: IE 9 only\n                    // Use onreadystatechange to replace onabort\n                    // to handle uncaught aborts\n                    if (xhr.onabort !== undefined) {\n                        xhr.onabort = errorCallback;\n                    } else {\n                        xhr.onreadystatechange = function() {\n                            // Check readyState before timeout as it changes\n                            if (xhr.readyState === 4) {\n                                // Allow onerror to be called first,\n                                // but that will not handle a native abort\n                                // Also, save errorCallback to a variable\n                                // as xhr.onerror cannot be accessed\n                                window.setTimeout(function() {\n                                    if (callback) {\n                                        errorCallback();\n                                    }\n                                });\n                            }\n                        };\n                    }\n\n                    // Create the abort callback\n                    callback = callback(\"abort\");\n\n                    try {\n                        // Do send the request (this may raise an exception)\n                        xhr.send(options.hasContent && options.data || null);\n                    } catch (e) {\n                        // #14683: Only rethrow if this hasn't been notified as an error yet\n                        if (callback) {\n                            throw e;\n                        }\n                    }\n                },\n                abort: function() {\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n        }\n    });\n\n    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n    jQuery.ajaxPrefilter(function(s) {\n        if (s.crossDomain) {\n            s.contents.script = false;\n        }\n    });\n\n    // Install script dataType\n    jQuery.ajaxSetup({\n        accepts: {\n            script: \"text/javascript, application/javascript, \" +\n                \"application/ecmascript, application/x-ecmascript\"\n        },\n        contents: { script: /\\b(?:java|ecma)script\\b/ },\n        converters: {\n            \"text script\": function(text) {\n                jQuery.globalEval(text);\n                return text;\n            }\n        }\n    });\n\n    // Handle cache's special case and crossDomain\n    jQuery.ajaxPrefilter(\"script\", function(s) {\n        if (s.cache === undefined) {\n            s.cache = false;\n        }\n        if (s.crossDomain) {\n            s.type = \"GET\";\n        }\n    });\n\n    // Bind script tag hack transport\n    jQuery.ajaxTransport(\"script\", function(s) {\n        // This transport only deals with cross domain requests\n        if (s.crossDomain) {\n            var script, callback;\n            return {\n                send: function(_, complete) {\n                    script = jQuery(\"<script>\")\n                        .prop({ charset: s.scriptCharset, src: s.url })\n                        .on(\n                            \"load error\",\n                            callback = function(evt) {\n                                script.remove();\n                                callback = null;\n                                if (evt) {\n                                    complete(\n                                        evt.type === \"error\" ? 404 : 200,\n                                        evt.type\n                                    );\n                                }\n                            }\n                        );\n\n                    // Use native DOM manipulation to avoid our domManip AJAX trickery\n                    document.head.appendChild(script[0]);\n                },\n                abort: function() {\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n        }\n    });\n\n    var oldCallbacks = [], rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n    // Default jsonp settings\n    jQuery.ajaxSetup({\n        jsonp: \"callback\",\n        jsonpCallback: function() {\n            var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n            this[callback] = true;\n            return callback;\n        }\n    });\n\n    // Detect, normalize options and install callbacks for jsonp requests\n    jQuery.ajaxPrefilter(\"json jsonp\", function(s, originalSettings, jqXHR) {\n        var callbackName,\n            overwritten,\n            responseContainer,\n            jsonProp = s.jsonp !== false &&\n                (rjsonp.test(s.url)\n                    ? \"url\"\n                    : typeof s.data === \"string\" &&\n                        (s.contentType || \"\").indexOf(\n                            \"application/x-www-form-urlencoded\"\n                        ) ===\n                            0 &&\n                        rjsonp.test(s.data) &&\n                        \"data\");\n\n        // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n        if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n            // Get callback name, remembering preexisting value associated with it\n            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback)\n                ? s.jsonpCallback()\n                : s.jsonpCallback;\n\n            // Insert callback into url or form data\n            if (jsonProp) {\n                s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n            } else if (s.jsonp !== false) {\n                s.url += (rquery.test(s.url) ? \"&\" : \"?\") +\n                    s.jsonp +\n                    \"=\" +\n                    callbackName;\n            }\n\n            // Use data converter to retrieve json after script execution\n            s.converters[\"script json\"] = function() {\n                if (!responseContainer) {\n                    jQuery.error(callbackName + \" was not called\");\n                }\n                return responseContainer[0];\n            };\n\n            // Force json dataType\n            s.dataTypes[0] = \"json\";\n\n            // Install callback\n            overwritten = window[callbackName];\n            window[callbackName] = function() {\n                responseContainer = arguments;\n            };\n\n            // Clean-up function (fires after converters)\n            jqXHR.always(function() {\n                // If previous value didn't exist - remove it\n                if (overwritten === undefined) {\n                    jQuery(window).removeProp(callbackName);\n                    // Otherwise restore preexisting value\n                } else {\n                    window[callbackName] = overwritten;\n                }\n\n                // Save back as free\n                if (s[callbackName]) {\n                    // Make sure that re-using the options doesn't screw things around\n                    s.jsonpCallback = originalSettings.jsonpCallback;\n\n                    // Save the callback name for future use\n                    oldCallbacks.push(callbackName);\n                }\n\n                // Call if it was a function and we have a response\n                if (responseContainer && jQuery.isFunction(overwritten)) {\n                    overwritten(responseContainer[0]);\n                }\n\n                responseContainer = overwritten = undefined;\n            });\n\n            // Delegate to script\n            return \"script\";\n        }\n    });\n\n    // Support: Safari 8 only\n    // In Safari 8 documents created via document.implementation.createHTMLDocument\n    // collapse sibling forms: the second one becomes a child of the first one.\n    // Because of that, this security measure has to be disabled in Safari 8.\n    // https://bugs.webkit.org/show_bug.cgi?id=137337\n    support.createHTMLDocument = (function() {\n        var body = document.implementation.createHTMLDocument(\"\").body;\n        body.innerHTML = \"<form></form><form></form>\";\n        return body.childNodes.length === 2;\n    })();\n\n    // Argument \"data\" should be string of html\n    // context (optional): If specified, the fragment will be created in this context,\n    // defaults to document\n    // keepScripts (optional): If true, will include scripts passed in the html string\n    jQuery.parseHTML = function(data, context, keepScripts) {\n        if (typeof data !== \"string\") {\n            return [];\n        }\n        if (typeof context === \"boolean\") {\n            keepScripts = context;\n            context = false;\n        }\n\n        var base, parsed, scripts;\n\n        if (!context) {\n            // Stop scripts or inline event handlers from being executed immediately\n            // by using document.implementation\n            if (support.createHTMLDocument) {\n                context = document.implementation.createHTMLDocument(\"\");\n\n                // Set the base href for the created document\n                // so any parsed elements with URLs\n                // are based on the document's URL (gh-2965)\n                base = context.createElement(\"base\");\n                base.href = document.location.href;\n                context.head.appendChild(base);\n            } else {\n                context = document;\n            }\n        }\n\n        parsed = rsingleTag.exec(data);\n        scripts = !keepScripts && [];\n\n        // Single tag\n        if (parsed) {\n            return [ context.createElement(parsed[1]) ];\n        }\n\n        parsed = buildFragment([ data ], context, scripts);\n\n        if (scripts && scripts.length) {\n            jQuery(scripts).remove();\n        }\n\n        return jQuery.merge([], parsed.childNodes);\n    };\n\n    /**\n * Load a url into a page\n */\n    jQuery.fn.load = function(url, params, callback) {\n        var selector, type, response, self = this, off = url.indexOf(\" \");\n\n        if (off > -1) {\n            selector = stripAndCollapse(url.slice(off));\n            url = url.slice(0, off);\n        }\n\n        // If it's a function\n        if (jQuery.isFunction(params)) {\n            // We assume that it's the callback\n            callback = params;\n            params = undefined;\n            // Otherwise, build a param string\n        } else if (params && typeof params === \"object\") {\n            type = \"POST\";\n        }\n\n        // If we have elements to modify, make the request\n        if (self.length > 0) {\n            jQuery.ajax({\n                url: url,\n                // If \"type\" variable is undefined, then \"GET\" method will be used.\n                // Make value of this field explicit since\n                // user can override it through ajaxSetup method\n                type: type || \"GET\",\n                dataType: \"html\",\n                data: params\n            }).done(function(responseText) {\n                // Save response for use in complete callback\n                response = arguments;\n\n                self.html(\n                    selector\n                        ? // If a selector was specified, locate the right elements in a dummy div\n                        // Exclude scripts to avoid IE 'Permission Denied' errors\n                        jQuery(\"<div>\")\n                            .append(jQuery.parseHTML(responseText))\n                            .find(selector)\n                        : // Otherwise use the full result\n                        responseText\n                );\n                // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n                // but they are ignored because response was set above.\n                // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n            }).always(\n                callback && function(jqXHR, status) {\n                        self.each(function() {\n                            callback.apply(\n                                this,\n                                response ||\n                                    [ jqXHR.responseText, status, jqXHR ]\n                            );\n                        });\n                    }\n            );\n        }\n\n        return this;\n    };\n\n    // Attach a bunch of functions for handling common AJAX events\n    jQuery.each(\n        [\n            \"ajaxStart\",\n            \"ajaxStop\",\n            \"ajaxComplete\",\n            \"ajaxError\",\n            \"ajaxSuccess\",\n            \"ajaxSend\"\n        ],\n        function(i, type) {\n            jQuery.fn[type] = function(fn) {\n                return this.on(type, fn);\n            };\n        }\n    );\n\n    jQuery.expr.pseudos.animated = function(elem) {\n        return jQuery.grep(jQuery.timers, function(fn) {\n            return elem === fn.elem;\n        }).length;\n    };\n\n    /**\n * Gets a window from an element\n */\n    function getWindow(elem) {\n        return jQuery.isWindow(elem)\n            ? elem\n            : elem.nodeType === 9 && elem.defaultView;\n    }\n\n    jQuery.offset = {\n        setOffset: function(elem, options, i) {\n            var curPosition,\n                curLeft,\n                curCSSTop,\n                curTop,\n                curOffset,\n                curCSSLeft,\n                calculatePosition,\n                position = jQuery.css(elem, \"position\"),\n                curElem = jQuery(elem),\n                props = {};\n\n            // Set position first, in-case top/left are set even on static elem\n            if (position === \"static\") {\n                elem.style.position = \"relative\";\n            }\n\n            curOffset = curElem.offset();\n            curCSSTop = jQuery.css(elem, \"top\");\n            curCSSLeft = jQuery.css(elem, \"left\");\n            calculatePosition = (position === \"absolute\" ||\n                position === \"fixed\") &&\n                (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\n\n            // Need to be able to calculate position if either\n            // top or left is auto and position is either absolute or fixed\n            if (calculatePosition) {\n                curPosition = curElem.position();\n                curTop = curPosition.top;\n                curLeft = curPosition.left;\n            } else {\n                curTop = parseFloat(curCSSTop) || 0;\n                curLeft = parseFloat(curCSSLeft) || 0;\n            }\n\n            if (jQuery.isFunction(options)) {\n                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n                options = options.call(elem, i, jQuery.extend({}, curOffset));\n            }\n\n            if (options.top != null) {\n                props.top = options.top - curOffset.top + curTop;\n            }\n            if (options.left != null) {\n                props.left = options.left - curOffset.left + curLeft;\n            }\n\n            if (\"using\" in options) {\n                options.using.call(elem, props);\n            } else {\n                curElem.css(props);\n            }\n        }\n    };\n\n    jQuery.fn.extend({\n        offset: function(options) {\n            // Preserve chaining for setter\n            if (arguments.length) {\n                return options === undefined ? this : this.each(function(i) {\n                        jQuery.offset.setOffset(this, options, i);\n                    });\n            }\n\n            var docElem, win, rect, doc, elem = this[0];\n\n            if (!elem) {\n                return;\n            }\n\n            // Support: IE <=11 only\n            // Running getBoundingClientRect on a\n            // disconnected node in IE throws an error\n            if (!elem.getClientRects().length) {\n                return { top: 0, left: 0 };\n            }\n\n            rect = elem.getBoundingClientRect();\n\n            // Make sure element is not hidden (display: none)\n            if (rect.width || rect.height) {\n                doc = elem.ownerDocument;\n                win = getWindow(doc);\n                docElem = doc.documentElement;\n\n                return {\n                    top: rect.top + win.pageYOffset - docElem.clientTop,\n                    left: rect.left + win.pageXOffset - docElem.clientLeft\n                };\n            }\n\n            // Return zeros for disconnected and hidden elements (gh-2310)\n            return rect;\n        },\n        position: function() {\n            if (!this[0]) {\n                return;\n            }\n\n            var offsetParent,\n                offset,\n                elem = this[0],\n                parentOffset = { top: 0, left: 0 };\n\n            // Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n            // because it is its only offset parent\n            if (jQuery.css(elem, \"position\") === \"fixed\") {\n                // Assume getBoundingClientRect is there when computed position is fixed\n                offset = elem.getBoundingClientRect();\n            } else {\n                // Get *real* offsetParent\n                offsetParent = this.offsetParent();\n\n                // Get correct offsets\n                offset = this.offset();\n                if (!jQuery.nodeName(offsetParent[0], \"html\")) {\n                    parentOffset = offsetParent.offset();\n                }\n\n                // Add offsetParent borders\n                parentOffset = {\n                    top: parentOffset.top +\n                        jQuery.css(offsetParent[0], \"borderTopWidth\", true),\n                    left: parentOffset.left +\n                        jQuery.css(offsetParent[0], \"borderLeftWidth\", true)\n                };\n            }\n\n            // Subtract parent offsets and element margins\n            return {\n                top: offset.top -\n                    parentOffset.top -\n                    jQuery.css(elem, \"marginTop\", true),\n                left: offset.left -\n                    parentOffset.left -\n                    jQuery.css(elem, \"marginLeft\", true)\n            };\n        },\n        // This method will return documentElement in the following cases:\n        // 1) For the element inside the iframe without offsetParent, this method will return\n        //    documentElement of the parent window\n        // 2) For the hidden or detached element\n        // 3) For body or html element, i.e. in case of the html node - it will return itself\n        //\n        // but those exceptions were never presented as a real life use-cases\n        // and might be considered as more preferable results.\n        //\n        // This logic, however, is not guaranteed and can change at any point in the future\n        offsetParent: function() {\n            return this.map(function() {\n                var offsetParent = this.offsetParent;\n\n                while (\n                    offsetParent &&\n                        jQuery.css(offsetParent, \"position\") === \"static\"\n                ) {\n                    offsetParent = offsetParent.offsetParent;\n                }\n\n                return offsetParent || documentElement;\n            });\n        }\n    });\n\n    // Create scrollLeft and scrollTop methods\n    jQuery.each(\n        { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" },\n        function(method, prop) {\n            var top = \"pageYOffset\" === prop;\n\n            jQuery.fn[method] = function(val) {\n                return access(\n                    this,\n                    function(elem, method, val) {\n                        var win = getWindow(elem);\n\n                        if (val === undefined) {\n                            return win ? win[prop] : elem[method];\n                        }\n\n                        if (win) {\n                            win.scrollTo(\n                                !top ? val : win.pageXOffset,\n                                top ? val : win.pageYOffset\n                            );\n                        } else {\n                            elem[method] = val;\n                        }\n                    },\n                    method,\n                    val,\n                    arguments.length\n                );\n            };\n        }\n    );\n\n    // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n    // Add the top/left cssHooks using jQuery.fn.position\n    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n    // getComputedStyle returns percent when specified for top/left/bottom/right;\n    // rather than make the css module depend on the offset module, just check for it here\n    jQuery.each([ \"top\", \"left\" ], function(i, prop) {\n        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(\n            elem,\n            computed\n        ) {\n            if (computed) {\n                computed = curCSS(elem, prop);\n\n                // If curCSS returns percentage, fallback to offset\n                return rnumnonpx.test(computed)\n                    ? jQuery(elem).position()[prop] + \"px\"\n                    : computed;\n            }\n        });\n    });\n\n    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n    jQuery.each({ Height: \"height\", Width: \"width\" }, function(name, type) {\n        jQuery.each(\n            { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n            function(defaultExtra, funcName) {\n                // Margin is only for outerHeight, outerWidth\n                jQuery.fn[funcName] = function(margin, value) {\n                    var chainable = arguments.length &&\n                        (defaultExtra || typeof margin !== \"boolean\"),\n                        extra = defaultExtra ||\n                            (margin === true || value === true\n                                ? \"margin\"\n                                : \"border\");\n\n                    return access(\n                        this,\n                        function(elem, type, value) {\n                            var doc;\n\n                            if (jQuery.isWindow(elem)) {\n                                // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n                                return funcName.indexOf(\"outer\") === 0\n                                    ? elem[\"inner\" + name]\n                                    : elem.document.documentElement[\"client\" +\n                                        name];\n                            }\n\n                            // Get document width or height\n                            if (elem.nodeType === 9) {\n                                doc = elem.documentElement;\n\n                                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n                                // whichever is greatest\n                                return Math.max(\n                                    elem.body[\"scroll\" + name],\n                                    doc[\"scroll\" + name],\n                                    elem.body[\"offset\" + name],\n                                    doc[\"offset\" + name],\n                                    doc[\"client\" + name]\n                                );\n                            }\n\n                            return value === undefined\n                                ? // Get width or height on the element, requesting but not forcing parseFloat\n                                jQuery.css(elem, type, extra)\n                                : // Set width or height on the element\n                                jQuery.style(elem, type, value, extra);\n                        },\n                        type,\n                        chainable ? margin : undefined,\n                        chainable\n                    );\n                };\n            }\n        );\n    });\n\n    jQuery.fn.extend({\n        bind: function(types, data, fn) {\n            return this.on(types, null, data, fn);\n        },\n        unbind: function(types, fn) {\n            return this.off(types, null, fn);\n        },\n        delegate: function(selector, types, data, fn) {\n            return this.on(types, selector, data, fn);\n        },\n        undelegate: function(selector, types, fn) {\n            // ( namespace ) or ( selector, types [, fn] )\n            return arguments.length === 1\n                ? this.off(selector, \"**\")\n                : this.off(types, selector || \"**\", fn);\n        }\n    });\n\n    jQuery.parseJSON = JSON.parse;\n\n    // Register as a named AMD module, since jQuery can be concatenated with other\n    // files that may use define, but not via a proper concatenation script that\n    // understands anonymous AMD modules. A named AMD is safest and most robust\n    // way to register. Lowercase jquery is used because AMD module names are\n    // derived from file names, and jQuery is normally delivered in a lowercase\n    // file name. Do this after creating the global so that if an AMD module wants\n    // to call noConflict to hide this version of jQuery, it will work.\n    // Note that for maximum portability, libraries that are not jQuery should\n    // declare themselves as anonymous modules, and avoid setting a global if an\n    // AMD loader is present. jQuery is a special case. For more information, see\n    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n            return jQuery;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n\n    var // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n        // Map over the $ in case of overwrite\n        _$ = window.$;\n\n    jQuery.noConflict = function(deep) {\n        if (window.$ === jQuery) {\n            window.$ = _$;\n        }\n\n        if (deep && window.jQuery === jQuery) {\n            window.jQuery = _jQuery;\n        }\n\n        return jQuery;\n    };\n\n    // Expose jQuery and $ identifiers, even in AMD\n    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n    // and CommonJS for browser emulators (#13566)\n    if (!noGlobal) {\n        window.jQuery = window.$ = jQuery;\n    }\n\n    return jQuery;\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9DOi9Vc2Vycy9EYW5nby9sZWFybi9vYm9sb24vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanM/N2Q5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMS4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDktMjJUMjI6MzBaXG4gKi9cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuICAgICAgICAvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuICAgICAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuICAgICAgICAvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cbiAgICAgICAgLy8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cbiAgICAgICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuICAgICAgICAvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudFxuICAgICAgICAgICAgPyBmYWN0b3J5KGdsb2JhbCwgdHJ1ZSlcbiAgICAgICAgICAgIDogKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXcuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnkodyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGdsb2JhbCk7XG4gICAgfVxuICAgIC8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24od2luZG93LCBub0dsb2JhbCkge1xuICAgIC8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuICAgIC8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuICAgIC8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4gICAgLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gICAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG4gICAgdmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG4gICAgdmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbiAgICB2YXIgcHVzaCA9IGFyci5wdXNoO1xuXG4gICAgdmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxuICAgIHZhciBjbGFzczJ0eXBlID0ge307XG5cbiAgICB2YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICB2YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxuICAgIHZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgdmFyIHN1cHBvcnQgPSB7fTtcblxuICAgIGZ1bmN0aW9uIERPTUV2YWwoY29kZSwgZG9jKSB7XG4gICAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cbiAgICAgICAgc2NyaXB0LnRleHQgPSBjb2RlO1xuICAgICAgICBkb2MuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICB9XG4gICAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICAgIC8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4gICAgLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcbiAgICB2YXIgdmVyc2lvbiA9IFwiMy4xLjFcIixcbiAgICAgICAgLy8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcbiAgICAgICAgalF1ZXJ5ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuICAgICAgICAgICAgLy8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG4gICAgICAgIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuICAgICAgICAvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbiAgICAgICAgcm1zUHJlZml4ID0gL14tbXMtLyxcbiAgICAgICAgcmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuICAgICAgICAvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG4gICAgICAgIGZjYW1lbENhc2UgPSBmdW5jdGlvbihhbGwsIGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9O1xuXG4gICAgalF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuICAgICAgICBqcXVlcnk6IHZlcnNpb24sXG4gICAgICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcbiAgICAgICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChudW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG4gICAgICAgICAgICByZXR1cm4gbnVtIDwgMCA/IHRoaXNbbnVtICsgdGhpcy5sZW5ndGhdIDogdGhpc1tudW1dO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG4gICAgICAgIC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuICAgICAgICBwdXNoU3RhY2s6IGZ1bmN0aW9uKGVsZW1zKSB7XG4gICAgICAgICAgICAvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuICAgICAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcbiAgICAgICAgICAgIHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmVhY2godGhpcywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBtYXA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbihlbGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGVsZW0sIGksIGVsZW0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKDApO1xuICAgICAgICB9LFxuICAgICAgICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXE6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCwgaiA9ICtpICsgKGkgPCAwID8gbGVuIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbal0gXSA6IFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICAgIC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuICAgICAgICBwdXNoOiBwdXNoLFxuICAgICAgICBzb3J0OiBhcnIuc29ydCxcbiAgICAgICAgc3BsaWNlOiBhcnIuc3BsaWNlXG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICBjb3B5SXNBcnJheSxcbiAgICAgICAgICAgIGNsb25lLFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV0gfHwge307XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZXAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29weUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGpRdWVyeS5leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvcHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICAvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcbiAgICAgICAgZXhwYW5kbzogXCJqUXVlcnlcIiArICh2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxuICAgICAgICAvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuICAgICAgICBpc1JlYWR5OiB0cnVlLFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfSxcbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgaXNXaW5kb3c6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcbiAgICAgICAgfSxcbiAgICAgICAgaXNOdW1lcmljOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG4gICAgICAgICAgICAvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG4gICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuICAgICAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZShvYmopO1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIpICYmXG4gICAgICAgICAgICAgICAgLy8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG4gICAgICAgICAgICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuICAgICAgICAgICAgICAgICFpc05hTihvYmogLSBwYXJzZUZsb2F0KG9iaikpO1xuICAgICAgICB9LFxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBwcm90bywgQ3RvcjtcblxuICAgICAgICAgICAgLy8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG4gICAgICAgICAgICAvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcbiAgICAgICAgICAgIGlmICghb2JqIHx8IHRvU3RyaW5nLmNhbGwob2JqKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG8gPSBnZXRQcm90byhvYmopO1xuXG4gICAgICAgICAgICAvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG4gICAgICAgICAgICBpZiAoIXByb3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG4gICAgICAgICAgICBDdG9yID0gaGFzT3duLmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGZuVG9TdHJpbmcuY2FsbChDdG9yKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuICAgICAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICsgXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuICAgICAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgICAgICBET01FdmFsKGNvZGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcbiAgICAgICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuICAgICAgICBjYW1lbENhc2U6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJtc1ByZWZpeCwgXCJtcy1cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShyZGFzaEFscGhhLCBmY2FtZWxDYXNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZU5hbWU6IGZ1bmN0aW9uKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmXG4gICAgICAgICAgICAgICAgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIGkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4gICAgICAgIHRyaW06IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyBcIlwiIDogKHRleHQgKyBcIlwiKS5yZXBsYWNlKHJ0cmltLCBcIlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKGFyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChhcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZShPYmplY3QoYXJyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHJldCwgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/IFsgYXJyIF0gOiBhcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChyZXQsIGFycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICBpbkFycmF5OiBmdW5jdGlvbihlbGVtLCBhcnIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKGFyciwgZWxlbSwgaSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgIG1lcmdlOiBmdW5jdGlvbihmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsIGogPSAwLCBpID0gZmlyc3QubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RbaSsrXSA9IHNlY29uZFtqXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3QubGVuZ3RoID0gaTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICB9LFxuICAgICAgICBncmVwOiBmdW5jdGlvbihlbGVtcywgY2FsbGJhY2ssIGludmVydCkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrSW52ZXJzZSxcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuICAgICAgICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soZWxlbXNbaV0sIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbGVtc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICAgIG1hcDogZnVuY3Rpb24oZWxlbXMsIGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIHZhbHVlLCBpID0gMCwgcmV0ID0gW107XG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG4gICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UoZWxlbXMpKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBlbGVtcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1zW2ldLCBpLCBhcmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIHJldCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuICAgICAgICBndWlkOiAxLFxuICAgICAgICAvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbiAgICAgICAgLy8gYXJndW1lbnRzLlxuICAgICAgICBwcm94eTogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBmbltjb250ZXh0XTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZm47XG4gICAgICAgICAgICAgICAgZm4gPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG4gICAgICAgICAgICAvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgaWYgKCFqUXVlcnkuaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaW11bGF0ZWQgYmluZFxuICAgICAgICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHByb3h5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0IHx8IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgICAgICAgICBwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuICAgICAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgICB9LFxuICAgICAgICBub3c6IERhdGUubm93LFxuICAgICAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cbiAgICAgICAgc3VwcG9ydDogc3VwcG9ydFxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBqUXVlcnkuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IGFycltTeW1ib2wuaXRlcmF0b3JdO1xuICAgIH1cblxuICAgIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICAgIGpRdWVyeS5lYWNoKFxuICAgICAgICBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoXG4gICAgICAgICAgICBcIiBcIlxuICAgICAgICApLFxuICAgICAgICBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgICAgICAgICBjbGFzczJ0eXBlW1wiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIl0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XG4gICAgICAgIC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcbiAgICAgICAgLy8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuICAgICAgICAvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcbiAgICAgICAgLy8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuICAgICAgICB2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGUgPSBqUXVlcnkudHlwZShvYmopO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHxcbiAgICAgICAgICAgIGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmIGxlbmd0aCAtIDEgaW4gb2JqO1xuICAgIH1cbiAgICB2YXIgU2l6emxlID0gLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbiAgICAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgc3VwcG9ydCxcbiAgICAgICAgICAgIEV4cHIsXG4gICAgICAgICAgICBnZXRUZXh0LFxuICAgICAgICAgICAgaXNYTUwsXG4gICAgICAgICAgICB0b2tlbml6ZSxcbiAgICAgICAgICAgIGNvbXBpbGUsXG4gICAgICAgICAgICBzZWxlY3QsXG4gICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgICAgc29ydElucHV0LFxuICAgICAgICAgICAgaGFzRHVwbGljYXRlLFxuICAgICAgICAgICAgLy8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuICAgICAgICAgICAgc2V0RG9jdW1lbnQsXG4gICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgIGRvY0VsZW0sXG4gICAgICAgICAgICBkb2N1bWVudElzSFRNTCxcbiAgICAgICAgICAgIHJidWdneVFTQSxcbiAgICAgICAgICAgIHJidWdneU1hdGNoZXMsXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgY29udGFpbnMsXG4gICAgICAgICAgICAvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG4gICAgICAgICAgICBleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgcHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICAgICAgZGlycnVucyA9IDAsXG4gICAgICAgICAgICBkb25lID0gMCxcbiAgICAgICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgdG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICBjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBJbnN0YW5jZSBtZXRob2RzXG4gICAgICAgICAgICBoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgYXJyID0gW10sXG4gICAgICAgICAgICBwb3AgPSBhcnIucG9wLFxuICAgICAgICAgICAgcHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcbiAgICAgICAgICAgIHB1c2ggPSBhcnIucHVzaCxcbiAgICAgICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxuICAgICAgICAgICAgLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG4gICAgICAgICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG4gICAgICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24obGlzdCwgZWxlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuICAgICAgICAgICAgLy8gUmVndWxhciBleHByZXNzaW9uc1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2VcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgK1xuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgIFwiKihcIiArXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciArXG4gICAgICAgICAgICAgICAgXCIpKD86XCIgK1xuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgIC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG4gICAgICAgICAgICAgICAgXCIqKFsqXiR8IX5dPz0pXCIgK1xuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgIC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG4gICAgICAgICAgICAgICAgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciArXG4gICAgICAgICAgICAgICAgXCIpKXwpXCIgK1xuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgIFwiKlxcXFxdXCIsXG4gICAgICAgICAgICBwc2V1ZG9zID0gXCI6KFwiICtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyICtcbiAgICAgICAgICAgICAgICBcIikoPzpcXFxcKChcIiArXG4gICAgICAgICAgICAgICAgLy8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcbiAgICAgICAgICAgICAgICBcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcbiAgICAgICAgICAgICAgICAvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcbiAgICAgICAgICAgICAgICBcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyArXG4gICAgICAgICAgICAgICAgXCIpKil8XCIgK1xuICAgICAgICAgICAgICAgIC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcbiAgICAgICAgICAgICAgICBcIi4qXCIgK1xuICAgICAgICAgICAgICAgIFwiKVxcXFwpfClcIixcbiAgICAgICAgICAgIC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcbiAgICAgICAgICAgIHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCh3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiKSxcbiAgICAgICAgICAgIHJ0cmltID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICBcIl5cIiArXG4gICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgK1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgXCIrJFwiLFxuICAgICAgICAgICAgICAgIFwiZ1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcmNvbW1hID0gbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIpLFxuICAgICAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICBcIl5cIiArXG4gICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICBcIiooWz4rfl18XCIgK1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgXCIpXCIgK1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgXCIqXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICByYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG4gICAgICAgICAgICAgICAgXCJnXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBycHNldWRvID0gbmV3IFJlZ0V4cChwc2V1ZG9zKSxcbiAgICAgICAgICAgIHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiksXG4gICAgICAgICAgICBtYXRjaEV4cHIgPSB7XG4gICAgICAgICAgICAgICAgSUQ6IG5ldyBSZWdFeHAoXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgQ0xBU1M6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgICAgICAgICAgIFRBRzogbmV3IFJlZ0V4cChcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiKSxcbiAgICAgICAgICAgICAgICBBVFRSOiBuZXcgUmVnRXhwKFwiXlwiICsgYXR0cmlidXRlcyksXG4gICAgICAgICAgICAgICAgUFNFVURPOiBuZXcgUmVnRXhwKFwiXlwiICsgcHNldWRvcyksXG4gICAgICAgICAgICAgICAgQ0hJTEQ6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiooPzooWystXXwpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiooXFxcXGQrKXwpKVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIqXFxcXCl8KVwiLFxuICAgICAgICAgICAgICAgICAgICBcImlcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYm9vbDogbmV3IFJlZ0V4cChcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiksXG4gICAgICAgICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuICAgICAgICAgICAgICAgIG5lZWRzQ29udGV4dDogbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgXCJeXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIipcXFxcKXwpKD89W14tXXwkKVwiLFxuICAgICAgICAgICAgICAgICAgICBcImlcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgICAgICAgIHJoZWFkZXIgPSAvXmhcXGQkL2ksXG4gICAgICAgICAgICBybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcbiAgICAgICAgICAgIC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuICAgICAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuICAgICAgICAgICAgcnNpYmxpbmcgPSAvWyt+XS8sXG4gICAgICAgICAgICAvLyBDU1MgZXNjYXBlc1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuICAgICAgICAgICAgcnVuZXNjYXBlID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsXG4gICAgICAgICAgICAgICAgXCJpZ1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24oXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveDwyNFxuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuICAgICAgICAgICAgICAgIHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgID8gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICA6IGhpZ2ggPCAwID8gLy8gQk1QIGNvZGVwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoICsgMHgxMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgKSA6IC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoID4+IDEwIHwgMHhEODAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2ggJiAweDNGRiB8IDB4REMwMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG4gICAgICAgICAgICByY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG4gICAgICAgICAgICBmY3NzZXNjYXBlID0gZnVuY3Rpb24oY2gsIGFzQ29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFzQ29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IFwiXFwwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaC5zbGljZSgwLCAtMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXFxcXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2guY2hhckNvZGVBdChjaC5sZW5ndGggLSAxKS50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIGNoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFVzZWQgZm9yIGlmcmFtZXNcbiAgICAgICAgICAgIC8vIFNlZSBzZXREb2N1bWVudCgpXG4gICAgICAgICAgICAvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcbiAgICAgICAgICAgIC8vIGVycm9yIGluIElFXG4gICAgICAgICAgICB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHVzaC5hcHBseShcbiAgICAgICAgICAgICAgICBhcnIgPSBzbGljZS5jYWxsKHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKSxcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG4gICAgICAgICAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG4gICAgICAgICAgICBhcnJbcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcHVzaCA9IHtcbiAgICAgICAgICAgICAgICBhcHBseTogLy8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggPyAoZnVuY3Rpb24odGFyZ2V0LCBlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hfbmF0aXZlLmFwcGx5KHRhcmdldCwgc2xpY2UuY2FsbChlbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkgOiAoZnVuY3Rpb24odGFyZ2V0LCBlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqID0gdGFyZ2V0Lmxlbmd0aCwgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XG4gICAgICAgICAgICB2YXIgbSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgbmlkLFxuICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgIXNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcbiAgICAgICAgICAgIGlmICghc2VlZCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJlZmVycmVkRG9jKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoc2VsZWN0b3IpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElEIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobSA9IG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uaWQgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMoY29udGV4dCwgZWxlbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlkID09PSBtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobSA9IG1hdGNoWzNdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0LnFzYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KHNlbGVjdG9yKSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pZCA9IG5pZC5yZXBsYWNlKHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgbmlkID0gZXhwYW5kbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzID0gdG9rZW5pemUoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2ldID0gXCIjXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmlkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU2VsZWN0b3IoZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcIixcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbChuZXdTZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAocXNhRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmlkID09PSBleHBhbmRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGwgb3RoZXJzXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0KFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICAgIHNlZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2FjaGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG4gICAgICAgICAgICAgICAgaWYgKGtleXMucHVzaChrZXkgKyBcIiBcIikgPiBFeHByLmNhY2hlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5cy5zaGlmdCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleSArIFwiIFwiXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuICAgICAgICBmdW5jdGlvbiBtYXJrRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIGZuW2V4cGFuZG9dID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuICAgICAgICBmdW5jdGlvbiBhc3NlcnQoZm4pIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFmbihlbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcbiAgICAgICAgICAgICAgICBlbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG4gICAgICAgIGZ1bmN0aW9uIGFkZEhhbmRsZShhdHRycywgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSwgaSA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBFeHByLmF0dHJIYW5kbGVbYXJyW2ldXSA9IGhhbmRsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuICAgICAgICBmdW5jdGlvbiBzaWJsaW5nQ2hlY2soYSwgYikge1xuICAgICAgICAgICAgdmFyIGN1ciA9IGIgJiYgYSxcbiAgICAgICAgICAgICAgICBkaWZmID0gY3VyICYmXG4gICAgICAgICAgICAgICAgICAgIGEubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgYi5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuICAgICAgICAgICAgLy8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciA9PT0gYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuICAgICAgICAgICAgICAgIGlmIChcImZvcm1cIiBpbiBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcbiAgICAgICAgICAgICAgICAgICAgLy8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJsYWJlbFwiIGluIGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gMTFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IC1XMDE4ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRBbmNlc3RvcihlbGVtKSA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJsYWJlbFwiIGluIGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSArYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbihzZWVkLCBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzID0gZm4oW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWRbaiA9IG1hdGNoSW5kZXhlc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbiAgICAgICAgZnVuY3Rpb24gdGVzdENvbnRleHQoY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuICAgICAgICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuICAgICAgICAvKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG4gICAgICAgIGlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgICAgICAgICAgLy8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJlxuICAgICAgICAgICAgICAgIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudFxuICAgICAgICAgICAgICAgID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIlxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbiAgICAgICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgaGFzQ29tcGFyZSxcbiAgICAgICAgICAgICAgICBzdWJXaW5kb3csXG4gICAgICAgICAgICAgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG4gICAgICAgICAgICBkb2N1bWVudCA9IGRvYztcbiAgICAgICAgICAgIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICBkb2N1bWVudElzSFRNTCA9ICFpc1hNTChkb2N1bWVudCk7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2VcbiAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiZcbiAgICAgICAgICAgICAgICAgICAgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuICAgICAgICAgICAgICAgIGlmIChzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJXaW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViV2luZG93LmF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG4gICAgICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBcImlcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcbiAgICAgICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDEwXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcbiAgICAgICAgICAgIC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuICAgICAgICAgICAgLy8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG4gICAgICAgICAgICBzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5pZCA9IGV4cGFuZG87XG4gICAgICAgICAgICAgICAgcmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoZXhwYW5kbykubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElEIGZpbHRlciBhbmQgZmluZFxuICAgICAgICAgICAgaWYgKHN1cHBvcnQuZ2V0QnlJZCkge1xuICAgICAgICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbihpZCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG4gICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oaWQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudElzSFRNTFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBpLCBlbGVtcywgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGVsZW0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtID0gZWxlbXNbaSsrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBlbGVtIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhZ1xuICAgICAgICAgICAgRXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZVxuICAgICAgICAgICAgICAgID8gKGZ1bmN0aW9uKHRhZywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnFzYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IChmdW5jdGlvbih0YWcsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbSA9IHJlc3VsdHNbaSsrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2xhc3NcbiAgICAgICAgICAgIEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oY2xhc3NOYW1lLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudElzSFRNTFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICAgICAgLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuICAgICAgICAgICAgLy8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcbiAgICAgICAgICAgIHJidWdneU1hdGNoZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcbiAgICAgICAgICAgIC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuICAgICAgICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuICAgICAgICAgICAgLy8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3JcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcbiAgICAgICAgICAgIHJidWdneVFTQSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBRU0EgcmVnZXhcbiAgICAgICAgICAgICAgICAvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcbiAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kbyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPHNlbGVjdCBpZD0nXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kbyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpbnB1dCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5LTExK1xuICAgICAgICAgICAgICAgICAgICAvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcbiAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKGVsLCBcIipcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuY2FsbChlbCwgXCJbcyE9JyddOnhcIik7XG4gICAgICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMucHVzaChcIiE9XCIsIHBzZXVkb3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpKTtcbiAgICAgICAgICAgIHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAocmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSk7XG5cbiAgICAgICAgICAgIC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgICAgIGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbik7XG5cbiAgICAgICAgICAgIC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuICAgICAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG4gICAgICAgICAgICAvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuICAgICAgICAgICAgY29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbnRhaW5zKVxuICAgICAgICAgICAgICAgID8gKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhIShidXAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXAubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWRvd24uY29udGFpbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhZG93bi5jb250YWlucyhidXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihidXApICYgMTYpKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiID0gYi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgICAgICAvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG4gICAgICAgICAgICBzb3J0T3JkZXIgPSBoYXNDb21wYXJlID8gKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlID0gKGEub3duZXJEb2N1bWVudCB8fCBhKSA9PT0gKGIub3duZXJEb2N1bWVudCB8fCBiKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXNjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSAmIDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKSA9PT0gY29tcGFyZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPT09IGRvY3VtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYilcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZihzb3J0SW5wdXQsIGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIH0pIDogKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVwID0gYS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXAgPSBbIGEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJwID0gWyBiIF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXAgfHwgIWJ1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJ1cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc29ydElucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4T2Yoc29ydElucHV0LCBiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1cCA9PT0gYnVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZ0NoZWNrKGEsIGIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAgY3VyID0gYTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcC51bnNoaWZ0KGN1cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyID0gYjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicC51bnNoaWZ0KGN1cik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYXBbaV0gPT09IGJwW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBbaV0gPT09IHByZWZlcnJlZERvY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oZXhwciwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihlbGVtLCBleHByKSB7XG4gICAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcbiAgICAgICAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UocmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIik7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJlxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudElzSFRNTCAmJlxuICAgICAgICAgICAgICAgICAgICAhY29tcGlsZXJDYWNoZVtleHByICsgXCIgXCJdICYmXG4gICAgICAgICAgICAgICAgICAgICghcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KGV4cHIpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoZXhwcikpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKGVsZW0sIGV4cHIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTFcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0pLmxlbmd0aCA+IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oY29udGV4dCwgZWxlbSkge1xuICAgICAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoKGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0KSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZXREb2N1bWVudChjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250YWlucyhjb250ZXh0LCBlbGVtKTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lLnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuICAgICAgICAgICAgICAgIHZhbCA9IGZuICYmIGhhc093bi5jYWxsKEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICA/IGZuKGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdmFsXG4gICAgICAgICAgICAgICAgOiBzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MXG4gICAgICAgICAgICAgICAgICAgID8gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgOiAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cbiAgICAgICAgU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSwgZHVwbGljYXRlcyA9IFtdLCBqID0gMCwgaSA9IDA7XG5cbiAgICAgICAgICAgIC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcbiAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG4gICAgICAgICAgICBzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoMCk7XG4gICAgICAgICAgICByZXN1bHRzLnNvcnQoc29ydE9yZGVyKTtcblxuICAgICAgICAgICAgaWYgKGhhc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtID0gcmVzdWx0c1tpKytdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSByZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gZHVwbGljYXRlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoZHVwbGljYXRlc1tqXSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG4gICAgICAgICAgICBzb3J0SW5wdXQgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuICAgICAgICBnZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSwgcmV0ID0gXCJcIiwgaSA9IDAsIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgaWYgKCFub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSBlbGVtW2krK10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGdldFRleHQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGdldFRleHQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuICAgICAgICAgICAgLy8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICBjYWNoZUxlbmd0aDogNTAsXG4gICAgICAgICAgICBjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcbiAgICAgICAgICAgIG1hdGNoOiBtYXRjaEV4cHIsXG4gICAgICAgICAgICBhdHRySGFuZGxlOiB7fSxcbiAgICAgICAgICAgIGZpbmQ6IHt9LFxuICAgICAgICAgICAgcmVsYXRpdmU6IHtcbiAgICAgICAgICAgICAgICBcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcbiAgICAgICAgICAgICAgICBcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICBBVFRSOiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzNdID0gKG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5lc2NhcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5lc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMl0gPT09IFwifj1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDSElMRDogZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXS5zbGljZSgwLCAzKSA9PT0gXCJudGhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzRdID0gKyhtYXRjaFs0XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDIgKiAobWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsobWF0Y2hbN10gKyBtYXRjaFs4XSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4Y2VzcywgdW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucXVvdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBzZXVkby50ZXN0KHVucXVvdGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5xdW90ZWQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICBUQUc6IGZ1bmN0aW9uKG5vZGVOYW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID8gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIENMQVNTOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlW2NsYXNzTmFtZSArIFwiIFwiXTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhdHRlcm4gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKF58XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInwkKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICApKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzQ2FjaGUoY2xhc3NOYW1lLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQVRUUjogZnVuY3Rpb24obmFtZSwgb3BlcmF0b3IsIGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoZWxlbSwgbmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0ID09PSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3BlcmF0b3IgPT09IFwiIT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdCAhPT0gY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvcGVyYXRvciA9PT0gXCJePVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKGNoZWNrKSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvcGVyYXRvciA9PT0gXCIqPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3BlcmF0b3IgPT09IFwiJD1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoZWNrICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2xpY2UoLWNoZWNrLmxlbmd0aCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvcGVyYXRvciA9PT0gXCJ+PVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ3aGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiKS5pbmRleE9mKGNoZWNrKSA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3BlcmF0b3IgPT09IFwifD1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0ID09PSBjaGVjayB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2subGVuZ3RoICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sgKyBcIi1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDSElMRDogZnVuY3Rpb24odHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKDAsIDMpICE9PSBcIm50aFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZCA9IHR5cGUuc2xpY2UoLTQpICE9PSBcImxhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID8gKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IChmdW5jdGlvbihlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSBzaW1wbGUgIT09IGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJuZXh0U2libGluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlID0gbm9kZVtkaXJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLm5vZGVUeXBlID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dFNpYmxpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJlbnQuZmlyc3RDaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50Lmxhc3RDaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkICYmIHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlW2V4cGFuZG9dID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdXRlckNhY2hlW25vZGUudW5pcXVlSURdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZUluZGV4ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkTm9kZXNbbm9kZUluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSAvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVtkaXJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2RpZmYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPT09IGVsZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVtleHBhbmRvXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gKytub2RlSW5kZXggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbZGlyXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9mVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLm5vZGVUeXBlID09PSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlW2V4cGFuZG9dID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW3R5cGVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgLT0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBQU0VVRE86IGZ1bmN0aW9uKHBzZXVkbywgYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gRXhwci5wc2V1ZG9zW3BzZXVkb10gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFeHByLnNldEZpbHRlcnNbcHNldWRvLnRvTG93ZXJDYXNlKCldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbltleHBhbmRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBzZXVkby50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oc2VlZCwgbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZuKHNlZWQsIGFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaW5kZXhPZihzZWVkLCBtYXRjaGVkW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbaWR4XSA9ICEobWF0Y2hlc1tpZHhdID0gbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVsZW0sIDAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwc2V1ZG9zOiB7XG4gICAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgbm90OiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXCIkMVwiKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJbZXhwYW5kb11cbiAgICAgICAgICAgICAgICAgICAgICAgID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBtYXRjaGVyKHNlZWQsIG51bGwsIHhtbCwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gc2VlZC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9IHVubWF0Y2hlZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGhhczogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZWxlbS50ZXh0Q29udGVudCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJUZXh0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGV4dChlbGVtKSkuaW5kZXhPZih0ZXh0KSA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTE7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLy8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLy8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuICAgICAgICAgICAgICAgIC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cbiAgICAgICAgICAgICAgICBsYW5nOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhbmcgPSBsYW5nLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbUxhbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVsZW0ubGFuZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtTGFuZy5pbmRleE9mKGxhbmcgKyBcIi1cIikgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSgxKSA9PT0gZWxlbS5pZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJvb3Q6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBCb29sZWFuIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyhmYWxzZSksXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGNyZWF0ZURpc2FibGVkUHNldWRvKHRydWUpLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuICAgICAgICAgICAgICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA8IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXShlbGVtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcbiAgICAgICAgICAgICAgICBoZWFkZXI6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJoZWFkZXIudGVzdChlbGVtLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaW5wdXRzLnRlc3QoZWxlbS5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBidXR0b246IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID09PSBcImJ1dHRvblwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBmaXJzdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgMCBdO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGxhc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24obWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGVxOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGV2ZW46IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24obWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9kZDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbihtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbHQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcyxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGd0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgKytpIDwgbGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBFeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuICAgICAgICAvLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuICAgICAgICBmb3IgKGkgaW4ge1xuICAgICAgICAgICAgcmFkaW86IHRydWUsXG4gICAgICAgICAgICBjaGVja2JveDogdHJ1ZSxcbiAgICAgICAgICAgIGZpbGU6IHRydWUsXG4gICAgICAgICAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAgICAgICAgIGltYWdlOiB0cnVlXG4gICAgICAgIH0pIHtcbiAgICAgICAgICAgIEV4cHIucHNldWRvc1tpXSA9IGNyZWF0ZUlucHV0UHNldWRvKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSkge1xuICAgICAgICAgICAgRXhwci5wc2V1ZG9zW2ldID0gY3JlYXRlQnV0dG9uUHNldWRvKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG4gICAgICAgIGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG4gICAgICAgIEV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbiAgICAgICAgdG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbihzZWxlY3RvciwgcGFyc2VPbmx5KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBzb0ZhcixcbiAgICAgICAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgICAgICAgcHJlRmlsdGVycyxcbiAgICAgICAgICAgICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xuXG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvRmFyID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBncm91cHMgPSBbXTtcbiAgICAgICAgICAgIHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuICAgICAgICAgICAgd2hpbGUgKHNvRmFyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyhzb0ZhcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSB8fCBzb0ZhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncm91cHMucHVzaCh0b2tlbnMgPSBbXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tYmluYXRvcnNcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyhzb0ZhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtYXRjaFswXS5yZXBsYWNlKHJ0cmltLCBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hlZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZpbHRlcnNcbiAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gRXhwci5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoID0gbWF0Y2hFeHByW3R5cGVdLmV4ZWMoc29GYXIpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghcHJlRmlsdGVyc1t0eXBlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggPSBwcmVGaWx0ZXJzW3R5cGVdKG1hdGNoKSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuICAgICAgICAgICAgLy8gaWYgd2UncmUganVzdCBwYXJzaW5nXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9ubHlcbiAgICAgICAgICAgICAgICA/IHNvRmFyLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogc29GYXIgPyBTaXp6bGUuZXJyb3Ioc2VsZWN0b3IpIDogLy8gQ2FjaGUgdGhlIHRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkNhY2hlKHNlbGVjdG9yLCBncm91cHMpLnNsaWNlKDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IodG9rZW5zKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGgsIHNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UpIHtcbiAgICAgICAgICAgIHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcbiAgICAgICAgICAgICAgICBza2lwID0gY29tYmluYXRvci5uZXh0LFxuICAgICAgICAgICAgICAgIGtleSA9IHNraXAgfHwgZGlyLFxuICAgICAgICAgICAgICAgIGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG4gICAgICAgICAgICAgICAgZG9uZU5hbWUgPSBkb25lKys7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICBjb21iaW5hdG9yLmZpcnN0ID8gKGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbSA9IGVsZW1bZGlyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pIDogKGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtW2V4cGFuZG9dIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZWxlbVtleHBhbmRvXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbZWxlbS51bmlxdWVJRF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdXRlckNhY2hlW2VsZW0udW5pcXVlSURdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1bZGlyXSB8fCBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVba2V5XSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDYWNoZVswXSA9PT0gZGlycnVucyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZENhY2hlWzFdID09PSBkb25lTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGVbMl0gPSBvbGRDYWNoZVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW2tleV0gPSBuZXdDYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FjaGVbMl0gPSBtYXRjaGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgPyAoZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXJzW2ldKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSkgOiBtYXRjaGVyc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29uZGVuc2UodW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICBuZXdVbm1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPSB1bm1hdGNoZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0TWF0Y2hlcihcbiAgICAgICAgICAgIHByZUZpbHRlcixcbiAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgIHBvc3RGaWx0ZXIsXG4gICAgICAgICAgICBwb3N0RmluZGVyLFxuICAgICAgICAgICAgcG9zdFNlbGVjdG9yXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlcihwb3N0RmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3N0RmluZGVyICYmICFwb3N0RmluZGVyW2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIocG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgIHByZU1hcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBwb3N0TWFwID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVDb250ZXh0cyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciB8fCBcIipcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckluID0gcHJlRmlsdGVyICYmIChzZWVkIHx8ICFzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uZGVuc2UoZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVsZW1zLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1hdGNoZXJJbjtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcihtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgcG9zdEZpbHRlclxuICAgICAgICAgICAgICAgIGlmIChwb3N0RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjb25kZW5zZShtYXRjaGVyT3V0LCBwb3N0TWFwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbHRlcih0ZW1wLCBbXSwgY29udGV4dCwgeG1sKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG4gICAgICAgICAgICAgICAgICAgIGkgPSB0ZW1wLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gPSB0ZW1wW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dFtwb3N0TWFwW2ldXSA9ICEobWF0Y2hlckluW3Bvc3RNYXBbaV1dID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtID0gbWF0Y2hlck91dFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaChtYXRjaGVySW5baV0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyKG51bGwsIG1hdGNoZXJPdXQgPSBbXSwgdGVtcCwgeG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ZW1wID0gcG9zdEZpbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaW5kZXhPZihzZWVkLCBlbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcHJlTWFwW2ldKSA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID09PSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXRjaGVyT3V0LnNwbGljZShwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtYXRjaGVyT3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyKG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG1hdGNoZXJPdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgICAgIHZhciBjaGVja0NvbnRleHQsXG4gICAgICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbMF0udHlwZV0sXG4gICAgICAgICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcbiAgICAgICAgICAgICAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcbiAgICAgICAgICAgICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbXBsaWNpdFJlbGF0aXZlLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPZihjaGVja0NvbnRleHQsIGVsZW0pID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG1hdGNoZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSAhbGVhZGluZ1JlbGF0aXZlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXRjaENvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1hdGNoQW55Q29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1tpXS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpLCBtYXRjaGVyKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSBFeHByLmZpbHRlclt0b2tlbnNbaV0udHlwZV0uYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldLm1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcltleHBhbmRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gKytpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlW3Rva2Vuc1tqXS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0TWF0Y2hlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID4gMSAmJiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDEgJiYgdG9TZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaSAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbnNbaSAtIDJdLnR5cGUgPT09IFwiIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiKlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMuc2xpY2UoaSwgaikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCBsZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zID0gdG9rZW5zLnNsaWNlKGopKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IodG9rZW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzKSB7XG4gICAgICAgICAgICB2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB4bWwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgIG91dGVybW9zdFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENvdW50ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oXCIqXCIsIG91dGVybW9zdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVuc1VuaXF1ZSA9IGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJtb3N0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbCA9ICFkb2N1bWVudElzSFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5U2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgKz0gaTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgICAgICAgICAgICAvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cbiAgICAgICAgICAgICAgICAgICAgLy8gbnVtZXJpY2FsbHkgemVyby5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2V0TWF0Y2hlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVybW9zdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhc2VlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLnVuaXF1ZVNvcnQocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bm1hdGNoZWQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGJ5U2V0ID8gbWFya0Z1bmN0aW9uKHN1cGVyTWF0Y2hlcikgOiBzdXBlck1hdGNoZXI7XG4gICAgICAgIH1cblxuICAgICAgICBjb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbihcbiAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBzZXRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XG5cbiAgICAgICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRva2VuaXplKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKG1hdGNoW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFtleHBhbmRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycylcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG4gICAgICAgICAgICAgICAgY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuICAgICAgICBzZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGZpbmQsXG4gICAgICAgICAgICAgICAgY29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICBtYXRjaCA9ICFzZWVkICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2VuaXplKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcbiAgICAgICAgICAgIC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcbiAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgICAgICAgIHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMubGVuZ3RoID4gMiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBFeHByLnJlbGF0aXZlW3Rva2Vuc1sxXS50eXBlXVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gKEV4cHIuZmluZFtcIklEXCJdKFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgW10pWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSh0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICBpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3Qoc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6IHRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlW3R5cGUgPSB0b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmQgPSBFeHByLmZpbmRbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWQgPSBmaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByc2libGluZy50ZXN0KHRva2Vuc1swXS50eXBlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHNlZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG4gICAgICAgICAgICAoY29tcGlsZWQgfHxcbiAgICAgICAgICAgICAgICBjb21waWxlKFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgICApKShzZWVkLCBjb250ZXh0LCAhZG9jdW1lbnRJc0hUTUwsIHJlc3VsdHMsICFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkgfHwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuICAgICAgICAvLyBTb3J0IHN0YWJpbGl0eVxuICAgICAgICBzdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoc29ydE9yZGVyKS5qb2luKFwiXCIpID09PVxuICAgICAgICAgICAgZXhwYW5kbztcblxuICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4gICAgICAgIC8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgICAgICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG4gICAgICAgIHNldERvY3VtZW50KCk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbiAgICAgICAgLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG4gICAgICAgIHN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcbiAgICAgICAgICAgIHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIilcbiAgICAgICAgICAgICkgJlxuICAgICAgICAgICAgICAgIDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbiAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbiAgICAgICAgaWYgKCFhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIjtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGUoXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgIC8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbiAgICAgICAgaWYgKCFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBcIlwiO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGUoXCJ2YWx1ZVwiLCBmdW5jdGlvbihlbGVtLCBuYW1lLCBpc1hNTCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAvLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG4gICAgICAgIGlmICghYXNzZXJ0KGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgYWRkSGFuZGxlKGJvb2xlYW5zLCBmdW5jdGlvbihlbGVtLCBuYW1lLCBpc1hNTCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNpenpsZTtcbiAgICB9KSh3aW5kb3cpO1xuXG4gICAgalF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG4gICAgalF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4gICAgLy8gRGVwcmVjYXRlZFxuICAgIGpRdWVyeS5leHByW1wiOlwiXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG4gICAgalF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG4gICAgalF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbiAgICBqUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG4gICAgalF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuICAgIGpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cbiAgICB2YXIgZGlyID0gZnVuY3Rpb24oZWxlbSwgZGlyLCB1bnRpbCkge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdLCB0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgd2hpbGUgKChlbGVtID0gZWxlbVtkaXJdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5KSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY2F0ZSAmJiBqUXVlcnkoZWxlbSkuaXModW50aWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfTtcblxuICAgIHZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKG4sIGVsZW0pIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcblxuICAgICAgICBmb3IgKDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2gobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9O1xuXG4gICAgdmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbiAgICB2YXIgcnNpbmdsZVRhZyA9IC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pO1xuXG4gICAgdmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuICAgIC8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG4gICAgZnVuY3Rpb24gd2lubm93KGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCkge1xuICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocXVhbGlmaWVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoZWxlbSwgaSwgZWxlbSkgIT09IG5vdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIGVsZW1lbnRcbiAgICAgICAgaWYgKHF1YWxpZmllci5ub2RlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IHF1YWxpZmllciAhPT0gbm90O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwocXVhbGlmaWVyLCBlbGVtKSA+IC0xICE9PSBub3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG4gICAgICAgIGlmIChyaXNTaW1wbGUudGVzdChxdWFsaWZpZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmZpbHRlcihxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGxleCBzZWxlY3RvciwgY29tcGFyZSB0aGUgdHdvIHNldHMsIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuICAgICAgICBxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZWxlbWVudHMpO1xuICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwocXVhbGlmaWVyLCBlbGVtKSA+IC0xICE9PSBub3QgJiZcbiAgICAgICAgICAgICAgICBlbGVtLm5vZGVUeXBlID09PSAxO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oZXhwciwgZWxlbXMsIG5vdCkge1xuICAgICAgICB2YXIgZWxlbSA9IGVsZW1zWzBdO1xuXG4gICAgICAgIGlmIChub3QpIHtcbiAgICAgICAgICAgIGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZWxlbSwgZXhwcikgPyBbIGVsZW0gXSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoXG4gICAgICAgICAgICBleHByLFxuICAgICAgICAgICAgalF1ZXJ5LmdyZXAoZWxlbXMsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBmaW5kOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIGksIHJldCwgbGVuID0gdGhpcy5sZW5ndGgsIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuY29udGFpbnMoc2VsZltpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9IHRoaXMucHVzaFN0YWNrKFtdKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQoc2VsZWN0b3IsIHNlbGZbaV0sIHJldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQocmV0KSA6IHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm90OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICBpczogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXdpbm5vdyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcbiAgICAgICAgICAgICAgICAvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdChzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgPyBqUXVlcnkoc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0b3IgfHwgW10sXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuICAgIC8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxuICAgIHZhciByb290alF1ZXJ5LFxuICAgICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuICAgICAgICAvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG4gICAgICAgIC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuICAgICAgICAvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG4gICAgICAgIHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcbiAgICAgICAgaW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCwgZWxlbTtcblxuICAgICAgICAgICAgLy8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuICAgICAgICAgICAgLy8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuICAgICAgICAgICAgcm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JbMF0gPT09IFwiPFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9PT0gXCI+XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLmxlbmd0aCA+PSAzXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHRbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5wYXJzZUhUTUwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNpbmdsZVRhZy50ZXN0KG1hdGNoWzFdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaXNQbGFpbk9iamVjdChjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtYXRjaCBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHRoaXNbbWF0Y2hdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKG1hdGNoLCBjb250ZXh0W21hdGNoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKCNpZClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRjaFsyXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0IHx8IHJvb3QpLmZpbmQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoY29udGV4dCkuZmluZChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvci5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuICAgICAgICAgICAgfSBlbHNlIGlmIChqUXVlcnkuaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gcm9vdC5yZWFkeShzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yKGpRdWVyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWFrZUFycmF5KHNlbGVjdG9yLCB0aGlzKTtcbiAgICAgICAgfTtcblxuICAgIC8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbiAgICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuICAgIC8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbiAgICByb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcblxuICAgIHZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcbiAgICAgICAgLy8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcbiAgICAgICAgZ3VhcmFudGVlZFVuaXF1ZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudHM6IHRydWUsXG4gICAgICAgICAgICBuZXh0OiB0cnVlLFxuICAgICAgICAgICAgcHJldjogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGhhczogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGpRdWVyeSh0YXJnZXQsIHRoaXMpLCBsID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyh0aGlzLCB0YXJnZXRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VzdDogZnVuY3Rpb24oc2VsZWN0b3JzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY3VyLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gW10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KHNlbGVjdG9ycyk7XG5cbiAgICAgICAgICAgIC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcbiAgICAgICAgICAgIGlmICghcm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSA8IDExICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YXJnZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhcmdldHMuaW5kZXgoY3VyKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICAgICAgICAgIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KG1hdGNoZWQpIDogbWF0Y2hlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG4gICAgICAgIGluZGV4OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5kZXggaW4gc2VsZWN0b3JcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoalF1ZXJ5KGVsZW0pLCB0aGlzWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgZWxlbS5qcXVlcnkgPyBlbGVtWzBdIDogZWxlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICAgICAgICAgIGpRdWVyeS51bmlxdWVTb3J0KFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UodGhpcy5nZXQoKSwgalF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBhZGRCYWNrOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByZXZPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2libGluZyhjdXIsIGRpcikge1xuICAgICAgICB3aGlsZSAoKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKFxuICAgICAgICB7XG4gICAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50czogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudHNVbnRpbDogZnVuY3Rpb24oZWxlbSwgaSwgdW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nKGVsZW0sIFwibmV4dFNpYmxpbmdcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldjogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRBbGw6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldkFsbDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dFVudGlsOiBmdW5jdGlvbihlbGVtLCBpLCB1bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldlVudGlsOiBmdW5jdGlvbihlbGVtLCBpLCB1bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpYmxpbmdzOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKChlbGVtLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGVsZW0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKGVsZW0uZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudHM6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKFtdLCBlbGVtLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgICAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24odW50aWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKHRoaXMsIGZuLCB1bnRpbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zbGljZSgtNSkgIT09IFwiVW50aWxcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIG1hdGNoZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFndWFyYW50ZWVkVW5pcXVlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlU29ydChtYXRjaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChycGFyZW50c3ByZXYudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgKTtcbiAgICB2YXIgcm5vdGh0bWx3aGl0ZSA9IC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZztcblxuICAgIC8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG4gICAgZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgalF1ZXJ5LmVhY2gob3B0aW9ucy5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXSwgZnVuY3Rpb24oXywgZmxhZykge1xuICAgICAgICAgICAgb2JqZWN0W2ZsYWddID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbiAgICBqUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG4gICAgICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcbiAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGNyZWF0ZU9wdGlvbnMob3B0aW9ucylcbiAgICAgICAgICAgIDogalF1ZXJ5LmV4dGVuZCh7fSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcbiAgICAgICAgZmlyaW5nLFxuICAgICAgICAgICAgLy8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcbiAgICAgICAgICAgIG1lbW9yeSxcbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICAgICAgICBmaXJlZCxcbiAgICAgICAgICAgIC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcbiAgICAgICAgICAgIGxvY2tlZCxcbiAgICAgICAgICAgIC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG4gICAgICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgICAgICAvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuICAgICAgICAgICAgcXVldWUgPSBbXSxcbiAgICAgICAgICAgIC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuICAgICAgICAgICAgZmlyaW5nSW5kZXggPSAtMSxcbiAgICAgICAgICAgIC8vIEZpcmUgY2FsbGJhY2tzXG4gICAgICAgICAgICBmaXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG4gICAgICAgICAgICAgICAgbG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG4gICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFtmaXJpbmdJbmRleF0uYXBwbHkobWVtb3J5WzBdLCBtZW1vcnlbMV0pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0b3BPbkZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2RcbiAgICAgICAgICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbW9yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcbiAgICAgICAgICAgIHNlbGYgPSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbW9yeSAmJiAhZmlyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChtZW1vcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gYWRkKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaChhcmdzLCBmdW5jdGlvbihfLCBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkudHlwZShhcmcpICE9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1vcnkgJiYgIWZpcmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKF8sIGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmRleCA9IGpRdWVyeS5pbkFycmF5KGFyZywgbGlzdCwgaW5kZXgpKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG4gICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheShmbiwgbGlzdCkgPiAtMSA6IGxpc3QubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFsaXN0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSAuZmlyZVxuICAgICAgICAgICAgICAgIC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuICAgICAgICAgICAgICAgIGxvY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lbW9yeSAmJiAhZmlyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWxvY2tlZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBmaXJlV2l0aDogZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuICAgICAgICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZmlyZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSWRlbnRpdHkodikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVGhyb3dlcihleCkge1xuICAgICAgICB0aHJvdyBleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZG9wdFZhbHVlKHZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIG1ldGhvZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKG1ldGhvZCA9IHZhbHVlLnByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwodmFsdWUpLmRvbmUocmVzb2x2ZSkuZmFpbChyZWplY3QpO1xuICAgICAgICAgICAgICAgIC8vIE90aGVyIHRoZW5hYmxlc1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbihtZXRob2QgPSB2YWx1ZS50aGVuKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIC8vIE90aGVyIG5vbi10aGVuYWJsZXNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuICAgICAgICAgICAgICAgIC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcbiAgICAgICAgICAgICAgICByZXNvbHZlLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcbiAgICAgICAgICAgIC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cbiAgICAgICAgICAgIC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG4gICAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG4gICAgICAgICAgICAvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG4gICAgICAgICAgICByZWplY3QuY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgdmFyIHR1cGxlcyA9IFtcbiAgICAgICAgICAgICAgICAvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIFwibm90aWZ5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicHJvZ3Jlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBcInJlc29sdmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkb25lXCIsXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBcInJlc29sdmVkXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgXCJyZWplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJmYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhbHdheXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjYXRjaDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4obnVsbCwgZm4pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG4gICAgICAgICAgICAgICAgICAgIHBpcGU6IGZ1bmN0aW9uKCkgLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi9cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbihuZXdEZWZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24oaSwgdHVwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKGZuc1t0dXBsZVs0XV0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbnNbdHVwbGVbNF1dO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMV1dKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0Z1bmN0aW9uKHJldHVybmVkLnByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvbWlzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyhuZXdEZWZlci5ub3RpZnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb25lKG5ld0RlZmVyLnJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKG5ld0RlZmVyLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyW3R1cGxlWzBdICsgXCJXaXRoXCJdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4RGVwdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZShkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkLCB0aGVuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkodGhhdCwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiA9IC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXR1cm5lZCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLnRoZW47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaHJvd2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gSWRlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyByZXR1cm5lZCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgdmFsdWUocylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNwZWNpYWwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKSh0aGF0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzID0gc3BlY2lhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbWlnaHRUaHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0YWNrVHJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggKyAxID49IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSBUaHJvd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbIGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChwcm9jZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24obmV3RGVmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVzWzBdWzNdLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEZWZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0Z1bmN0aW9uKG9uUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLm5vdGlmeVdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sxXVszXS5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaXNGdW5jdGlvbihvbkZ1bGZpbGxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9uRnVsZmlsbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBJZGVudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbMl1bM10uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzRnVuY3Rpb24ob25SZWplY3RlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9uUmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFRocm93ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8galF1ZXJ5LmV4dGVuZChvYmosIHByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IHt9O1xuXG4gICAgICAgICAgICAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG4gICAgICAgICAgICBqUXVlcnkuZWFjaCh0dXBsZXMsIGZ1bmN0aW9uKGksIHR1cGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0dXBsZVsyXSwgc3RhdGVTdHJpbmcgPSB0dXBsZVs1XTtcblxuICAgICAgICAgICAgICAgIC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuICAgICAgICAgICAgICAgIC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcbiAgICAgICAgICAgICAgICBwcm9taXNlW3R1cGxlWzFdXSA9IGxpc3QuYWRkO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVzWzMgLSBpXVsyXS5kaXNhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1swXVsyXS5sb2NrXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuICAgICAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuICAgICAgICAgICAgICAgIGxpc3QuYWRkKHR1cGxlWzNdLmZpcmUpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cbiAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVswXV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJXaXRoXCJdKHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVswXSArIFwiV2l0aFwiXSA9IGxpc3QuZmlyZVdpdGg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG4gICAgICAgICAgICBwcm9taXNlLnByb21pc2UoZGVmZXJyZWQpO1xuXG4gICAgICAgICAgICAvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG4gICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgIGZ1bmMuY2FsbChkZWZlcnJlZCwgZGVmZXJyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGwgZG9uZSFcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKHNpbmdsZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLy8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG4gICAgICAgICAgICByZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGkgPSByZW1haW5pbmcsXG4gICAgICAgICAgICAgICAgLy8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuICAgICAgICAgICAgICAgIHJlc29sdmVDb250ZXh0cyA9IEFycmF5KGkpLFxuICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hc3RlciBEZWZlcnJlZFxuICAgICAgICAgICAgICAgIG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3RvcnlcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDb250ZXh0c1tpXSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzW2ldID0gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyLnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBhZG9wdFZhbHVlKFxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWFzdGVyLmRvbmUodXBkYXRlRnVuYyhpKSkucmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWFzdGVyLnJlamVjdFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0Z1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZXNbaV0gJiYgcmVzb2x2ZVZhbHVlc1tpXS50aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXN0ZXIudGhlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBhZG9wdFZhbHVlKHJlc29sdmVWYWx1ZXNbaV0sIHVwZGF0ZUZ1bmMoaSksIG1hc3Rlci5yZWplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4gICAgLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG4gICAgdmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbiAgICBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKGVycm9yLCBzdGFjaykge1xuICAgICAgICAvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG4gICAgICAgIC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlICYmXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2FybiAmJlxuICAgICAgICAgICAgICAgIGVycm9yICYmXG4gICAgICAgICAgICAgICAgcmVycm9yTmFtZXMudGVzdChlcnJvci5uYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxuICAgIHZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuICAgIGpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHJlYWR5TGlzdC50aGVuKGZuKS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uKGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICAvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcbiAgICAgICAgLy8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuICAgICAgICAvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuICAgICAgICByZWFkeVdhaXQ6IDEsXG4gICAgICAgIC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuICAgICAgICBob2xkUmVhZHk6IGZ1bmN0aW9uKGhvbGQpIHtcbiAgICAgICAgICAgIGlmIChob2xkKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5V2FpdCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uKHdhaXQpIHtcbiAgICAgICAgICAgIC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcbiAgICAgICAgICAgIGlmICh3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgICAgICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuICAgICAgICAgICAgaWYgKHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKGRvY3VtZW50LCBbIGpRdWVyeSBdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuICAgIC8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcbiAgICAgICAgalF1ZXJ5LnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbiAgICAvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4gICAgLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG4gICAgaWYgKFxuICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcbiAgICAgICAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmXG4gICAgICAgICAgICAgICAgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbFxuICAgICkge1xuICAgICAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoalF1ZXJ5LnJlYWR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCk7XG5cbiAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXBsZXRlZCk7XG4gICAgfVxuXG4gICAgLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4gICAgLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG4gICAgdmFyIGFjY2VzcyA9IGZ1bmN0aW9uKGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3KSB7XG4gICAgICAgIHZhciBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoLCBidWxrID0ga2V5ID09IG51bGw7XG5cbiAgICAgICAgLy8gU2V0cyBtYW55IHZhbHVlc1xuICAgICAgICBpZiAoalF1ZXJ5LnR5cGUoa2V5KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3MoZWxlbXMsIGZuLCBpLCBrZXlbaV0sIHRydWUsIGVtcHR5R2V0LCByYXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0cyBvbmUgdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIWpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChidWxrKSB7XG4gICAgICAgICAgICAgICAgLy8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG4gICAgICAgICAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKGVsZW1zLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bGsgPSBmbjtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbihlbGVtLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVsay5jYWxsKGpRdWVyeShlbGVtKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKGVsZW1zW2ldLCBpLCBmbihlbGVtc1tpXSwga2V5KSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhaW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXRzXG4gICAgICAgIGlmIChidWxrKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbChlbGVtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVuID8gZm4oZWxlbXNbMF0sIGtleSkgOiBlbXB0eUdldDtcbiAgICB9O1xuICAgIHZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24ob3duZXIpIHtcbiAgICAgICAgLy8gQWNjZXB0cyBvbmx5OlxuICAgICAgICAvLyAgLSBOb2RlXG4gICAgICAgIC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgLy8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcbiAgICAgICAgLy8gIC0gT2JqZWN0XG4gICAgICAgIC8vICAgIC0gQW55XG4gICAgICAgIHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhK293bmVyLm5vZGVUeXBlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBEYXRhKCkge1xuICAgICAgICB0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG4gICAgfVxuXG4gICAgRGF0YS51aWQgPSAxO1xuXG4gICAgRGF0YS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNhY2hlOiBmdW5jdGlvbihvd25lcikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xuXG4gICAgICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBvbmVcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgICAgICAgICAgICBpZiAoYWNjZXB0RGF0YShvd25lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgdGhpcy5leHBhbmRvLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihvd25lciwgZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9wLCBjYWNoZSA9IHRoaXMuY2FjaGUob3duZXIpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG4gICAgICAgICAgICAvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtqUXVlcnkuY2FtZWxDYXNlKGRhdGEpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbalF1ZXJ5LmNhbWVsQ2FzZShwcm9wKV0gPSBkYXRhW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihvd25lciwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHRoaXMuY2FjaGUob3duZXIpXG4gICAgICAgICAgICAgICAgOiAvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG4gICAgICAgICAgICAgICAgb3duZXJbdGhpcy5leHBhbmRvXSAmJlxuICAgICAgICAgICAgICAgICAgICBvd25lclt0aGlzLmV4cGFuZG9dW2pRdWVyeS5jYW1lbENhc2Uoa2V5KV07XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2VzczogZnVuY3Rpb24ob3duZXIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgICAvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGtleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChvd25lciwga2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcbiAgICAgICAgICAgIC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdGhpcy5zZXQob3duZXIsIGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihvd25lciwga2V5KSB7XG4gICAgICAgICAgICB2YXIgaSwgY2FjaGUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xuXG4gICAgICAgICAgICBpZiAoY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5Lm1hcChqUXVlcnkuY2FtZWxDYXNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkgaW4gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWyBrZXkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXkubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IGtleS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXlbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoY2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuICAgICAgICAgICAgICAgIC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG4gICAgICAgICAgICAgICAgaWYgKG93bmVyLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG93bmVyW3RoaXMuZXhwYW5kb107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXNEYXRhOiBmdW5jdGlvbihvd25lcikge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdChjYWNoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbiAgICB2YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG4gICAgLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbiAgICAvL1xuICAgIC8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4gICAgLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuICAgIC8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbiAgICAvL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbiAgICAvL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuICAgIC8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbiAgICAvL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG4gICAgdmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLywgcm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcbiAgICAgICAgaWYgKGRhdGEgPT09ICtkYXRhICsgXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuICtkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJicmFjZS50ZXN0KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRhdGFBdHRyKGVsZW0sIGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG4gICAgICAgIC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZShybXVsdGlEYXNoLCBcIi0kJlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZ2V0RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG4gICAgICAgICAgICAgICAgZGF0YVVzZXIuc2V0KGVsZW0sIGtleSwgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVXNlci5oYXNEYXRhKGVsZW0pIHx8IGRhdGFQcml2Lmhhc0RhdGEoZWxlbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVXNlci5hY2Nlc3MoZWxlbSwgbmFtZSwgZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZShlbGVtLCBuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcbiAgICAgICAgLy8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG4gICAgICAgIF9kYXRhOiBmdW5jdGlvbihlbGVtLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKGVsZW0sIG5hbWUsIGRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBfcmVtb3ZlRGF0YTogZnVuY3Rpb24oZWxlbSwgbmFtZSkge1xuICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgZGF0YTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGksIG5hbWUsIGRhdGEsIGVsZW0gPSB0aGlzWzBdLCBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAvLyBHZXRzIGFsbCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KGVsZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZGF0YVByaXYuZ2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGF0dHJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiZGF0YS1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKG5hbWUuc2xpY2UoNSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUF0dHIoZWxlbSwgbmFtZSwgZGF0YVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQoZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVzZXIuc2V0KHRoaXMsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KGVsZW0sIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YUF0dHIoZWxlbSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkYXRhLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVc2VyLnNldCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZSh0aGlzLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBxdWV1ZTogZnVuY3Rpb24oZWxlbSwgdHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAodHlwZSB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiO1xuICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YVByaXYuZ2V0KGVsZW0sIHR5cGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUgfHwgW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uKGVsZW0sIHR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKGVsZW0sIHR5cGUpLFxuICAgICAgICAgICAgICAgIHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKSxcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCB0eXBlKSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgICAgICAgIGlmIChmbiA9PT0gXCJpbnByb2dyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGgtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmeFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGVsZW0sIG5leHQsIGhvb2tzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzdGFydExlbmd0aCAmJiBob29rcykge1xuICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgX3F1ZXVlSG9va3M6IGZ1bmN0aW9uKGVsZW0sIHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuZ2V0KGVsZW0sIGtleSkgfHwgZGF0YVByaXYuYWNjZXNzKGVsZW0sIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2V0dGVyID0gMjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwiZnhcIjtcbiAgICAgICAgICAgICAgICBzZXR0ZXItLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKHRoaXNbMF0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKHRoaXMsIHR5cGUsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyh0aGlzLCB0eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG4gICAgICAgIC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuICAgICAgICBwcm9taXNlOiBmdW5jdGlvbih0eXBlLCBvYmopIHtcbiAgICAgICAgICAgIHZhciB0bXAsXG4gICAgICAgICAgICAgICAgY291bnQgPSAxLFxuICAgICAgICAgICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1jb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZVdpdGgoZWxlbWVudHMsIFsgZWxlbWVudHMgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBkYXRhUHJpdi5nZXQoZWxlbWVudHNbaV0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdG1wLmVtcHR5LmFkZChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZShvYmopO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHBudW0gPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2U7XG5cbiAgICB2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpO1xuXG4gICAgdmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG4gICAgdmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKGVsZW0sIGVsKSB7XG4gICAgICAgIC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcbiAgICAgICAgZWxlbSA9IGVsIHx8IGVsZW07XG5cbiAgICAgICAgLy8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcbiAgICAgICAgcmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiAvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcbiAgICAgICAgICAgICAgICAvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmNvbnRhaW5zKFxuICAgICAgICAgICAgICAgICAgICBlbGVtLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1cbiAgICAgICAgICAgICAgICApICYmIGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIjtcbiAgICB9O1xuXG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbihlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncykge1xuICAgICAgICB2YXIgcmV0LCBuYW1lLCBvbGQgPSB7fTtcblxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9sZFtuYW1lXSA9IGVsZW0uc3R5bGVbbmFtZV07XG4gICAgICAgICAgICBlbGVtLnN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IGNhbGxiYWNrLmFwcGx5KGVsZW0sIGFyZ3MgfHwgW10pO1xuXG4gICAgICAgIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9sZFtuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFkanVzdENTUyhlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2Vlbikge1xuICAgICAgICB2YXIgYWRqdXN0ZWQsXG4gICAgICAgICAgICBzY2FsZSA9IDEsXG4gICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMjAsXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB0d2VlbiA/IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmN1cigpO1xuICAgICAgICAgICAgICAgIH0pIDogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNzcyhlbGVtLCBwcm9wLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcbiAgICAgICAgICAgIHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbM10gfHxcbiAgICAgICAgICAgICAgICAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFwiXCIgOiBcInB4XCIpLFxuICAgICAgICAgICAgLy8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSB8fFxuICAgICAgICAgICAgICAgIHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCkgJiZcbiAgICAgICAgICAgICAgICByY3NzTnVtLmV4ZWMoalF1ZXJ5LmNzcyhlbGVtLCBwcm9wKSk7XG5cbiAgICAgICAgaWYgKGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFszXSAhPT0gdW5pdCkge1xuICAgICAgICAgICAgLy8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuICAgICAgICAgICAgdW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFszXTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuICAgICAgICAgICAgdmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuICAgICAgICAgICAgICAgIC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgYW5kIGFwcGx5XG4gICAgICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcbiAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cbiAgICAgICAgICAgIH0gd2hpbGUgKHNjYWxlICE9PSAoc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwpICYmXG4gICAgICAgICAgICAgICAgc2NhbGUgIT09IDEgJiZcbiAgICAgICAgICAgICAgICAtLW1heEl0ZXJhdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlUGFydHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG4gICAgICAgICAgICAvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGFkanVzdGVkID0gdmFsdWVQYXJ0c1sxXVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbEluVW5pdCArICh2YWx1ZVBhcnRzWzFdICsgMSkgKiB2YWx1ZVBhcnRzWzJdXG4gICAgICAgICAgICAgICAgOiArdmFsdWVQYXJ0c1syXTtcbiAgICAgICAgICAgIGlmICh0d2Vlbikge1xuICAgICAgICAgICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0O1xuICAgICAgICAgICAgICAgIHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRqdXN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheShlbGVtKSB7XG4gICAgICAgIHZhciB0ZW1wLFxuICAgICAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuICAgICAgICAgICAgZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwW25vZGVOYW1lXTtcblxuICAgICAgICBpZiAoZGlzcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpKTtcbiAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3ModGVtcCwgXCJkaXNwbGF5XCIpO1xuXG4gICAgICAgIHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wKTtcblxuICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIGRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdERpc3BsYXlNYXBbbm9kZU5hbWVdID0gZGlzcGxheTtcblxuICAgICAgICByZXR1cm4gZGlzcGxheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93SGlkZShlbGVtZW50cywgc2hvdykge1xuICAgICAgICB2YXIgZGlzcGxheSwgZWxlbSwgdmFsdWVzID0gW10sIGluZGV4ID0gMCwgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuICAgICAgICAgICAgICAgIC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IGRhdGFQcml2LmdldChlbGVtLCBcImRpc3BsYXlcIikgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBnZXREZWZhdWx0RGlzcGxheShlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gXCJub25lXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQoZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHNbaW5kZXhdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvd0hpZGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIaWRkZW5XaXRoaW5UcmVlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciByY2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xuXG4gICAgdmFyIHJ0YWdOYW1lID0gLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pO1xuXG4gICAgdmFyIHJzY3JpcHRUeXBlID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaTtcblxuICAgIC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG4gICAgdmFyIHdyYXBNYXAgPSB7XG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgIG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuICAgICAgICAvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuICAgICAgICAvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG4gICAgICAgIC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cbiAgICAgICAgdGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuICAgICAgICBjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuICAgICAgICB0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG4gICAgICAgIHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcbiAgICAgICAgX2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG4gICAgfTtcblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgd3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG4gICAgd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbiAgICB3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuICAgIGZ1bmN0aW9uIGdldEFsbChjb250ZXh0LCB0YWcpIHtcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyB8fCBcIipcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhZyB8fCBcIipcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKGNvbnRleHQsIHRhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoWyBjb250ZXh0IF0sIHJldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuICAgIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoZWxlbXMsIHJlZkVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBpID0gMCwgbCA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZGF0YVByaXYuc2V0KFxuICAgICAgICAgICAgICAgIGVsZW1zW2ldLFxuICAgICAgICAgICAgICAgIFwiZ2xvYmFsRXZhbFwiLFxuICAgICAgICAgICAgICAgICFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQocmVmRWxlbWVudHNbaV0sIFwiZ2xvYmFsRXZhbFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuICAgIGZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCkge1xuICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgIHdyYXAsXG4gICAgICAgICAgICBjb250YWlucyxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW1zW2ldO1xuXG4gICAgICAgICAgICBpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS50eXBlKGVsZW0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJodG1sLnRlc3QoZWxlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjb250ZXh0LmNyZWF0ZVRleHROb2RlKGVsZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdGFnID0gKHJ0YWdOYW1lLmV4ZWMoZWxlbSkgfHwgWyBcIlwiLCBcIlwiIF0pWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXAgPSB3cmFwTWFwW3RhZ10gfHwgd3JhcE1hcC5fZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9IHdyYXBbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoZWxlbSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcFsyXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgaiA9IHdyYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIHRtcC5jaGlsZE5vZGVzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICB0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5MilcbiAgICAgICAgICAgICAgICAgICAgdG1wLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG4gICAgICAgIGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGVsZW0gPSBub2Rlc1tpKytdKSB7XG4gICAgICAgICAgICAvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheShlbGVtLCBzZWxlY3Rpb24pID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWlucyA9IGpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pO1xuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gZnJhZ21lbnRcbiAgICAgICAgICAgIHRtcCA9IGdldEFsbChmcmFnbWVudC5hcHBlbmRDaGlsZChlbGVtKSwgXCJzY3JpcHRcIik7XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHNldEdsb2JhbEV2YWwodG1wKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuICAgICAgICAgICAgaWYgKHNjcmlwdHMpIHtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbSA9IHRtcFtqKytdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyc2NyaXB0VHlwZS50ZXN0KGVsZW0udHlwZSB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cblxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSksXG4gICAgICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG4gICAgICAgIC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG4gICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcbiAgICAgICAgLy8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIik7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpO1xuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChpbnB1dCk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG4gICAgICAgIC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuICAgICAgICBzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXZcbiAgICAgICAgICAgIC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgICAgIC5jbG9uZU5vZGUodHJ1ZSkubGFzdENoaWxkLmNoZWNrZWQ7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcbiAgICAgICAgc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuICAgIH0pKCk7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIHZhciBya2V5RXZlbnQgPSAvXmtleS8sXG4gICAgICAgIHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuICAgICAgICBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbiAgICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG4gICAgZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbihlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUpIHtcbiAgICAgICAgdmFyIG9yaWdGbiwgdHlwZTtcblxuICAgICAgICAvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgICAgICBvbihlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbdHlwZV0sIG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gKCB0eXBlcywgZm4gKVxuICAgICAgICAgICAgZm4gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChmbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcbiAgICAgICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9uZSA9PT0gMSkge1xuICAgICAgICAgICAgb3JpZ0ZuID0gZm47XG4gICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG4gICAgICAgICAgICAgICAgalF1ZXJ5KCkub2ZmKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuICAgICAgICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8IChvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKyspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xuICAgIGpRdWVyeS5ldmVudCA9IHtcbiAgICAgICAgZ2xvYmFsOiB7fSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbihlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVPYmpJbixcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZSxcbiAgICAgICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwsXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLFxuICAgICAgICAgICAgICAgIG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KGVsZW0pO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuICAgICAgICAgICAgaWYgKCFlbGVtRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5ndWlkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAgICAgaWYgKCEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoZWxlbSwgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuICAgICAgICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgWyBcIlwiIF07XG4gICAgICAgICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWModHlwZXNbdF0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuICAgICAgICAgICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iakluXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgaWYgKCEoaGFuZGxlcnMgPSBldmVudHNbdHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhc3BlY2lhbC5zZXR1cCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuc2V0dXAuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZXZlbnRIYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYWRkLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoKGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKyksIDAsIGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZ2xvYmFsW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcykge1xuICAgICAgICAgICAgdmFyIGosXG4gICAgICAgICAgICAgICAgb3JpZ0NvdW50LFxuICAgICAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmosXG4gICAgICAgICAgICAgICAgc3BlY2lhbCxcbiAgICAgICAgICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMsXG4gICAgICAgICAgICAgICAgb3JpZ1R5cGUsXG4gICAgICAgICAgICAgICAgZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKGVsZW0pICYmIGRhdGFQcml2LmdldChlbGVtKTtcblxuICAgICAgICAgICAgaWYgKCFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcbiAgICAgICAgICAgIHR5cGVzID0gKHR5cGVzIHx8IFwiXCIpLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFsgXCJcIiBdO1xuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICh0LS0pIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKHR5cGVzW3RdKSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9ICh0bXBbMl0gfHwgXCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSArIHR5cGVzW3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG4gICAgICAgICAgICAgICAgdHlwZSA9IChzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0bXAgPSB0bXBbMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcbiAgICAgICAgICAgICAgICBvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gaGFuZGxlcnNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCF0bXAgfHwgdG1wLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFzZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShqLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZU9iai5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgICAgICAgICAvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIXNwZWNpYWwudGVhcmRvd24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1EYXRhLmhhbmRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdChldmVudHMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uKG5hdGl2ZUV2ZW50KSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcbiAgICAgICAgICAgIHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgobmF0aXZlRXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgICBtYXRjaGVkLFxuICAgICAgICAgICAgICAgIGhhbmRsZU9iaixcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUsXG4gICAgICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IChkYXRhUHJpdi5nZXQodGhpcywgXCJldmVudHNcIikgfHwge30pW2V2ZW50LnR5cGVdIHx8XG4gICAgICAgICAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFtldmVudC50eXBlXSB8fCB7fTtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBldmVudDtcblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIGV2ZW50KSA9PT0gZmFsc2VcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGhhbmRsZXJzXG4gICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBldmVudCwgaGFuZGxlcnMpO1xuXG4gICAgICAgICAgICAvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgICAgIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzW2orK10pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhZXZlbnQucm5hbWVzcGFjZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJuYW1lc3BhY2UudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gKChqUXVlcnkuZXZlbnQuc3BlY2lhbFtoYW5kbGVPYmoub3JpZ1R5cGVdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge30pLmhhbmRsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyKS5hcHBseShtYXRjaGVkLmVsZW0sIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuICAgICAgICAgICAgaWYgKHNwZWNpYWwucG9zdERpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXJzOiBmdW5jdGlvbihldmVudCwgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGhhbmRsZU9iaixcbiAgICAgICAgICAgICAgICBzZWwsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEhhbmRsZXJzLFxuICAgICAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnMsXG4gICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlID0gW10sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG4gICAgICAgICAgICAgICAgY3VyID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICAvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVDb3VudCAmJiAvLyBTdXBwb3J0OiBJRSA8PTlcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG4gICAgICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSAmJiAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuICAgICAgICAgICAgICAgICAgICAhKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkU2VsZWN0b3JzW3NlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzW3NlbF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGpRdWVyeShzZWwsIHRoaXMpLmluZGV4KGN1cikgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBqUXVlcnkuZmluZChzZWwsIHRoaXMsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTZWxlY3RvcnNbc2VsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkSGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBjdXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuICAgICAgICAgICAgY3VyID0gdGhpcztcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiBjdXIsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZShkZWxlZ2F0ZUNvdW50KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlclF1ZXVlO1xuICAgICAgICB9LFxuICAgICAgICBhZGRQcm9wOiBmdW5jdGlvbihuYW1lLCBob29rKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oaG9vaykgPyAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvb2sodGhpcy5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkgOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmaXg6IGZ1bmN0aW9uKG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEV2ZW50W2pRdWVyeS5leHBhbmRvXVxuICAgICAgICAgICAgICAgID8gb3JpZ2luYWxFdmVudFxuICAgICAgICAgICAgICAgIDogbmV3IGpRdWVyeS5FdmVudChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3BlY2lhbDoge1xuICAgICAgICAgICAgbG9hZDoge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcbiAgICAgICAgICAgICAgICBub0J1YmJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6IHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGljazoge1xuICAgICAgICAgICAgICAgIC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGljayAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ub2RlTmFtZSh0aGlzLCBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3NcbiAgICAgICAgICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZShldmVudC50YXJnZXQsIFwiYVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVmb3JldW5sb2FkOiB7XG4gICAgICAgICAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGVsZW0sIHR5cGUsIGhhbmRsZSkge1xuICAgICAgICAvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcbiAgICAgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oc3JjLCBwcm9wcykge1xuICAgICAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KHNyYywgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZlbnQgb2JqZWN0XG4gICAgICAgIGlmIChzcmMgJiYgc3JjLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAgICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG4gICAgICAgICAgICAgICAgc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgc3JjLnJldHVyblZhbHVlID09PSBmYWxzZVxuICAgICAgICAgICAgICAgID8gcmV0dXJuVHJ1ZVxuICAgICAgICAgICAgICAgIDogcmV0dXJuRmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuICAgICAgICAgICAgLy8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzXG4gICAgICAgICAgICAgICAgPyBzcmMudGFyZ2V0LnBhcmVudE5vZGVcbiAgICAgICAgICAgICAgICA6IHNyYy50YXJnZXQ7XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICAvLyBFdmVudCB0eXBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodGhpcywgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cbiAgICAgICAgLy8gTWFyayBpdCBhcyBmaXhlZFxuICAgICAgICB0aGlzW2pRdWVyeS5leHBhbmRvXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgICBqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICAgICAgaXNTaW11bGF0ZWQ6IGZhbHNlLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbiAgICBqUXVlcnkuZWFjaChcbiAgICAgICAge1xuICAgICAgICAgICAgYWx0S2V5OiB0cnVlLFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWw6IHRydWUsXG4gICAgICAgICAgICBldmVudFBoYXNlOiB0cnVlLFxuICAgICAgICAgICAgbWV0YUtleTogdHJ1ZSxcbiAgICAgICAgICAgIHBhZ2VYOiB0cnVlLFxuICAgICAgICAgICAgcGFnZVk6IHRydWUsXG4gICAgICAgICAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICAgICAgICAgIHZpZXc6IHRydWUsXG4gICAgICAgICAgICBjaGFyOiB0cnVlLFxuICAgICAgICAgICAgY2hhckNvZGU6IHRydWUsXG4gICAgICAgICAgICBrZXk6IHRydWUsXG4gICAgICAgICAgICBrZXlDb2RlOiB0cnVlLFxuICAgICAgICAgICAgYnV0dG9uOiB0cnVlLFxuICAgICAgICAgICAgYnV0dG9uczogdHJ1ZSxcbiAgICAgICAgICAgIGNsaWVudFg6IHRydWUsXG4gICAgICAgICAgICBjbGllbnRZOiB0cnVlLFxuICAgICAgICAgICAgb2Zmc2V0WDogdHJ1ZSxcbiAgICAgICAgICAgIG9mZnNldFk6IHRydWUsXG4gICAgICAgICAgICBwb2ludGVySWQ6IHRydWUsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcmVlblg6IHRydWUsXG4gICAgICAgICAgICBzY3JlZW5ZOiB0cnVlLFxuICAgICAgICAgICAgdGFyZ2V0VG91Y2hlczogdHJ1ZSxcbiAgICAgICAgICAgIHRvRWxlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIHRvdWNoZXM6IHRydWUsXG4gICAgICAgICAgICB3aGljaDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXZlbnQuY2hhckNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhZXZlbnQud2hpY2ggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBybW91c2VFdmVudC50ZXN0KGV2ZW50LnR5cGUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b24gJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b24gJiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b24gJiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC53aGljaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZFByb3BcbiAgICApO1xuXG4gICAgLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4gICAgLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbiAgICAvLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuICAgIC8vXG4gICAgLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuICAgIC8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuICAgIC8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG4gICAgalF1ZXJ5LmVhY2goXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgICAgICAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG4gICAgICAgICAgICBwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcbiAgICAgICAgICAgIHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24ob3JpZywgZml4KSB7XG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtvcmlnXSA9IHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcbiAgICAgICAgICAgICAgICBiaW5kVHlwZTogZml4LFxuICAgICAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhcmVsYXRlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgIT09IHRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhalF1ZXJ5LmNvbnRhaW5zKHRhcmdldCwgcmVsYXRlZClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBmaXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBvbjogZnVuY3Rpb24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIG9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xuICAgICAgICB9LFxuICAgICAgICBvbmU6IGZ1bmN0aW9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBvbih0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2ZmOiBmdW5jdGlvbih0eXBlcywgc2VsZWN0b3IsIGZuKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqLCB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaikge1xuICAgICAgICAgICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICB0eXBlcy5kZWxlZ2F0ZVRhcmdldFxuICAgICAgICAgICAgICAgICkub2ZmKGhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsIGhhbmRsZU9iai5zZWxlY3RvciwgaGFuZGxlT2JqLmhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG4gICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vICggdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUodGhpcywgdHlwZXMsIGZuLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcbiAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuICAgICAgICAvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcbiAgICAgICAgLy8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG4gICAgICAgIHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcbiAgICAgICAgcnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcbiAgICAgICAgcmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4gICAgZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KGVsZW0sIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwidGFibGVcIikgJiZcbiAgICAgICAgICAgICAgICBqUXVlcnkubm9kZU5hbWUoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgXCJ0clwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbiAgICBmdW5jdGlvbiBkaXNhYmxlU2NyaXB0KGVsZW0pIHtcbiAgICAgICAgZWxlbS50eXBlID0gKGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoZWxlbSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKGVsZW0udHlwZSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBlbGVtLnR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KHNyYywgZGVzdCkge1xuICAgICAgICB2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuICAgICAgICBpZiAoZGVzdC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cbiAgICAgICAgaWYgKGRhdGFQcml2Lmhhc0RhdGEoc3JjKSkge1xuICAgICAgICAgICAgcGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3Moc3JjKTtcbiAgICAgICAgICAgIHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KGRlc3QsIHBkYXRhT2xkKTtcbiAgICAgICAgICAgIGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG4gICAgICAgICAgICAgICAgcGRhdGFDdXIuZXZlbnRzID0ge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBldmVudHNbdHlwZV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKGRlc3QsIHR5cGUsIGV2ZW50c1t0eXBlXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBDb3B5IHVzZXIgZGF0YVxuICAgICAgICBpZiAoZGF0YVVzZXIuaGFzRGF0YShzcmMpKSB7XG4gICAgICAgICAgICB1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2VzcyhzcmMpO1xuICAgICAgICAgICAgdWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKHt9LCB1ZGF0YU9sZCk7XG5cbiAgICAgICAgICAgIGRhdGFVc2VyLnNldChkZXN0LCB1ZGF0YUN1cik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbiAgICBmdW5jdGlvbiBmaXhJbnB1dChzcmMsIGRlc3QpIHtcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KHNyYy50eXBlKSkge1xuICAgICAgICAgICAgZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG4gICAgICAgICAgICAvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIikge1xuICAgICAgICAgICAgZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9tTWFuaXAoY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQpIHtcbiAgICAgICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuICAgICAgICBhcmdzID0gY29uY2F0LmFwcGx5KFtdLCBhcmdzKTtcblxuICAgICAgICB2YXIgZnJhZ21lbnQsXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIHNjcmlwdHMsXG4gICAgICAgICAgICBoYXNTY3JpcHRzLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaU5vQ2xvbmUgPSBsIC0gMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSk7XG5cbiAgICAgICAgLy8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICBsID4gMSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXN1cHBvcnQuY2hlY2tDbG9uZSAmJlxuICAgICAgICAgICAgICAgICAgICByY2hlY2tlZC50ZXN0KHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbU1hbmlwKHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudChcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bMF0ub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGlnbm9yZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZmlyc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKGZpcnN0IHx8IGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcChnZXRBbGwoZnJhZ21lbnQsIFwic2NyaXB0XCIpLCBkaXNhYmxlU2NyaXB0KTtcbiAgICAgICAgICAgICAgICBoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG4gICAgICAgICAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGlOb0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKG5vZGUsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2Uoc2NyaXB0cywgZ2V0QWxsKG5vZGUsIFwic2NyaXB0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29sbGVjdGlvbltpXSwgbm9kZSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1NjcmlwdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVlbmFibGUgc2NyaXB0c1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWFwKHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNjcmlwdFR5cGUudGVzdChub2RlLnR5cGUgfHwgXCJcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWRhdGFQcml2LmFjY2Vzcyhub2RlLCBcImdsb2JhbEV2YWxcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNvbnRhaW5zKGRvYywgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Ll9ldmFsVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2V2YWxVcmwobm9kZS5zcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRE9NRXZhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZShyY2xlYW5TY3JpcHQsIFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSkge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgIG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCBlbGVtKSA6IGVsZW0sXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBmb3IgKDsgKG5vZGUgPSBub2Rlc1tpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChub2RlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbChnZXRBbGwobm9kZSwgXCJzY3JpcHRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShyeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgc3JjRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgaW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSk7XG5cbiAgICAgICAgICAgIC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmXG4gICAgICAgICAgICAgICAgICAgIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJlxuICAgICAgICAgICAgICAgICAgICAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcbiAgICAgICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBnZXRBbGwoY2xvbmUpO1xuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKGVsZW0pO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaXhJbnB1dChzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcbiAgICAgICAgICAgIGlmIChkYXRhQW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZXBEYXRhQW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKGNsb25lKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudChzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KGVsZW0sIGNsb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbChjbG9uZSwgXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBpZiAoZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoZWxlbSwgXCJzY3JpcHRcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW5EYXRhOiBmdW5jdGlvbihlbGVtcykge1xuICAgICAgICAgICAgdmFyIGRhdGEsIGVsZW0sIHR5cGUsIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCwgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyAoZWxlbSA9IGVsZW1zW2ldKSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjZXB0RGF0YShlbGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9IGVsZW1bZGF0YVByaXYuZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiBkYXRhLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbFt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bZGF0YVByaXYuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1bZGF0YVVzZXIuZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bZGF0YVVzZXIuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8galF1ZXJ5LnRleHQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gOVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KHRoaXMsIGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPT09IDlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCh0aGlzLCBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSwgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKGVsZW0sIGZhbHNlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuICAgICAgICAgICAgZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBkYXRhQW5kRXZlbnRzXG4gICAgICAgICAgICAgICAgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY2xvbmUodGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdIHx8IHt9LCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXJub0lubmVyaHRtbC50ZXN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICF3cmFwTWFwWyhydGFnTmFtZS5leGVjKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFwiXCIsIFwiXCIgXSlbMV0udG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1tpXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKGVsZW0sIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eSgpLmFwcGVuZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlnbm9yZWQgPSBbXTtcblxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaW5BcnJheSh0aGlzLCBpZ25vcmVkKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsZW0sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlnbm9yZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5lYWNoKFxuICAgICAgICB7XG4gICAgICAgICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcbiAgICAgICAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG4gICAgICAgICAgICBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG4gICAgICAgICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuICAgICAgICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtcyxcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IGpRdWVyeShzZWxlY3RvciksXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8PSBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeShpbnNlcnRbaV0pW29yaWdpbmFsXShlbGVtcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXQsIGVsZW1zLmdldCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2socmV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICApO1xuICAgIHZhciBybWFyZ2luID0gL15tYXJnaW4vO1xuXG4gICAgdmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiKTtcblxuICAgIHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcbiAgICAgICAgLy8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG4gICAgICAgIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICAgICAgICB2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgICAgICBpZiAoIXZpZXcgfHwgIXZpZXcub3BlbmVyKSB7XG4gICAgICAgICAgICB2aWV3ID0gd2luZG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICB9O1xuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcbiAgICAgICAgLy8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG4gICAgICAgICAgICBpZiAoIWRpdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcbiAgICAgICAgICAgICAgICBcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuICAgICAgICAgICAgICAgIFwidG9wOjElO3dpZHRoOjUwJVwiO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZGl2KTtcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcbiAgICAgICAgICAgIGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcbiAgICAgICAgICAgIC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuICAgICAgICAgICAgZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcbiAgICAgICAgICAgIHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcbiAgICAgICAgICAgIGRpdiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGl4ZWxQb3NpdGlvblZhbCxcbiAgICAgICAgICAgIGJveFNpemluZ1JlbGlhYmxlVmFsLFxuICAgICAgICAgICAgcGl4ZWxNYXJnaW5SaWdodFZhbCxcbiAgICAgICAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG4gICAgICAgIGlmICghZGl2LnN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgIC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuICAgICAgICBkaXYuY2xvbmVOb2RlKHRydWUpLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcbiAgICAgICAgc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuICAgICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG4gICAgICAgICAgICBcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgICAgICBqUXVlcnkuZXh0ZW5kKHN1cHBvcnQsIHtcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG5cbiAgICBmdW5jdGlvbiBjdXJDU1MoZWxlbSwgbmFtZSwgY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCwgc3R5bGUgPSBlbGVtLnN0eWxlO1xuXG4gICAgICAgIGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKGVsZW0pO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFtuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcbiAgICAgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuICAgICAgICAgICAgLy8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmXG4gICAgICAgICAgICAgICAgICAgIHJudW1ub25weC50ZXN0KHJldCkgJiZcbiAgICAgICAgICAgICAgICAgICAgcm1hcmdpbi50ZXN0KG5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgICAgICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID8gLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgICAgLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cbiAgICAgICAgICAgIHJldCArIFwiXCIgOiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkR2V0SG9va0lmKGNvbmRpdGlvbkZuLCBob29rRm4pIHtcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbkZuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgLy8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuICAgIC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuICAgIC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuICAgIHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcbiAgICAgICAgY3NzU2hvdyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICAgIH0sXG4gICAgICAgIGNzc05vcm1hbFRyYW5zZm9ybSA9IHsgbGV0dGVyU3BhY2luZzogXCIwXCIsIGZvbnRXZWlnaHQ6IFwiNDAwXCIgfSxcbiAgICAgICAgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuICAgICAgICBlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZTtcblxuICAgIC8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZShuYW1lKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG4gICAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuICAgICAgICB2YXIgY2FwTmFtZSA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIG5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlcihlbGVtLCB2YWx1ZSwgc3VidHJhY3QpIHtcbiAgICAgICAgLy8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuICAgICAgICAvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgdmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWModmFsdWUpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1xuICAgICAgICAgICAgPyAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuICAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF0Y2hlc1syXSAtIChzdWJ0cmFjdCB8fCAwKSkgKyAobWF0Y2hlc1szXSB8fCBcInB4XCIpXG4gICAgICAgICAgICA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzKSB7XG4gICAgICAgIHZhciBpLCB2YWwgPSAwO1xuXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuICAgICAgICBpZiAoZXh0cmEgPT09IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHtcbiAgICAgICAgICAgIGkgPSA0O1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCA0OyBpICs9IDIpIHtcbiAgICAgICAgICAgIC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcbiAgICAgICAgICAgIGlmIChleHRyYSA9PT0gXCJtYXJnaW5cIikge1xuICAgICAgICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICAgICAgICAvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEgPT09IFwiY29udGVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCAtPSBqUXVlcnkuY3NzKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhICE9PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCAtPSBqUXVlcnkuY3NzKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbaV0gKyBcIldpZHRoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuICAgICAgICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuICAgICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gXCJwYWRkaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IGpRdWVyeS5jc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJib3JkZXJcIiArIGNzc0V4cGFuZFtpXSArIFwiV2lkdGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEpIHtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcbiAgICAgICAgdmFyIHZhbCxcbiAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pLFxuICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PVxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJveFwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG4gICAgICAgIC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgaWYgKGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcbiAgICAgICAgLy8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG4gICAgICAgIC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuICAgICAgICBpZiAodmFsIDw9IDAgfHwgdmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XG4gICAgICAgICAgICBpZiAodmFsIDwgMCB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGVsZW0uc3R5bGVbbmFtZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG4gICAgICAgICAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG4gICAgICAgICAgICAvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG4gICAgICAgICAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcbiAgICAgICAgICAgICAgICAoc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVtuYW1lXSk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcbiAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcbiAgICAgICAgcmV0dXJuIHZhbCArXG4gICAgICAgICAgICBhdWdtZW50V2lkdGhPckhlaWdodChcbiAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSxcbiAgICAgICAgICAgICAgICB2YWx1ZUlzQm9yZGVyQm94LFxuICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgKSArXG4gICAgICAgICAgICBcInB4XCI7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcbiAgICAgICAgY3NzSG9va3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGVsZW0sIGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBjdXJDU1MoZWxlbSwgXCJvcGFjaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuICAgICAgICBjc3NOdW1iZXI6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICAgICAgICAgICAgY29sdW1uQ291bnQ6IHRydWUsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgICAgICAgICAgIGZsZXhHcm93OiB0cnVlLFxuICAgICAgICAgICAgZmxleFNocmluazogdHJ1ZSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgb3BhY2l0eTogdHJ1ZSxcbiAgICAgICAgICAgIG9yZGVyOiB0cnVlLFxuICAgICAgICAgICAgb3JwaGFuczogdHJ1ZSxcbiAgICAgICAgICAgIHdpZG93czogdHJ1ZSxcbiAgICAgICAgICAgIHpJbmRleDogdHJ1ZSxcbiAgICAgICAgICAgIHpvb206IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuICAgICAgICAvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG4gICAgICAgIGNzc1Byb3BzOiB7IGZsb2F0OiBcImNzc0Zsb2F0XCIgfSxcbiAgICAgICAgLy8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcbiAgICAgICAgc3R5bGU6IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSkge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWVsZW0gfHxcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fFxuICAgICAgICAgICAgICAgICAgICBlbGVtLm5vZGVUeXBlID09PSA4IHx8XG4gICAgICAgICAgICAgICAgICAgICFlbGVtLnN0eWxlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgICAgICAgdmFyIHJldCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGhvb2tzLFxuICAgICAgICAgICAgICAgIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShuYW1lKSxcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGU7XG5cbiAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbb3JpZ05hbWVdIHx8XG4gICAgICAgICAgICAgICAgKGpRdWVyeS5jc3NQcm9wc1tvcmlnTmFtZV0gPSB2ZW5kb3JQcm9wTmFtZShvcmlnTmFtZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ05hbWUpO1xuXG4gICAgICAgICAgICAvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV0gfHwgalF1ZXJ5LmNzc0hvb2tzW29yaWdOYW1lXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSByY3NzTnVtLmV4ZWModmFsdWUpKSAmJiByZXRbMV1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhZGp1c3RDU1MoZWxlbSwgbmFtZSwgcmV0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlcyBidWcgIzkyMzdcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHJldCAmJiByZXRbM10gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChqUXVlcnkuY3NzTnVtYmVyW29yaWdOYW1lXSA/IFwiXCIgOiBcInB4XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IFwiXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuaW5kZXhPZihcImJhY2tncm91bmRcIikgPT09IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbbmFtZV0gPSBcImluaGVyaXRcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFob29rcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIShcInNldFwiIGluIGhvb2tzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBleHRyYSkpICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2V0XCIgaW4gaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXQgPSBob29rcy5nZXQoZWxlbSwgZmFsc2UsIGV4dHJhKSkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjc3M6IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWwsIG51bSwgaG9va3MsIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShuYW1lKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSB8fFxuICAgICAgICAgICAgICAgIChqUXVlcnkuY3NzUHJvcHNbb3JpZ05hbWVdID0gdmVuZG9yUHJvcE5hbWUob3JpZ05hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIG9yaWdOYW1lKTtcblxuICAgICAgICAgICAgLy8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV0gfHwgalF1ZXJ5LmNzc0hvb2tzW29yaWdOYW1lXTtcblxuICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcbiAgICAgICAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gaG9va3MuZ2V0KGVsZW0sIHRydWUsIGV4dHJhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bbmFtZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuICAgICAgICAgICAgaWYgKGV4dHJhID09PSBcIlwiIHx8IGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgbnVtID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZShudW0pID8gbnVtIHx8IDAgOiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZWFjaChbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgICAgIGpRdWVyeS5jc3NIb29rc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oZWxlbSwgY29tcHV0ZWQsIGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHJkaXNwbGF5c3dhcC50ZXN0KGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUsIGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyhlbGVtKSxcbiAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QgPSBleHRyYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcykgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoZXMgPSByY3NzTnVtLmV4ZWModmFsdWUpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoZXNbM10gfHwgXCJweFwiKSAhPT0gXCJweFwiXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkuY3NzKGVsZW0sIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRQb3NpdGl2ZU51bWJlcihlbGVtLCB2YWx1ZSwgc3VidHJhY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoXG4gICAgICAgIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuICAgICAgICBmdW5jdGlvbihlbGVtLCBjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KGN1ckNTUyhlbGVtLCBcIm1hcmdpbkxlZnRcIikpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwKGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpICtcbiAgICAgICAgICAgICAgICAgICAgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbiAgICBqUXVlcnkuZWFjaCh7IG1hcmdpbjogXCJcIiwgcGFkZGluZzogXCJcIiwgYm9yZGVyOiBcIldpZHRoXCIgfSwgZnVuY3Rpb24oXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgc3VmZml4XG4gICAgKSB7XG4gICAgICAgIGpRdWVyeS5jc3NIb29rc1twcmVmaXggKyBzdWZmaXhdID0ge1xuICAgICAgICAgICAgZXhwYW5kOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlLnNwbGl0KFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbIHZhbHVlIF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZFtwcmVmaXggKyBjc3NFeHBhbmRbaV0gKyBzdWZmaXhdID0gcGFydHNbaV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzW2kgLSAyXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghcm1hcmdpbi50ZXN0KHByZWZpeCkpIHtcbiAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1twcmVmaXggKyBzdWZmaXhdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgY3NzOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZXMsIGxlbiwgbWFwID0ge30sIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBbbmFtZVtpXV0gPSBqUXVlcnkuY3NzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGpRdWVyeS5zdHlsZShlbGVtLCBuYW1lLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogalF1ZXJ5LmNzcyhlbGVtLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIFR3ZWVuKGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcpO1xuICAgIH1cbiAgICBqUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFR3ZWVuLFxuICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1t0aGlzLnByb3BdO1xuXG4gICAgICAgICAgICByZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0XG4gICAgICAgICAgICAgICAgPyBob29rcy5nZXQodGhpcylcbiAgICAgICAgICAgICAgICA6IFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bjogZnVuY3Rpb24ocGVyY2VudCkge1xuICAgICAgICAgICAgdmFyIGVhc2VkLCBob29rcyA9IFR3ZWVuLnByb3BIb29rc1t0aGlzLnByb3BdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbdGhpcy5lYXNpbmddKFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob29rcyAmJiBob29rcy5zZXQpIHtcbiAgICAgICAgICAgICAgICBob29rcy5zZXQodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cbiAgICBUd2Vlbi5wcm9wSG9va3MgPSB7XG4gICAgICAgIF9kZWZhdWx0OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW0uc3R5bGVbdHdlZW4ucHJvcF0gPT0gbnVsbFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0galF1ZXJ5LmNzcyh0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiKTtcblxuICAgICAgICAgICAgICAgIC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odHdlZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cbiAgICAgICAgICAgICAgICAvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmZ4LnN0ZXBbdHdlZW4ucHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0ZXBbdHdlZW4ucHJvcF0odHdlZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0d2Vlbi5lbGVtLnN0eWxlW2pRdWVyeS5jc3NQcm9wc1t0d2Vlbi5wcm9wXV0gIT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW3R3ZWVuLnByb3BdKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgIC8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuICAgIFR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0d2Vlbikge1xuICAgICAgICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSA9IHR3ZWVuLm5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZWFzaW5nID0ge1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICBzd2luZzogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGguY29zKHAgKiBNYXRoLlBJKSAvIDI7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWZhdWx0OiBcInN3aW5nXCJcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbiAgICAvLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxuICAgIGpRdWVyeS5meC5zdGVwID0ge307XG5cbiAgICB2YXIgZnhOb3csXG4gICAgICAgIHRpbWVySWQsXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgICAgICBycnVuID0gL3F1ZXVlSG9va3MkLztcblxuICAgIGZ1bmN0aW9uIHJhZigpIHtcbiAgICAgICAgaWYgKHRpbWVySWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICAgICAgICAgIGpRdWVyeS5meC50aWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG4gICAgZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnhOb3cgPSBqUXVlcnkubm93KCk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbiAgICBmdW5jdGlvbiBnZW5GeCh0eXBlLCBpbmNsdWRlV2lkdGgpIHtcbiAgICAgICAgdmFyIHdoaWNoLCBpID0gMCwgYXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG4gICAgICAgIC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcbiAgICAgICAgaW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG4gICAgICAgIGZvciAoOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoKSB7XG4gICAgICAgICAgICB3aGljaCA9IGNzc0V4cGFuZFtpXTtcbiAgICAgICAgICAgIGF0dHJzW1wibWFyZ2luXCIgKyB3aGljaF0gPSBhdHRyc1tcInBhZGRpbmdcIiArIHdoaWNoXSA9IHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jbHVkZVdpZHRoKSB7XG4gICAgICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHZhbHVlLCBwcm9wLCBhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIHR3ZWVuLFxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IChBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gfHwgW10pLmNvbmNhdChcbiAgICAgICAgICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbXCIqXCJdXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHR3ZWVuID0gY29sbGVjdGlvbltpbmRleF0uY2FsbChhbmltYXRpb24sIHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlcihlbGVtLCBwcm9wcywgb3B0cykge1xuICAgICAgICB2YXIgcHJvcCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdG9nZ2xlLFxuICAgICAgICAgICAgaG9va3MsXG4gICAgICAgICAgICBvbGRmaXJlLFxuICAgICAgICAgICAgcHJvcFR3ZWVuLFxuICAgICAgICAgICAgcmVzdG9yZURpc3BsYXksXG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICAgICAgaXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcbiAgICAgICAgICAgIGFuaW0gPSB0aGlzLFxuICAgICAgICAgICAgb3JpZyA9IHt9LFxuICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlLFxuICAgICAgICAgICAgaGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoZWxlbSksXG4gICAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmdldChlbGVtLCBcImZ4c2hvd1wiKTtcblxuICAgICAgICAvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3NcbiAgICAgICAgaWYgKCFvcHRzLnF1ZXVlKSB7XG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCBcImZ4XCIpO1xuICAgICAgICAgICAgaWYgKGhvb2tzLnVucXVldWVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy51bnF1ZXVlZCA9IDA7XG4gICAgICAgICAgICAgICAgb2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG4gICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhvb2tzLnVucXVldWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQrKztcblxuICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcbiAgICAgICAgICAgICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkucXVldWUoZWxlbSwgXCJmeFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgZm9yIChwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHJmeHR5cGVzLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IChoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBcInNob3dcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTaG93ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNob3dbcHJvcF0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmlnW3Byb3BdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbcHJvcF0gfHxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcbiAgICAgICAgcHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3BzKTtcbiAgICAgICAgaWYgKCFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3Qob3JpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuICAgICAgICBpZiAoaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuICAgICAgICAgICAgLy8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG4gICAgICAgICAgICAvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WVxuICAgICAgICAgICAgb3B0cy5vdmVyZmxvdyA9IFtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyxcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvd1gsXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dZXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcbiAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcbiAgICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJkaXNwbGF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RvcmVEaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKFsgZWxlbSBdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0hpZGUoWyBlbGVtIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuY3NzKGVsZW0sIFwiZmxvYXRcIikgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdG9yZURpc3BsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5vdmVyZmxvdykge1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WzBdO1xuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbMV07XG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1syXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG4gICAgICAgIHByb3BUd2VlbiA9IGZhbHNlO1xuICAgICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xuICAgICAgICAgICAgLy8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICghcHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImhpZGRlblwiIGluIGRhdGFTaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyhlbGVtLCBcImZ4c2hvd1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiByZXN0b3JlRGlzcGxheVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcbiAgICAgICAgICAgICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cbiAgICAgICAgICAgICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKFsgZWxlbSBdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0hpZGUoWyBlbGVtIF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBcImZ4c2hvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIG9yaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wLCBvcmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXItcHJvcGVydHkgc2V0dXBcbiAgICAgICAgICAgIHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKGhpZGRlbiA/IGRhdGFTaG93W3Byb3BdIDogMCwgcHJvcCwgYW5pbSk7XG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIGRhdGFTaG93KSkge1xuICAgICAgICAgICAgICAgIGRhdGFTaG93W3Byb3BdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR3ZWVuLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9wRmlsdGVyKHByb3BzLCBzcGVjaWFsRWFzaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cbiAgICAgICAgLy8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG4gICAgICAgIGZvciAoaW5kZXggaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKGluZGV4KTtcbiAgICAgICAgICAgIGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbbmFtZV07XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvb2tzLmV4cGFuZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgLy8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuICAgICAgICAgICAgICAgIC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGluZGV4IGluIHByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbaW5kZXhdID0gdmFsdWVbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tpbmRleF0gPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbbmFtZV0gPSBlYXNpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBbmltYXRpb24oZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgc3RvcHBlZCxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aWNrLmVsZW07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5NylcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMSAtIHRlbXAsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKHBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdKTtcblxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChlbGVtLCBbIGFuaW1hdGlvbiBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICAgICAgICAgIHByb3BzOiBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKSxcbiAgICAgICAgICAgICAgICBvcHRzOiBqUXVlcnkuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB7IHNwZWNpYWxFYXNpbmc6IHt9LCBlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQgfSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHdlZW5zOiBbXSxcbiAgICAgICAgICAgICAgICBjcmVhdGVUd2VlbjogZnVuY3Rpb24ocHJvcCwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nW3Byb3BdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuZWFzaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnMucHVzaCh0d2Vlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKGdvdG9FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdvdG9FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuICAgICAgICBwcm9wRmlsdGVyKHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nKTtcblxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzW2luZGV4XS5jYWxsKFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5vcHRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihyZXN1bHQuc3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgICAgICAgICAgICAgICAgICApLnN0b3AgPSBqUXVlcnkucHJveHkocmVzdWx0LnN0b3AsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqUXVlcnkubWFwKHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uKTtcblxuICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oYW5pbWF0aW9uLm9wdHMuc3RhcnQpKSB7XG4gICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKGVsZW0sIGFuaW1hdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBqUXVlcnkuZngudGltZXIoXG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRpY2ssIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICAgICAgICAgIGFuaW06IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICBxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvblxuICAgICAgICAgICAgLnByb2dyZXNzKGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzKVxuICAgICAgICAgICAgLmRvbmUoYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUpXG4gICAgICAgICAgICAuZmFpbChhbmltYXRpb24ub3B0cy5mYWlsKVxuICAgICAgICAgICAgLmFsd2F5cyhhbmltYXRpb24ub3B0cy5hbHdheXMpO1xuICAgIH1cblxuICAgIGpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKEFuaW1hdGlvbiwge1xuICAgICAgICB0d2VlbmVyczoge1xuICAgICAgICAgICAgXCIqXCI6IFtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0Q1NTKHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyh2YWx1ZSksIHR3ZWVuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgdHdlZW5lcjogZnVuY3Rpb24ocHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwcm9wcztcbiAgICAgICAgICAgICAgICBwcm9wcyA9IFsgXCIqXCIgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5tYXRjaChybm90aHRtbHdoaXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3AsIGluZGV4ID0gMCwgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXSA9IEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0udW5zaGlmdChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuICAgICAgICBwcmVmaWx0ZXI6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcmVwZW5kKSB7XG4gICAgICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oc3BlZWQsIGVhc2luZywgZm4pIHtcbiAgICAgICAgdmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgPyBqUXVlcnkuZXh0ZW5kKHt9LCBzcGVlZClcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmbiB8fFxuICAgICAgICAgICAgICAgICAgICAhZm4gJiYgZWFzaW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0Z1bmN0aW9uKHNwZWVkKSAmJiBzcGVlZCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogc3BlZWQsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbihlYXNpbmcpICYmIGVhc2luZ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmYgb3IgaWYgZG9jdW1lbnQgaXMgaGlkZGVuXG4gICAgICAgIGlmIChqUXVlcnkuZngub2ZmIHx8IGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbb3B0LmR1cmF0aW9uXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuICAgICAgICBpZiAob3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHQucXVldWUgPSBcImZ4XCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBRdWV1ZWluZ1xuICAgICAgICBvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG4gICAgICAgIG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKG9wdC5vbGQpKSB7XG4gICAgICAgICAgICAgICAgb3B0Lm9sZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0LnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgb3B0LnF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgZmFkZVRvOiBmdW5jdGlvbihzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGlzSGlkZGVuV2l0aGluVHJlZSlcbiAgICAgICAgICAgICAgICAuY3NzKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgIC5zaG93KClcbiAgICAgICAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAgICAgICAuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24ocHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3ApLFxuICAgICAgICAgICAgICAgIG9wdGFsbCA9IGpRdWVyeS5zcGVlZChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayksXG4gICAgICAgICAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW0gPSBBbmltYXRpb24odGhpcywgalF1ZXJ5LmV4dGVuZCh7fSwgcHJvcCksIG9wdGFsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eSB8fCBkYXRhUHJpdi5nZXQodGhpcywgXCJmaW5pc2hcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICA/IHRoaXMuZWFjaChkb0FuaW1hdGlvbilcbiAgICAgICAgICAgICAgICA6IHRoaXMucXVldWUob3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uKHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQpIHtcbiAgICAgICAgICAgIHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbihob29rcykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBzdG9wKGdvdG9FbmQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XG4gICAgICAgICAgICAgICAgY2xlYXJRdWV1ZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXF1ZXVlID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVByaXYuZ2V0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2luZGV4XSAmJiBkYXRhW2luZGV4XS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wUXVldWUoZGF0YVtpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbmRleCBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCAmJiBycnVuLnRlc3QoaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wUXVldWUoZGF0YVtpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1tpbmRleF0ucXVldWUgPT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzW2luZGV4XS5hbmltLnN0b3AoZ290b0VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXF1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG4gICAgICAgICAgICAgICAgLy8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cbiAgICAgICAgICAgICAgICBpZiAoZGVxdWV1ZSB8fCAhZ290b0VuZCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFQcml2LmdldCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhW3R5cGUgKyBcInF1ZXVlXCJdLFxuICAgICAgICAgICAgICAgICAgICBob29rcyA9IGRhdGFbdHlwZSArIFwicXVldWVIb29rc1wiXSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuICAgICAgICAgICAgICAgIGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuICAgICAgICAgICAgICAgIGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBbXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaG9va3MgJiYgaG9va3Muc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBob29rcy5zdG9wLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1tpbmRleF0ucXVldWUgPT09IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlW2luZGV4XSAmJiBxdWV1ZVtpbmRleF0uZmluaXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpbmRleF0uZmluaXNoLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmZpbmlzaDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZWFjaChbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgICAgIHZhciBjc3NGbiA9IGpRdWVyeS5mbltuYW1lXTtcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24oc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgICA/IGNzc0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICA6IHRoaXMuYW5pbWF0ZShnZW5GeChuYW1lLCB0cnVlKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xuICAgIGpRdWVyeS5lYWNoKFxuICAgICAgICB7XG4gICAgICAgICAgICBzbGlkZURvd246IGdlbkZ4KFwic2hvd1wiKSxcbiAgICAgICAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcbiAgICAgICAgICAgIHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcbiAgICAgICAgICAgIGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuICAgICAgICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuICAgICAgICAgICAgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24obmFtZSwgcHJvcHMpIHtcbiAgICAgICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBqUXVlcnkudGltZXJzID0gW107XG4gICAgalF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpbWVyLCBpID0gMCwgdGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuICAgICAgICBmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuICAgICAgICBmb3IgKDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbaV07XG5cbiAgICAgICAgICAgIC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgaWYgKCF0aW1lcigpICYmIHRpbWVyc1tpXSA9PT0gdGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKChpLS0pLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGltZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24odGltZXIpIHtcbiAgICAgICAgalF1ZXJ5LnRpbWVycy5wdXNoKHRpbWVyKTtcbiAgICAgICAgaWYgKHRpbWVyKCkpIHtcbiAgICAgICAgICAgIGpRdWVyeS5meC5zdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgalF1ZXJ5LnRpbWVycy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbiAgICBqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aW1lcklkKSB7XG4gICAgICAgICAgICB0aW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyYWYpXG4gICAgICAgICAgICAgICAgOiB3aW5kb3cuc2V0SW50ZXJ2YWwoalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRpbWVySWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lcklkID0gbnVsbDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnNwZWVkcyA9IHtcbiAgICAgICAgc2xvdzogNjAwLFxuICAgICAgICBmYXN0OiAyMDAsXG4gICAgICAgIC8vIERlZmF1bHQgc3BlZWRcbiAgICAgICAgX2RlZmF1bHQ6IDQwMFxuICAgIH07XG5cbiAgICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4gICAgLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbiAgICBqUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbih0aW1lLCB0eXBlKSB7XG4gICAgICAgIHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzW3RpbWVdIHx8IHRpbWUgOiB0aW1lO1xuICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSwgZnVuY3Rpb24obmV4dCwgaG9va3MpIHtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQobmV4dCwgdGltZSk7XG4gICAgICAgICAgICBob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXG4gICAgICAgICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSk7XG5cbiAgICAgICAgaW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG4gICAgICAgIHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuICAgICAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBcInRcIjtcbiAgICAgICAgaW5wdXQudHlwZSA9IFwicmFkaW9cIjtcbiAgICAgICAgc3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuICAgIH0pKCk7XG5cbiAgICB2YXIgYm9vbEhvb2ssIGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKHRoaXMsIG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBhdHRyOiBmdW5jdGlvbihlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJldCwgaG9va3MsIG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuICAgICAgICAgICAgaWYgKG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkucHJvcChlbGVtLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICAgICAgICAgIC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzW25hbWUudG9Mb3dlckNhc2UoKV0gfHxcbiAgICAgICAgICAgICAgICAgICAgKGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdChuYW1lKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoZWxlbSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocmV0ID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlICsgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJnZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIG5hbWUpKSAhPT0gbnVsbFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBuYW1lKTtcblxuICAgICAgICAgICAgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgYXR0ckhvb2tzOiB7XG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4gICAgICAgICAgICAgICAgYXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSk7XG5cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuYW1lID0gYXR0ck5hbWVzW2krK10pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgYm9vbEhvb2sgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoZWxlbSwgbmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmVhY2goalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IGF0dHJIYW5kbGVbbmFtZV0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuICAgICAgICBhdHRySGFuZGxlW25hbWVdID0gZnVuY3Rpb24oZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICAgIHZhciByZXQsIGhhbmRsZSwgbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBhdHRySGFuZGxlW2xvd2VyY2FzZU5hbWVdO1xuICAgICAgICAgICAgICAgIGF0dHJIYW5kbGVbbG93ZXJjYXNlTmFtZV0gPSByZXQ7XG4gICAgICAgICAgICAgICAgcmV0ID0gZ2V0dGVyKGVsZW0sIG5hbWUsIGlzWE1MKSAhPSBudWxsID8gbG93ZXJjYXNlTmFtZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXSA9IGhhbmRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG4gICAgICAgIHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgcHJvcDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbalF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIHByb3A6IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcywgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG4gICAgICAgICAgICBpZiAoblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgLy8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuICAgICAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1tuYW1lXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocmV0ID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImdldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXQgPSBob29rcy5nZXQoZWxlbSwgbmFtZSkpICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcEhvb2tzOiB7XG4gICAgICAgICAgICB0YWJJbmRleDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgXCJ0YWJpbmRleFwiKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0YWJpbmRleCwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmZvY3VzYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmNsaWNrYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpICYmIGVsZW0uaHJlZlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvcEZpeDogeyBmb3I6IFwiaHRtbEZvclwiLCBjbGFzczogXCJjbGFzc05hbWVcIiB9XG4gICAgfSk7XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbiAgICAvLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4gICAgLy8gb24gdGhlIG9wdGlvblxuICAgIC8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4gICAgLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuICAgIC8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuICAgIC8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuICAgIGlmICghc3VwcG9ydC5vcHRTZWxlY3RlZCkge1xuICAgICAgICBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZWFjaChcbiAgICAgICAgW1xuICAgICAgICAgICAgXCJ0YWJJbmRleFwiLFxuICAgICAgICAgICAgXCJyZWFkT25seVwiLFxuICAgICAgICAgICAgXCJtYXhMZW5ndGhcIixcbiAgICAgICAgICAgIFwiY2VsbFNwYWNpbmdcIixcbiAgICAgICAgICAgIFwiY2VsbFBhZGRpbmdcIixcbiAgICAgICAgICAgIFwicm93U3BhblwiLFxuICAgICAgICAgICAgXCJjb2xTcGFuXCIsXG4gICAgICAgICAgICBcInVzZU1hcFwiLFxuICAgICAgICAgICAgXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICAgICAgXCJjb250ZW50RWRpdGFibGVcIlxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGpRdWVyeS5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG4gICAgZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSh2YWx1ZSkge1xuICAgICAgICB2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG4gICAgICAgIHJldHVybiB0b2tlbnMuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2xhc3MoZWxlbSkge1xuICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgIH1cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSwgaSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLmFkZENsYXNzKHZhbHVlLmNhbGwodGhpcywgaiwgZ2V0Q2xhc3ModGhpcykpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtID0gdGhpc1tpKytdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3MoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShjdXJWYWx1ZSkgKyBcIiBcIjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjbGF6eiA9IGNsYXNzZXNbaisrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIuaW5kZXhPZihcIiBcIiArIGNsYXp6ICsgXCIgXCIpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZShjdXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBmaW5hbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLCBpID0gMDtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgICkucmVtb3ZlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCBnZXRDbGFzcyh0aGlzKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbSA9IHRoaXNbaSsrXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJWYWx1ZSA9IGdldENsYXNzKGVsZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShjdXJWYWx1ZSkgKyBcIiBcIjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjbGF6eiA9IGNsYXNzZXNbaisrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGZpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKHZhbHVlLCBzdGF0ZVZhbCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVWYWxcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmFkZENsYXNzKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMucmVtb3ZlQ2xhc3ModmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgKS50b2dnbGVDbGFzcyh2YWx1ZS5jYWxsKHRoaXMsIGksIGdldENsYXNzKHRoaXMpLCBzdGF0ZVZhbCksIHN0YXRlVmFsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpKytdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGFQcml2LmdldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUsIGVsZW0sIGkgPSAwO1xuXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbSA9IHRoaXNbaSsrXSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShnZXRDbGFzcyhlbGVtKSkgKyBcIiBcIikuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICkgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcnJldHVybiA9IC9cXHIvZztcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICB2YWw6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbiwgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW2VsZW0udHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS52YWxIb29rc1tlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXQgPSBob29rcy5nZXQoZWxlbSwgXCJ2YWx1ZVwiKSkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXQgPSBlbGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZS5jYWxsKHRoaXMsIGksIGpRdWVyeSh0aGlzKS52YWwoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpRdWVyeS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW3RoaXMudHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWhvb2tzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhKFwic2V0XCIgaW4gaG9va3MpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rcy5zZXQodGhpcywgdmFsLCBcInZhbHVlXCIpID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIHZhbEhvb2tzOiB7XG4gICAgICAgICAgICBvcHRpb246IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsIDogLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXBBbmRDb2xsYXBzZShqUXVlcnkudGV4dChlbGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gb25lID8gaW5kZXggOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhb3B0aW9uLmRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFqUXVlcnkubm9kZU5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcHRncm91cFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KG9wdGlvbikudmFsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvblNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldChvcHRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG4gICAgalF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdID0ge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KGVsZW0pLnZhbCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKSA+XG4gICAgICAgICAgICAgICAgICAgICAgICAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghc3VwcG9ydC5jaGVja09uKSB7XG4gICAgICAgICAgICBqUXVlcnkudmFsSG9va3NbdGhpc10uZ2V0ID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cbiAgICB2YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbiAgICBqUXVlcnkuZXh0ZW5kKGpRdWVyeS5ldmVudCwge1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbihldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBjdXIsXG4gICAgICAgICAgICAgICAgdG1wLFxuICAgICAgICAgICAgICAgIGJ1YmJsZVR5cGUsXG4gICAgICAgICAgICAgICAgb250eXBlLFxuICAgICAgICAgICAgICAgIGhhbmRsZSxcbiAgICAgICAgICAgICAgICBzcGVjaWFsLFxuICAgICAgICAgICAgICAgIGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBoYXNPd24uY2FsbChldmVudCwgXCJ0eXBlXCIpID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbChldmVudCwgXCJuYW1lc3BhY2VcIilcbiAgICAgICAgICAgICAgICAgICAgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgIDogW107XG5cbiAgICAgICAgICAgIGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICAvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG4gICAgICAgICAgICBpZiAocmZvY3VzTW9ycGgudGVzdCh0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCIuXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcy5zb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG4gICAgICAgICAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRbalF1ZXJ5LmV4cGFuZG9dXG4gICAgICAgICAgICAgICAgPyBldmVudFxuICAgICAgICAgICAgICAgIDogbmV3IGpRdWVyeS5FdmVudCh0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG4gICAgICAgICAgICBldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcbiAgICAgICAgICAgIGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG4gICAgICAgICAgICBldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgPyBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG4gICAgICAgICAgICBldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3RcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhID09IG51bGwgPyBbIGV2ZW50IF0gOiBqUXVlcnkubWFrZUFycmF5KGRhdGEsIFsgZXZlbnQgXSk7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcbiAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhb25seUhhbmRsZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwudHJpZ2dlciAmJlxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoZWxlbSwgZGF0YSkgPT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuICAgICAgICAgICAgLy8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcbiAgICAgICAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coZWxlbSkpIHtcbiAgICAgICAgICAgICAgICBidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJmb2N1c01vcnBoLnRlc3QoYnViYmxlVHlwZSArIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaChjdXIpO1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSBjdXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG4gICAgICAgICAgICAgICAgaWYgKHRtcCA9PT0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXRoLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaSA+IDEgPyBidWJibGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IGhhbmRsZXJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSAoZGF0YVByaXYuZ2V0KGN1ciwgXCJldmVudHNcIikgfHwge30pW2V2ZW50LnR5cGVdICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmdldChjdXIsIFwiaGFuZGxlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFwcGx5KGN1ciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTmF0aXZlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBvbnR5cGUgJiYgY3VyW29udHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YShjdXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseShjdXIsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG4gICAgICAgICAgICBpZiAoIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICghc3BlY2lhbC5fZGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5fZGVmYXVsdC5hcHBseShldmVudFBhdGgucG9wKCksIGRhdGEpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0RGF0YShlbGVtKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG9udHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0Z1bmN0aW9uKGVsZW1bdHlwZV0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWpRdWVyeS5pc1dpbmRvdyhlbGVtKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGVsZW1bb250eXBlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bb250eXBlXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bdHlwZV0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW29udHlwZV0gPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuICAgICAgICAvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuICAgICAgICBzaW11bGF0ZTogZnVuY3Rpb24odHlwZSwgZWxlbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0galF1ZXJ5LmV4dGVuZChuZXcgalF1ZXJ5LkV2ZW50KCksIGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBpc1NpbXVsYXRlZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKGUsIG51bGwsIGVsZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcih0eXBlLCBkYXRhLCB0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIodHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5lYWNoKFxuICAgICAgICAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG4gICAgICAgICAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICAgICAgICAgIFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiKS5zcGxpdChcbiAgICAgICAgICAgIFwiIFwiXG4gICAgICAgICksXG4gICAgICAgIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG4gICAgICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbihkYXRhLCBmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMub24obmFtZSwgbnVsbCwgZGF0YSwgZm4pXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy50cmlnZ2VyKG5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgaG92ZXI6IGZ1bmN0aW9uKGZuT3ZlciwgZm5PdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoZm5PdmVyKS5tb3VzZWxlYXZlKGZuT3V0IHx8IGZuT3Zlcik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4gICAgLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuICAgIC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4gICAgLy9cbiAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbiAgICAvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbiAgICAvLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbiAgICAvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuICAgIGlmICghc3VwcG9ydC5mb2N1c2luKSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oXG4gICAgICAgICAgICBvcmlnLFxuICAgICAgICAgICAgZml4XG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuc2ltdWxhdGUoXG4gICAgICAgICAgICAgICAgICAgIGZpeCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xuICAgICAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0YWNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKG9yaWcsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmFjY2Vzcyhkb2MsIGZpeCwgKGF0dGFjaGVzIHx8IDApICsgMSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKGRvYywgZml4KSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZG9jLCBmaXgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuYWNjZXNzKGRvYywgZml4LCBhdHRhY2hlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG4gICAgdmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG4gICAgdmFyIHJxdWVyeSA9IC9cXD8vO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuICAgIGpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHhtbDtcbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG4gICAgICAgIC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgeG1sID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgeG1sID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geG1sO1xuICAgIH07XG5cbiAgICB2YXIgcmJyYWNrZXQgPSAvXFxbXFxdJC8sXG4gICAgICAgIHJDUkxGID0gL1xccj9cXG4vZyxcbiAgICAgICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuICAgICAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICAgICAgICBqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICAgICAgICAgICAgYWRkKHByZWZpeCwgdik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhZGl0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgICAgb2JqW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICB0cmFkaXRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgYWRkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgICAgICAgIGFkZChwcmVmaXgsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuICAgIC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICAgIGpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKGEsIHRyYWRpdGlvbmFsKSB7XG4gICAgICAgIHZhciBwcmVmaXgsXG4gICAgICAgICAgICBzID0gW10sXG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbihrZXksIHZhbHVlT3JGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZU9yRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVPckZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZU9yRnVuY3Rpb247XG5cbiAgICAgICAgICAgICAgICBzW3MubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgICAgIGlmIChqUXVlcnkuaXNBcnJheShhKSB8fCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoYSkpIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYWRkKHRoaXMubmFtZSwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAgICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgICAgICAgIGZvciAocHJlZml4IGluIGEpIHtcbiAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXgsIGFbcHJlZml4XSwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG4gICAgICAgIHJldHVybiBzLmpvaW4oXCImXCIpO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKHRoaXMsIFwiZWxlbWVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoZWxlbWVudHMpIDogdGhpcztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhalF1ZXJ5KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByc3VibWl0dGFibGUudGVzdCh0aGlzLm5vZGVOYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KHR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KHR5cGUpKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaSwgZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5KHRoaXMpLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXCJcXHJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWxlbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbC5yZXBsYWNlKHJDUkxGLCBcIlxcclxcblwiKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmdldCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcjIwID0gLyUyMC9nLFxuICAgICAgICByaGFzaCA9IC8jLiokLyxcbiAgICAgICAgcmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcbiAgICAgICAgcmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuICAgICAgICAvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cbiAgICAgICAgcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcbiAgICAgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG4gICAgICAgIHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcbiAgICAgICAgLyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuICAgICAgICBwcmVmaWx0ZXJzID0ge30sXG4gICAgICAgIC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cbiAgICAgICAgdHJhbnNwb3J0cyA9IHt9LFxuICAgICAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cbiAgICAgICAgYWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KFwiKlwiKSxcbiAgICAgICAgLy8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG4gICAgICAgIG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuICAgIC8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbiAgICBmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoc3RydWN0dXJlKSB7XG4gICAgICAgIC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIC5tYXRjaChybm90aHRtbHdoaXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICBbXTtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIHdoaWxlIChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZVswXSA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoMSkgfHwgXCIqXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RydWN0dXJlW2RhdGFUeXBlXSA9IHN0cnVjdHVyZVtkYXRhVHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSkudW5zaGlmdChmdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdKS5wdXNoKGZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuICAgIGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKFxuICAgICAgICBzdHJ1Y3R1cmUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG9yaWdpbmFsT3B0aW9ucyxcbiAgICAgICAganFYSFJcbiAgICApIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHt9LCBzZWVraW5nVHJhbnNwb3J0ID0gc3RydWN0dXJlID09PSB0cmFuc3BvcnRzO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluc3BlY3QoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICAgIGluc3BlY3RlZFtkYXRhVHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSwgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgXyxcbiAgICAgICAgICAgICAgICBwcmVmaWx0ZXJPckZhY3RvcnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGpxWEhSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhc2Vla2luZ1RyYW5zcG9ydCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWluc3BlY3RlZFtkYXRhVHlwZU9yVHJhbnNwb3J0XVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWVraW5nVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zcGVjdChvcHRpb25zLmRhdGFUeXBlc1swXSkgfHwgIWluc3BlY3RlZFtcIipcIl0gJiYgaW5zcGVjdChcIipcIik7XG4gICAgfVxuXG4gICAgLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4gICAgLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbiAgICAvLyBGaXhlcyAjOTg4N1xuICAgIGZ1bmN0aW9uIGFqYXhFeHRlbmQodGFyZ2V0LCBzcmMpIHtcbiAgICAgICAgdmFyIGtleSwgZGVlcCwgZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGZvciAoa2V5IGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHNyY1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAoZmxhdE9wdGlvbnNba2V5XVxuICAgICAgICAgICAgICAgICAgICA/IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICA6IGRlZXAgfHwgKGRlZXAgPSB7fSkpW2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCB0YXJnZXQsIGRlZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbiAgICBmdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpIHtcbiAgICAgICAgdmFyIGN0LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUsXG4gICAgICAgICAgICBmaXJzdERhdGFUeXBlLFxuICAgICAgICAgICAgY29udGVudHMgPSBzLmNvbnRlbnRzLFxuICAgICAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgd2hpbGUgKGRhdGFUeXBlc1swXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcbiAgICAgICAgaWYgKGN0KSB7XG4gICAgICAgICAgICBmb3IgKHR5cGUgaW4gY29udGVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHNbdHlwZV0gJiYgY29udGVudHNbdHlwZV0udGVzdChjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuICAgICAgICBpZiAoZGF0YVR5cGVzWzBdIGluIHJlc3BvbnNlcykge1xuICAgICAgICAgICAgZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcbiAgICAgICAgICAgIGZvciAodHlwZSBpbiByZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFUeXBlc1swXSB8fCBzLmNvbnZlcnRlcnNbdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdXSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlyc3REYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdERhdGFUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuICAgICAgICAgICAgZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcbiAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICAgICAgICBpZiAoZmluYWxEYXRhVHlwZSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1swXSkge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KGZpbmFsRGF0YVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlc1tmaW5hbERhdGFUeXBlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG4gICAgZnVuY3Rpb24gYWpheENvbnZlcnQocywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MpIHtcbiAgICAgICAgdmFyIGNvbnYyLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGNvbnYsXG4gICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgY29udmVydGVycyA9IHt9LFxuICAgICAgICAgICAgLy8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuICAgICAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuICAgICAgICAvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcbiAgICAgICAgaWYgKGRhdGFUeXBlc1sxXSkge1xuICAgICAgICAgICAgZm9yIChjb252IGluIHMuY29udmVydGVycykge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbY29udi50b0xvd2VyQ2FzZSgpXSA9IHMuY29udmVydGVyc1tjb252XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKHMucmVzcG9uc2VGaWVsZHNbY3VycmVudF0pIHtcbiAgICAgICAgICAgICAgICBqcVhIUltzLnJlc3BvbnNlRmllbGRzW2N1cnJlbnRdXSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKCFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHMuZGF0YUZpbHRlcihyZXNwb25zZSwgcy5kYXRhVHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbcHJldiArIFwiIFwiICsgY3VycmVudF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbXCIqIFwiICsgY3VycmVudF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb252KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnYyIGluIGNvbnZlcnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBjb252Mi5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFsxXSA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbcHJldiArIFwiIFwiICsgdG1wWzBdXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyc1tcIiogXCIgKyB0bXBbMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnYgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1tjb252Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb252ZXJ0ZXJzW2NvbnYyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0bXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQodG1wWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb252ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udiAmJiBzLnRocm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwicGFyc2VyZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjb252XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB0byBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuICAgICAgICBhY3RpdmU6IDAsXG4gICAgICAgIC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3RcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB7fSxcbiAgICAgICAgZXRhZzoge30sXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgICAgICAgdXJsOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QobG9jYXRpb24ucHJvdG9jb2wpLFxuICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IHRydWUsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuICAgICAgICAgICAgLypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cbiAgICAgICAgICAgIGFjY2VwdHM6IHtcbiAgICAgICAgICAgICAgICBcIipcIjogYWxsVHlwZXMsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgICAgICAgICAgaHRtbDogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgICAgICAgICB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuICAgICAgICAgICAgICAgIGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50czogeyB4bWw6IC9cXGJ4bWxcXGIvLCBodG1sOiAvXFxiaHRtbC8sIGpzb246IC9cXGJqc29uXFxiLyB9LFxuICAgICAgICAgICAgcmVzcG9uc2VGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICB4bWw6IFwicmVzcG9uc2VYTUxcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuICAgICAgICAgICAgICAgIGpzb246IFwicmVzcG9uc2VKU09OXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBEYXRhIGNvbnZlcnRlcnNcbiAgICAgICAgICAgIC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcbiAgICAgICAgICAgICAgICBcIiogdGV4dFwiOiBTdHJpbmcsXG4gICAgICAgICAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuICAgICAgICAgICAgICAgIFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcbiAgICAgICAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG4gICAgICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcbiAgICAgICAgICAgIGZsYXRPcHRpb25zOiB7IHVybDogdHJ1ZSwgY29udGV4dDogdHJ1ZSB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG4gICAgICAgIC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cbiAgICAgICAgLy8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cbiAgICAgICAgYWpheFNldHVwOiBmdW5jdGlvbih0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MgPyAvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoXG4gICAgICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQodGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICApIDogLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMpLFxuICAgICAgICBhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHModHJhbnNwb3J0cyksXG4gICAgICAgIC8vIE1haW4gbWV0aG9kXG4gICAgICAgIGFqYXg6IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG4gICAgICAgICAgICAgICAgY2FjaGVVUkwsXG4gICAgICAgICAgICAgICAgLy8gUmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcbiAgICAgICAgICAgICAgICB0aW1lb3V0VGltZXIsXG4gICAgICAgICAgICAgICAgLy8gVXJsIGNsZWFudXAgdmFyXG4gICAgICAgICAgICAgICAgdXJsQW5jaG9yLFxuICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQsXG4gICAgICAgICAgICAgICAgLy8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAgICAgZmlyZUdsb2JhbHMsXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgLy8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG4gICAgICAgICAgICAgICAgdW5jYWNoZWQsXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgIHMgPSBqUXVlcnkuYWpheFNldHVwKHt9LCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAvLyBDYWxsYmFja3MgY29udGV4dFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICA/IGpRdWVyeShjYWxsYmFja0NvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIDogalF1ZXJ5LmV2ZW50LFxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkc1xuICAgICAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG4gICAgICAgICAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcbiAgICAgICAgICAgICAgICAvLyBGYWtlIHhoclxuICAgICAgICAgICAgICAgIGpxWEhSID0ge1xuICAgICAgICAgICAgICAgICAgICByZWFkeVN0YXRlOiAwLFxuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSByaGVhZGVycy5leGVjKHJlc3BvbnNlSGVhZGVyc1N0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV0gPSBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gUmF3IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm1pbWVUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhtYXBbanFYSFIuc3RhdHVzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2RlIGluIG1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVtjb2RlXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlW2NvZGVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFtjb2RlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKHN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5hYm9ydChmaW5hbFRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgwLCBmaW5hbFRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggZGVmZXJyZWRzXG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlKGpxWEhSKTtcblxuICAgICAgICAgICAgLy8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG4gICAgICAgICAgICAvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuICAgICAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBzLnVybCA9ICgodXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYpICsgXCJcIikucmVwbGFjZShcbiAgICAgICAgICAgICAgICBycHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuICAgICAgICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuICAgICAgICAgICAgcy5kYXRhVHlwZXMgPSAocy5kYXRhVHlwZSB8fCBcIipcIilcbiAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIC5tYXRjaChybm90aHRtbHdoaXRlKSB8fFxuICAgICAgICAgICAgICAgIFsgXCJcIiBdO1xuXG4gICAgICAgICAgICAvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cbiAgICAgICAgICAgIGlmIChzLmNyb3NzRG9tYWluID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcbiAgICAgICAgICAgICAgICAvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuICAgICAgICAgICAgICAgIC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi8vXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG4gICAgICAgICAgICBpZiAocy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHMuZGF0YSA9IGpRdWVyeS5wYXJhbShzLmRhdGEsIHMudHJhZGl0aW9uYWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBwcmVmaWx0ZXJzXG4gICAgICAgICAgICBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUik7XG5cbiAgICAgICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuICAgICAgICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcbiAgICAgICAgICAgIGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG4gICAgICAgICAgICAvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG4gICAgICAgICAgICBpZiAoZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuICAgICAgICAgICAgcy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG4gICAgICAgICAgICBzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KHMudHlwZSk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuICAgICAgICAgICAgLy8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG4gICAgICAgICAgICAvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICBjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2Uocmhhc2gsIFwiXCIpO1xuXG4gICAgICAgICAgICAvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuICAgICAgICAgICAgaWYgKCFzLmhhc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcbiAgICAgICAgICAgICAgICB1bmNhY2hlZCA9IHMudXJsLnNsaWNlKGNhY2hlVVJMLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG4gICAgICAgICAgICAgICAgaWYgKHMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVVSTCArPSAocnF1ZXJ5LnRlc3QoY2FjaGVVUkwpID8gXCImXCIgOiBcIj9cIikgKyBzLmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcy5kYXRhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAocy5jYWNoZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKHJhbnRpQ2FjaGUsIFwiJDFcIik7XG4gICAgICAgICAgICAgICAgICAgIHVuY2FjaGVkID0gKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFwiJlwiIDogXCI/XCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXz1cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZSsrICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY2FjaGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcbiAgICAgICAgICAgICAgICBzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHMuZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICBzLnByb2Nlc3NEYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIChzLmNvbnRlbnRUeXBlIHx8IFwiXCIpLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgICAgICAgICAgICAgICkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzLmRhdGEgPSBzLmRhdGEucmVwbGFjZShyMjAsIFwiK1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgICAgICAgIGlmIChzLmlmTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Lmxhc3RNb2RpZmllZFtjYWNoZVVSTF0pIHtcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYtTW9kaWZpZWQtU2luY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pIHtcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYtTm9uZS1NYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV0YWdbY2FjaGVVUkxdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGVudFR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcbiAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgICAgICAgXCJBY2NlcHRcIixcbiAgICAgICAgICAgICAgICBzLmRhdGFUeXBlc1swXSAmJiBzLmFjY2VwdHNbcy5kYXRhVHlwZXNbMF1dXG4gICAgICAgICAgICAgICAgICAgID8gcy5hY2NlcHRzW3MuZGF0YVR5cGVzWzBdXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5kYXRhVHlwZXNbMF0gIT09IFwiKlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBzLmFjY2VwdHNbXCIqXCJdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cbiAgICAgICAgICAgIGZvciAoaSBpbiBzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKGksIHMuaGVhZGVyc1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzLmJlZm9yZVNlbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHMuYmVmb3JlU2VuZC5jYWxsKGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMpID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuICAgICAgICAgICAgc3RyQWJvcnQgPSBcImFib3J0XCI7XG5cbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5hZGQocy5jb21wbGV0ZSk7XG4gICAgICAgICAgICBqcVhIUi5kb25lKHMuc3VjY2Vzcyk7XG4gICAgICAgICAgICBqcVhIUi5mYWlsKHMuZXJyb3IpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdHJhbnNwb3J0XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzLFxuICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBqcVhIUlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG4gICAgICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGRvbmUoLTEsIFwiTm8gVHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRpbWVvdXRcbiAgICAgICAgICAgICAgICBpZiAocy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMudGltZW91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChyZXF1ZXN0SGVhZGVycywgZG9uZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgtMSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNTdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vIFNldCByZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgcmVzcG9uc2UgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFqYXhDb252ZXJ0KHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG4gICAgICAgICAgICAgICAgaWYgKGlzU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocy5pZk1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldGFnW2NhY2hlVVJMXSA9IG1vZGlmaWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gY29udGVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gIWVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgfHwgIXN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXNUZXh0ID0gKG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCkgKyBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxuICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoY2FsbGJhY2tDb250ZXh0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoY2FsbGJhY2tDb250ZXh0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBqcVhIUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c0NvZGUoc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGlmIChmaXJlR2xvYmFscykge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aChjYWxsYmFja0NvbnRleHQsIFtcbiAgICAgICAgICAgICAgICAgICAganFYSFIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIGlmIChmaXJlR2xvYmFscykge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS0talF1ZXJ5LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICB9LFxuICAgICAgICBnZXRKU09OOiBmdW5jdGlvbih1cmwsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNjcmlwdDogZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXQodXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmVhY2goWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbihpLCBtZXRob2QpIHtcbiAgICAgICAgalF1ZXJ5W21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgICAgICAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KFxuICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzUGxhaW5PYmplY3QodXJsKSAmJiB1cmxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICBnbG9iYWw6IGZhbHNlLFxuICAgICAgICAgICAgdGhyb3dzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgd3JhcEFsbDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgdmFyIHdyYXA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzWzBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGh0bWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLmNhbGwodGhpc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcbiAgICAgICAgICAgICAgICB3cmFwID0galF1ZXJ5KGh0bWwsIHRoaXNbMF0ub3duZXJEb2N1bWVudCkuZXEoMCkuY2xvbmUodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpc1swXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oaHRtbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBJbm5lcihodG1sLmNhbGwodGhpcywgaSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLCBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMud3JhcEFsbChodG1sKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGVuZChodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JhcDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbihodG1sKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBBbGwoaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVud3JhcDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KHNlbGVjdG9yKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoZWxlbSk7XG4gICAgfTtcbiAgICBqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiAhIShlbGVtLm9mZnNldFdpZHRoIHx8XG4gICAgICAgICAgICBlbGVtLm9mZnNldEhlaWdodCB8fFxuICAgICAgICAgICAgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG4gICAgICAgIC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG4gICAgICAgIDA6IDIwMCxcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgICAgLy8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG4gICAgICAgIDEyMjM6IDIwNFxuICAgIH0sXG4gICAgICAgIHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbiAgICBzdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZDtcbiAgICBzdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG4gICAgICAgIC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgaWYgKHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oaGVhZGVycywgY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIHhociA9IG9wdGlvbnMueGhyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXNzd29yZFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMueGhyRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucy54aHJGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJbaV0gPSBvcHRpb25zLnhockZpZWxkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG9wdGlvbnMubWltZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuICAgICAgICAgICAgICAgICAgICAvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIGhlYWRlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWJvcnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgwLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyU3VjY2Vzc1N0YXR1c1t4aHIuc3RhdHVzXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuIHRvIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soXCJlcnJvclwiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayhcImFib3J0XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcbiAgICAgICAgICAgIHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XG4gICAgICAgIGFjY2VwdHM6IHtcbiAgICAgICAgICAgIHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcbiAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRzOiB7IHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvIH0sXG4gICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICAgIFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKHRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIiwgZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzLmNhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcbiAgICAgICAgICAgIHMudHlwZSA9IFwiR0VUXCI7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuICAgICAgICBpZiAocy5jcm9zc0RvbWFpbikge1xuICAgICAgICAgICAgdmFyIHNjcmlwdCwgY2FsbGJhY2s7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKF8sIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucHJvcCh7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibG9hZCBlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2dC50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRbMF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgb2xkQ2FsbGJhY2tzID0gW10sIHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbiAgICAvLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XG4gICAgICAgIGpzb25wOiBcImNhbGxiYWNrXCIsXG4gICAgICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8IGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyBub25jZSsrO1xuICAgICAgICAgICAgdGhpc1tjYWxsYmFja10gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIiwgZnVuY3Rpb24ocywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrTmFtZSxcbiAgICAgICAgICAgIG92ZXJ3cml0dGVuLFxuICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIsXG4gICAgICAgICAgICBqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHJqc29ucC50ZXN0KHMudXJsKVxuICAgICAgICAgICAgICAgICAgICA/IFwidXJsXCJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcmpzb25wLnRlc3Qocy5kYXRhKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCIpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcbiAgICAgICAgaWYgKGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWzBdID09PSBcImpzb25wXCIpIHtcbiAgICAgICAgICAgIC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcbiAgICAgICAgICAgIGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKHMuanNvbnBDYWxsYmFjaylcbiAgICAgICAgICAgICAgICA/IHMuanNvbnBDYWxsYmFjaygpXG4gICAgICAgICAgICAgICAgOiBzLmpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcbiAgICAgICAgICAgIGlmIChqc29uUHJvcCkge1xuICAgICAgICAgICAgICAgIHNbanNvblByb3BdID0gc1tqc29uUHJvcF0ucmVwbGFjZShyanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcy51cmwgKz0gKHJxdWVyeS50ZXN0KHMudXJsKSA/IFwiJlwiIDogXCI/XCIpICtcbiAgICAgICAgICAgICAgICAgICAgcy5qc29ucCArXG4gICAgICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG4gICAgICAgICAgICBzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VDb250YWluZXJbMF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG4gICAgICAgICAgICBzLmRhdGFUeXBlc1swXSA9IFwianNvblwiO1xuXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrXG4gICAgICAgICAgICBvdmVyd3JpdHRlbiA9IHdpbmRvd1tjYWxsYmFja05hbWVdO1xuICAgICAgICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuICAgICAgICAgICAganFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgIGlmIChvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh3aW5kb3cpLnJlbW92ZVByb3AoY2FsbGJhY2tOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG92ZXJ3cml0dGVuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgYmFjayBhcyBmcmVlXG4gICAgICAgICAgICAgICAgaWYgKHNbY2FsbGJhY2tOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgcy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2tOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24ob3ZlcndyaXR0ZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0dGVuKHJlc3BvbnNlQ29udGFpbmVyWzBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuICAgICAgICAgICAgcmV0dXJuIFwic2NyaXB0XCI7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbiAgICAvLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4gICAgLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4gICAgLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbiAgICBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikuYm9keTtcbiAgICAgICAgYm9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG4gICAgICAgIHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xuICAgIH0pKCk7XG5cbiAgICAvLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbiAgICAvLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4gICAgLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbiAgICAvLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG4gICAgalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGtlZXBTY3JpcHRzID0gY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICBpZiAoc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLy8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcbiAgICAgICAgICAgICAgICAvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuICAgICAgICAgICAgICAgIGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpO1xuICAgICAgICAgICAgICAgIGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWFkLmFwcGVuZENoaWxkKGJhc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoZGF0YSk7XG4gICAgICAgIHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cbiAgICAgICAgLy8gU2luZ2xlIHRhZ1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQocGFyc2VkWzFdKSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkID0gYnVpbGRGcmFnbWVudChbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyk7XG5cbiAgICAgICAgaWYgKHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGpRdWVyeShzY3JpcHRzKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoW10sIHBhcnNlZC5jaGlsZE5vZGVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbiAgICBqUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKHVybCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLCBzZWxmID0gdGhpcywgb2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG4gICAgICAgIGlmIChvZmYgPiAtMSkge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKHVybC5zbGljZShvZmYpKTtcbiAgICAgICAgICAgIHVybCA9IHVybC5zbGljZSgwLCBvZmYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihwYXJhbXMpKSB7XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcIlBPU1RcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG4gICAgICAgIGlmIChzZWxmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5odG1sKFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KFwiPGRpdj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGpRdWVyeS5wYXJzZUhUTUwocmVzcG9uc2VUZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZChzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcbiAgICAgICAgICAgIH0pLmFsd2F5cyhcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBmdW5jdGlvbihqcVhIUiwgc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG4gICAgalF1ZXJ5LmVhY2goXG4gICAgICAgIFtcbiAgICAgICAgICAgIFwiYWpheFN0YXJ0XCIsXG4gICAgICAgICAgICBcImFqYXhTdG9wXCIsXG4gICAgICAgICAgICBcImFqYXhDb21wbGV0ZVwiLFxuICAgICAgICAgICAgXCJhamF4RXJyb3JcIixcbiAgICAgICAgICAgIFwiYWpheFN1Y2Nlc3NcIixcbiAgICAgICAgICAgIFwiYWpheFNlbmRcIlxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbihpLCB0eXBlKSB7XG4gICAgICAgICAgICBqUXVlcnkuZm5bdHlwZV0gPSBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgalF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbiAgICBmdW5jdGlvbiBnZXRXaW5kb3coZWxlbSkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmlzV2luZG93KGVsZW0pXG4gICAgICAgICAgICA/IGVsZW1cbiAgICAgICAgICAgIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xuICAgIH1cblxuICAgIGpRdWVyeS5vZmZzZXQgPSB7XG4gICAgICAgIHNldE9mZnNldDogZnVuY3Rpb24oZWxlbSwgb3B0aW9ucywgaSkge1xuICAgICAgICAgICAgdmFyIGN1clBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGN1ckxlZnQsXG4gICAgICAgICAgICAgICAgY3VyQ1NTVG9wLFxuICAgICAgICAgICAgICAgIGN1clRvcCxcbiAgICAgICAgICAgICAgICBjdXJPZmZzZXQsXG4gICAgICAgICAgICAgICAgY3VyQ1NTTGVmdCxcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGpRdWVyeS5jc3MoZWxlbSwgXCJwb3NpdGlvblwiKSxcbiAgICAgICAgICAgICAgICBjdXJFbGVtID0galF1ZXJ5KGVsZW0pLFxuICAgICAgICAgICAgICAgIHByb3BzID0ge307XG5cbiAgICAgICAgICAgIC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG4gICAgICAgICAgICBjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKGVsZW0sIFwidG9wXCIpO1xuICAgICAgICAgICAgY3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gPSAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID09PSBcImZpeGVkXCIpICYmXG4gICAgICAgICAgICAgICAgKGN1ckNTU1RvcCArIGN1ckNTU0xlZnQpLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG4gICAgICAgICAgICAvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyVG9wID0gcGFyc2VGbG9hdChjdXJDU1NUb3ApIHx8IDA7XG4gICAgICAgICAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoY3VyQ1NTTGVmdCkgfHwgMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY2FsbChlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKHt9LCBjdXJPZmZzZXQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9wICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy50b3AgPSBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKyBjdXJUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5sZWZ0ID0gb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKyBjdXJMZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXCJ1c2luZ1wiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVzaW5nLmNhbGwoZWxlbSwgcHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJFbGVtLmNzcyhwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIG9mZnNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBvcHRpb25zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkb2NFbGVtLCB3aW4sIHJlY3QsIGRvYywgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgICAgICAvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG4gICAgICAgICAgICAvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgICAgIGlmICghZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgaXMgbm90IGhpZGRlbiAoZGlzcGxheTogbm9uZSlcbiAgICAgICAgICAgIGlmIChyZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgICAgIHdpbiA9IGdldFdpbmRvdyhkb2MpO1xuICAgICAgICAgICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChnaC0yMzEwKVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpc1swXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCxcbiAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuICAgICAgICAgICAgLy8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuICAgICAgICAgICAgaWYgKGpRdWVyeS5jc3MoZWxlbSwgXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkubm9kZU5hbWUob2Zmc2V0UGFyZW50WzBdLCBcImh0bWxcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBwYXJlbnRPZmZzZXQudG9wICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0LnRvcCAtXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgLVxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUpLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgLVxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgIC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cbiAgICAgICAgLy8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG4gICAgICAgIC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcbiAgICAgICAgLy8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuICAgICAgICAvL1xuICAgICAgICAvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcbiAgICAgICAgLy8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG4gICAgICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goXG4gICAgICAgIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LFxuICAgICAgICBmdW5jdGlvbihtZXRob2QsIHByb3ApIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cbiAgICAgICAgICAgIGpRdWVyeS5mblttZXRob2RdID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW4gPyB3aW5bcHJvcF0gOiBlbGVtW21ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bbWV0aG9kXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4gICAgLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbiAgICAvLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbiAgICAvLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuICAgIC8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4gICAgLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbiAgICBqUXVlcnkuZWFjaChbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKGksIHByb3ApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW3Byb3BdID0gYWRkR2V0SG9va0lmKHN1cHBvcnQucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24oXG4gICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgY29tcHV0ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZCA9IGN1ckNTUyhlbGVtLCBwcm9wKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuICAgICAgICAgICAgICAgIHJldHVybiBybnVtbm9ucHgudGVzdChjb21wdXRlZClcbiAgICAgICAgICAgICAgICAgICAgPyBqUXVlcnkoZWxlbSkucG9zaXRpb24oKVtwcm9wXSArIFwicHhcIlxuICAgICAgICAgICAgICAgICAgICA6IGNvbXB1dGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgalF1ZXJ5LmVhY2goXG4gICAgICAgICAgICB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGRlZmF1bHRFeHRyYSwgZnVuY05hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcbiAgICAgICAgICAgICAgICBqUXVlcnkuZm5bZnVuY05hbWVdID0gZnVuY3Rpb24obWFyZ2luLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYSA9IGRlZmF1bHRFeHRyYSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIm1hcmdpblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJib3JkZXJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlbGVtLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzV2luZG93KGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jTmFtZS5pbmRleE9mKFwib3V0ZXJcIikgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZWxlbVtcImlubmVyXCIgKyBuYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5W1wic2Nyb2xsXCIgKyBuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY1tcInNjcm9sbFwiICsgbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJvZmZzZXRcIiArIG5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jW1wib2Zmc2V0XCIgKyBuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY1tcImNsaWVudFwiICsgbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCB0eXBlLCBleHRyYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbmFibGVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKHR5cGVzLCBkYXRhLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIG51bGwsIGRhdGEsIGZuKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbih0eXBlcywgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZih0eXBlcywgbnVsbCwgZm4pO1xuICAgICAgICB9LFxuICAgICAgICBkZWxlZ2F0ZTogZnVuY3Rpb24oc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbik7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKHNlbGVjdG9yLCB0eXBlcywgZm4pIHtcbiAgICAgICAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgPyB0aGlzLm9mZihzZWxlY3RvciwgXCIqKlwiKVxuICAgICAgICAgICAgICAgIDogdGhpcy5vZmYodHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcblxuICAgIC8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuICAgIC8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbiAgICAvLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3RcbiAgICAvLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4gICAgLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4gICAgLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4gICAgLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuICAgIC8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4gICAgLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuICAgIC8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuICAgICAgICAvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgICAgICBfJCA9IHdpbmRvdy4kO1xuXG4gICAgalF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbihkZWVwKSB7XG4gICAgICAgIGlmICh3aW5kb3cuJCA9PT0galF1ZXJ5KSB7XG4gICAgICAgICAgICB3aW5kb3cuJCA9IF8kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5KSB7XG4gICAgICAgICAgICB3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4gICAgLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuICAgIC8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbiAgICBpZiAoIW5vR2xvYmFsKSB7XG4gICAgICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4galF1ZXJ5O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBDOi9Vc2Vycy9EYW5nby9sZWFybi9vYm9sb24vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function($) {\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Dropdown = function () {\n    function Dropdown(opt) {\n        _classCallCheck(this, Dropdown);\n\n        this.opt = opt;\n        this.btn = $(opt.btn);\n        this.list = $(opt.list);\n\n        this.list.hide();\n\n        this._onClick();\n    }\n\n    _createClass(Dropdown, [{\n        key: \"_onClick\",\n        value: function _onClick() {\n            var btn = this.btn;\n            var list = this.list;\n\n            $(btn).click(function (e) {\n                e.preventDefault();\n                $(list).slideToggle();\n            });\n        }\n    }]);\n\n    return Dropdown;\n}();\n\nexports.default = Dropdown;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvRHJvcGRvd24uanM/ZDJkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wZG93biB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMub3B0ID0gb3B0O1xuICAgICAgICB0aGlzLmJ0biA9ICQob3B0LmJ0bik7XG4gICAgICAgIHRoaXMubGlzdCA9ICQob3B0Lmxpc3QpO1xuXG4gICAgICAgIHRoaXMubGlzdC5oaWRlKCk7XG5cbiAgICAgICAgdGhpcy5fb25DbGljaygpO1xuICAgIH1cblxuICAgIF9vbkNsaWNrKCkge1xuICAgICAgICBsZXQgYnRuID0gdGhpcy5idG47XG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5saXN0O1xuXG4gICAgICAgICQoYnRuKS5jbGljayhmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkKGxpc3QpLnNsaWRlVG9nZ2xlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvanMvRHJvcGRvd24uanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFuQkE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function($) {\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Popup = function () {\n    function Popup(opt) {\n        _classCallCheck(this, Popup);\n\n        this.el = $(opt.el);\n\n        this._open();\n        this._close();\n    }\n\n    _createClass(Popup, [{\n        key: \"_open\",\n        value: function _open() {\n            this.el.each(function () {\n                $(this).click(function (e) {\n                    e.preventDefault();\n\n                    var popup = $(\".\" + $(this).attr(\"data-target\"));\n\n                    $(popup).parent().addClass(\"is-active\");\n\n                    $(popup).show();\n                    $(\"body\").css({ overflow: \"hidden\" });\n                });\n            });\n        }\n    }, {\n        key: \"_close\",\n        value: function _close() {\n            $(\".js-popup-close\").click(function (e) {\n                $(\".popup\").hide();\n                $(\".popup\").parent().removeClass(\"is-active\");\n                $(\"body\").css({ overflow: \"auto\" });\n            });\n        }\n    }]);\n\n    return Popup;\n}();\n\nexports.default = Popup;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvUG9wdXAuanM/ZGI5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBQb3B1cCB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMuZWwgPSAkKG9wdC5lbCk7XG5cbiAgICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgIH1cblxuICAgIF9vcGVuKCkge1xuICAgICAgICB0aGlzLmVsLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgcG9wdXAgPSAkKFwiLlwiICsgJCh0aGlzKS5hdHRyKFwiZGF0YS10YXJnZXRcIikpO1xuXG4gICAgICAgICAgICAgICAgJChwb3B1cCkucGFyZW50KCkuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgICAgICAkKHBvcHVwKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgJChcImJvZHlcIikuY3NzKHsgb3ZlcmZsb3c6IFwiaGlkZGVuXCIgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2Nsb3NlKCkge1xuICAgICAgICAkKFwiLmpzLXBvcHVwLWNsb3NlXCIpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICQoXCIucG9wdXBcIikuaGlkZSgpO1xuICAgICAgICAgICAgJChcIi5wb3B1cFwiKS5wYXJlbnQoKS5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICQoXCJib2R5XCIpLmNzcyh7IG92ZXJmbG93OiBcImF1dG9cIiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9qcy9Qb3B1cC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBN0JBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function($) {\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Tabs = function () {\n    function Tabs(opt) {\n        _classCallCheck(this, Tabs);\n\n        this.opt = opt;\n        this.currentSection = $(opt.section);\n        this.currentRoomsNumb = $(opt.rooms);\n\n        this._defaultSection(this.currentSection, this.currentRoomsNumb);\n        this._onClick();\n    }\n\n    _createClass(Tabs, [{\n        key: \"_defaultSection\",\n        value: function _defaultSection(currentSection, currentRoomsNumb) {\n            // default section and rooms\n            var section = currentSection[0];\n            var rooms = currentRoomsNumb[0];\n\n            $(\".js-tab-link\").each(function () {\n                var first = $(this).data(\"section\") == section;\n                var second = $(this).data(\"rooms\") == rooms;\n\n                if (first || second) {\n                    $(this).addClass(\"is-active\");\n                }\n            });\n            this._open();\n            this._defaultType();\n        }\n    }, {\n        key: \"_defaultType\",\n        value: function _defaultType() {\n            // default type and inner content\n            $(\".js-tab-content.is-active .js-tab-link-in\").first().addClass(\"is-active\");\n            $(\".js-tab-content.is-active .js-tab-desc\").first().addClass(\"is-active\");\n            $(\".js-tab-content.is-active .js-tab-img\").first().addClass(\"is-active\");\n            $(\".js-tab-content.is-active .js-tab-metrics\").first().addClass(\"is-active\");\n        }\n    }, {\n        key: \"_onClick\",\n        value: function _onClick() {\n            var self = this;\n            $(\".js-tab-link\").click(function (e) {\n                e.preventDefault();\n\n                $(this).addClass(\"is-active\").siblings().removeClass(\"is-active\");\n\n                self._open();\n                self._defaultType();\n            });\n            $(\".js-tab-content.is-active .js-tab-link-in\").click(function () {\n                $(this).addClass(\"is-active\").siblings().removeClass(\"is-active\");\n\n                var n = $(this).data(\"type\");\n\n                var desc = $(\".js-tab-content.is-active\").find(\".js-tab-desc\");\n                $(desc[n - 1]).addClass(\"is-active\").siblings().removeClass(\"is-active\");\n\n                var img = $(\".js-tab-content.is-active\").find(\".js-tab-img\");\n                $(img[n - 1]).addClass(\"is-active\").siblings().removeClass(\"is-active\");\n\n                var metrics = $(\".js-tab-content.is-active\").find(\".js-tab-metrics\");\n                $(metrics[n - 1]).addClass(\"is-active\").siblings().removeClass(\"is-active\");\n            });\n        }\n    }, {\n        key: \"_open\",\n        value: function _open() {\n            var section = $(\".js-tab-link.is-active[data-section]\").data(\"section\");\n            var rooms = $(\".js-tab-link.is-active[data-rooms]\").data(\"rooms\");\n\n            $(\".js-tab-content\").each(function () {\n                var first = $(this).data(\"section\") == section;\n                var second = $(this).data(\"rooms\") == rooms;\n\n                if (first && second) {\n                    $(this).addClass(\"is-active\").siblings().removeClass(\"is-active\");\n                }\n            });\n        }\n    }]);\n\n    return Tabs;\n}();\n\nexports.default = Tabs;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvVGFicy5qcz9iYzU1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICB0aGlzLm9wdCA9IG9wdDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VjdGlvbiA9ICQob3B0LnNlY3Rpb24pO1xuICAgICAgICB0aGlzLmN1cnJlbnRSb29tc051bWIgPSAkKG9wdC5yb29tcyk7XG5cbiAgICAgICAgdGhpcy5fZGVmYXVsdFNlY3Rpb24odGhpcy5jdXJyZW50U2VjdGlvbiwgdGhpcy5jdXJyZW50Um9vbXNOdW1iKTtcbiAgICAgICAgdGhpcy5fb25DbGljaygpO1xuICAgIH1cblxuICAgIF9kZWZhdWx0U2VjdGlvbihjdXJyZW50U2VjdGlvbiwgY3VycmVudFJvb21zTnVtYikge1xuICAgICAgICAvLyBkZWZhdWx0IHNlY3Rpb24gYW5kIHJvb21zXG4gICAgICAgIGxldCBzZWN0aW9uID0gY3VycmVudFNlY3Rpb25bMF07XG4gICAgICAgIGxldCByb29tcyA9IGN1cnJlbnRSb29tc051bWJbMF07XG5cbiAgICAgICAgJChcIi5qcy10YWItbGlua1wiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gJCh0aGlzKS5kYXRhKFwic2VjdGlvblwiKSA9PSBzZWN0aW9uO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9ICQodGhpcykuZGF0YShcInJvb21zXCIpID09IHJvb21zO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3QgfHwgc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFR5cGUoKTtcbiAgICB9XG5cbiAgICBfZGVmYXVsdFR5cGUoKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdHlwZSBhbmQgaW5uZXIgY29udGVudFxuICAgICAgICAkKFwiLmpzLXRhYi1jb250ZW50LmlzLWFjdGl2ZSAuanMtdGFiLWxpbmstaW5cIilcbiAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICQoXCIuanMtdGFiLWNvbnRlbnQuaXMtYWN0aXZlIC5qcy10YWItZGVzY1wiKVxuICAgICAgICAgICAgLmZpcnN0KClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgJChcIi5qcy10YWItY29udGVudC5pcy1hY3RpdmUgLmpzLXRhYi1pbWdcIilcbiAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICQoXCIuanMtdGFiLWNvbnRlbnQuaXMtYWN0aXZlIC5qcy10YWItbWV0cmljc1wiKVxuICAgICAgICAgICAgLmZpcnN0KClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICB9XG5cbiAgICBfb25DbGljaygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAkKFwiLmpzLXRhYi1saW5rXCIpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKFwiaXMtYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICBzZWxmLl9vcGVuKCk7XG4gICAgICAgICAgICBzZWxmLl9kZWZhdWx0VHlwZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgJChcIi5qcy10YWItY29udGVudC5pcy1hY3RpdmUgLmpzLXRhYi1saW5rLWluXCIpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKFwiaXMtYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICBsZXQgbiA9ICQodGhpcykuZGF0YShcInR5cGVcIik7XG5cbiAgICAgICAgICAgIHZhciBkZXNjID0gJChcIi5qcy10YWItY29udGVudC5pcy1hY3RpdmVcIikuZmluZChcIi5qcy10YWItZGVzY1wiKTtcbiAgICAgICAgICAgICQoZGVzY1tuIC0gMV0pXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpXG4gICAgICAgICAgICAgICAgLnNpYmxpbmdzKClcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgIHZhciBpbWcgPSAkKFwiLmpzLXRhYi1jb250ZW50LmlzLWFjdGl2ZVwiKS5maW5kKFwiLmpzLXRhYi1pbWdcIik7XG4gICAgICAgICAgICAkKGltZ1tuIC0gMV0pXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpXG4gICAgICAgICAgICAgICAgLnNpYmxpbmdzKClcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgIHZhciBtZXRyaWNzID0gJChcIi5qcy10YWItY29udGVudC5pcy1hY3RpdmVcIikuZmluZChcbiAgICAgICAgICAgICAgICBcIi5qcy10YWItbWV0cmljc1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgJChtZXRyaWNzW24gLSAxXSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIilcbiAgICAgICAgICAgICAgICAuc2libGluZ3MoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX29wZW4oKSB7XG4gICAgICAgIGxldCBzZWN0aW9uID0gJChcIi5qcy10YWItbGluay5pcy1hY3RpdmVbZGF0YS1zZWN0aW9uXVwiKS5kYXRhKFwic2VjdGlvblwiKTtcbiAgICAgICAgbGV0IHJvb21zID0gJChcIi5qcy10YWItbGluay5pcy1hY3RpdmVbZGF0YS1yb29tc11cIikuZGF0YShcInJvb21zXCIpO1xuXG4gICAgICAgICQoXCIuanMtdGFiLWNvbnRlbnRcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9ICQodGhpcykuZGF0YShcInNlY3Rpb25cIikgPT0gc2VjdGlvbjtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSAkKHRoaXMpLmRhdGEoXCJyb29tc1wiKSA9PSByb29tcztcblxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIHNlY29uZCkge1xuICAgICAgICAgICAgICAgICQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zaWJsaW5ncygpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9qcy9UYWJzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFJQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7O0FBL0ZBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function($) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = modal;\nfunction modal() {\n    var content = $(\".js-tab-content.is-active\"),\n        rooms = $(content).find('.js-tab-metrics.is-active [data-modal=\"js-modal-rooms\"]'),\n        sizes = $(content).find('.js-tab-metrics.is-active [data-modal=\"js-modal-sizes\"]'),\n        totalKey = $(content).find('.js-tab-metrics.is-active [data-modal=\"js-modal-total-key\"]'),\n        totalValue = $(content).find('.js-tab-metrics.is-active [data-modal=\"js-modal-total-value\"]'),\n        image = $(content).find('.js-tab-img.is-active[data-modal=\"js-modal-image\"]'),\n        title = $(content).find('[data-modal=\"js-modal-title\"]'),\n        type = $(content).find('.js-tab-link-in.is-active[data-modal=\"js-modal-type\"]'),\n        link = $(content).find('[data-modal=\"js-modal-link\"]');\n\n    function move(el) {\n        $(el).each(function () {\n            var t = $(el).data(\"modal\");\n\n            $(\".\" + t).append($(el).html());\n\n            if ($(el).is(\"[href]\")) {\n                var href = $(el).attr(\"href\");\n                $(\".\" + t).attr(\"href\", href);\n            }\n        });\n    }\n\n    move(rooms);\n    move(sizes);\n    move(totalKey);\n    move(totalValue);\n    move(image);\n    move(title);\n    move(type);\n    move(link);\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvbW9kYWwuanM/YWU5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtb2RhbCgpIHtcbiAgICB2YXIgY29udGVudCA9ICQoXCIuanMtdGFiLWNvbnRlbnQuaXMtYWN0aXZlXCIpLFxuICAgICAgICByb29tcyA9ICQoY29udGVudCkuZmluZChcbiAgICAgICAgICAgICcuanMtdGFiLW1ldHJpY3MuaXMtYWN0aXZlIFtkYXRhLW1vZGFsPVwianMtbW9kYWwtcm9vbXNcIl0nXG4gICAgICAgICksXG4gICAgICAgIHNpemVzID0gJChjb250ZW50KS5maW5kKFxuICAgICAgICAgICAgJy5qcy10YWItbWV0cmljcy5pcy1hY3RpdmUgW2RhdGEtbW9kYWw9XCJqcy1tb2RhbC1zaXplc1wiXSdcbiAgICAgICAgKSxcbiAgICAgICAgdG90YWxLZXkgPSAkKGNvbnRlbnQpLmZpbmQoXG4gICAgICAgICAgICAnLmpzLXRhYi1tZXRyaWNzLmlzLWFjdGl2ZSBbZGF0YS1tb2RhbD1cImpzLW1vZGFsLXRvdGFsLWtleVwiXSdcbiAgICAgICAgKSxcbiAgICAgICAgdG90YWxWYWx1ZSA9ICQoY29udGVudCkuZmluZChcbiAgICAgICAgICAgICcuanMtdGFiLW1ldHJpY3MuaXMtYWN0aXZlIFtkYXRhLW1vZGFsPVwianMtbW9kYWwtdG90YWwtdmFsdWVcIl0nXG4gICAgICAgICksXG4gICAgICAgIGltYWdlID0gJChjb250ZW50KS5maW5kKFxuICAgICAgICAgICAgJy5qcy10YWItaW1nLmlzLWFjdGl2ZVtkYXRhLW1vZGFsPVwianMtbW9kYWwtaW1hZ2VcIl0nXG4gICAgICAgICksXG4gICAgICAgIHRpdGxlID0gJChjb250ZW50KS5maW5kKCdbZGF0YS1tb2RhbD1cImpzLW1vZGFsLXRpdGxlXCJdJyksXG4gICAgICAgIHR5cGUgPSAkKGNvbnRlbnQpLmZpbmQoXG4gICAgICAgICAgICAnLmpzLXRhYi1saW5rLWluLmlzLWFjdGl2ZVtkYXRhLW1vZGFsPVwianMtbW9kYWwtdHlwZVwiXSdcbiAgICAgICAgKSxcbiAgICAgICAgbGluayA9ICQoY29udGVudCkuZmluZCgnW2RhdGEtbW9kYWw9XCJqcy1tb2RhbC1saW5rXCJdJyk7XG5cbiAgICBmdW5jdGlvbiBtb3ZlKGVsKSB7XG4gICAgICAgICQoZWwpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgdCA9ICQoZWwpLmRhdGEoXCJtb2RhbFwiKTtcblxuICAgICAgICAgICAgJChcIi5cIiArIHQpLmFwcGVuZCgkKGVsKS5odG1sKCkpO1xuXG4gICAgICAgICAgICBpZiAoJChlbCkuaXMoXCJbaHJlZl1cIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaHJlZiA9ICQoZWwpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgICAgICAgICAgICQoXCIuXCIgKyB0KS5hdHRyKFwiaHJlZlwiLCBocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW92ZShyb29tcyk7XG4gICAgbW92ZShzaXplcyk7XG4gICAgbW92ZSh0b3RhbEtleSk7XG4gICAgbW92ZSh0b3RhbFZhbHVlKTtcbiAgICBtb3ZlKGltYWdlKTtcbiAgICBtb3ZlKHRpdGxlKTtcbiAgICBtb3ZlKHR5cGUpO1xuICAgIG1vdmUobGluayk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2pzL21vZGFsLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {(function($, window, document, undefined) {\n    /**\n\t * Creates a carousel.\n\t * @class The Owl Carousel.\n\t * @public\n\t * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n\t * @param {Object} [options] - The options\n\t */\n    function Owl(element, options) {\n        /**\n\t\t * Current settings for the carousel.\n\t\t * @public\n\t\t */\n        this.settings = null;\n\n        /**\n\t\t * Current options set by the caller including defaults.\n\t\t * @public\n\t\t */\n        this.options = $.extend({}, Owl.Defaults, options);\n\n        /**\n\t\t * Plugin element.\n\t\t * @public\n\t\t */\n        this.$element = $(element);\n\n        /**\n\t\t * Proxied event handlers.\n\t\t * @protected\n\t\t */\n        this._handlers = {};\n\n        /**\n\t\t * References to the running plugins of this carousel.\n\t\t * @protected\n\t\t */\n        this._plugins = {};\n\n        /**\n\t\t * Currently suppressed events to prevent them from beeing retriggered.\n\t\t * @protected\n\t\t */\n        this._supress = {};\n\n        /**\n\t\t * Absolute current position.\n\t\t * @protected\n\t\t */\n        this._current = null;\n\n        /**\n\t\t * Animation speed in milliseconds.\n\t\t * @protected\n\t\t */\n        this._speed = null;\n\n        /**\n\t\t * Coordinates of all items in pixel.\n\t\t * @todo The name of this member is missleading.\n\t\t * @protected\n\t\t */\n        this._coordinates = [];\n\n        /**\n\t\t * Current breakpoint.\n\t\t * @todo Real media queries would be nice.\n\t\t * @protected\n\t\t */\n        this._breakpoint = null;\n\n        /**\n\t\t * Current width of the plugin element.\n\t\t */\n        this._width = null;\n\n        /**\n\t\t * All real items.\n\t\t * @protected\n\t\t */\n        this._items = [];\n\n        /**\n\t\t * All cloned items.\n\t\t * @protected\n\t\t */\n        this._clones = [];\n\n        /**\n\t\t * Merge values of all items.\n\t\t * @todo Maybe this could be part of a plugin.\n\t\t * @protected\n\t\t */\n        this._mergers = [];\n\n        /**\n\t\t * Widths of all items.\n\t\t */\n        this._widths = [];\n\n        /**\n\t\t * Invalidated parts within the update process.\n\t\t * @protected\n\t\t */\n        this._invalidated = {};\n\n        /**\n\t\t * Ordered list of workers for the update process.\n\t\t * @protected\n\t\t */\n        this._pipe = [];\n\n        /**\n\t\t * Current state information for the drag operation.\n\t\t * @todo #261\n\t\t * @protected\n\t\t */\n        this._drag = {\n            time: null,\n            target: null,\n            pointer: null,\n            stage: { start: null, current: null },\n            direction: null\n        };\n\n        /**\n\t\t * Current state information and their tags.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n        this._states = {\n            current: {},\n            tags: {\n                initializing: [ \"busy\" ],\n                animating: [ \"busy\" ],\n                dragging: [ \"interacting\" ]\n            }\n        };\n\n        $.each(\n            [ \"onResize\", \"onThrottledResize\" ],\n            $.proxy(\n                function(i, handler) {\n                    this._handlers[handler] = $.proxy(this[handler], this);\n                },\n                this\n            )\n        );\n\n        $.each(\n            Owl.Plugins,\n            $.proxy(\n                function(key, plugin) {\n                    this._plugins[key.charAt(0).toLowerCase() +\n                        key.slice(1)] = new plugin(this);\n                },\n                this\n            )\n        );\n\n        $.each(\n            Owl.Workers,\n            $.proxy(\n                function(priority, worker) {\n                    this._pipe.push({\n                        filter: worker.filter,\n                        run: $.proxy(worker.run, this)\n                    });\n                },\n                this\n            )\n        );\n\n        this.setup();\n        this.initialize();\n    }\n\n    /**\n\t * Default options for the carousel.\n\t * @public\n\t */\n    Owl.Defaults = {\n        items: 3,\n        loop: false,\n        center: false,\n        rewind: false,\n        mouseDrag: true,\n        touchDrag: true,\n        pullDrag: true,\n        freeDrag: false,\n        margin: 0,\n        stagePadding: 0,\n        merge: false,\n        mergeFit: true,\n        autoWidth: false,\n        startPosition: 0,\n        rtl: false,\n        smartSpeed: 250,\n        fluidSpeed: false,\n        dragEndSpeed: false,\n        responsive: {},\n        responsiveRefreshRate: 200,\n        responsiveBaseElement: window,\n        fallbackEasing: \"swing\",\n        info: false,\n        nestedItemSelector: false,\n        itemElement: \"div\",\n        stageElement: \"div\",\n        refreshClass: \"owl-refresh\",\n        loadedClass: \"owl-loaded\",\n        loadingClass: \"owl-loading\",\n        rtlClass: \"owl-rtl\",\n        responsiveClass: \"owl-responsive\",\n        dragClass: \"owl-drag\",\n        itemClass: \"owl-item\",\n        stageClass: \"owl-stage\",\n        stageOuterClass: \"owl-stage-outer\",\n        grabClass: \"owl-grab\"\n    };\n\n    /**\n\t * Enumeration for width.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n    Owl.Width = { Default: \"default\", Inner: \"inner\", Outer: \"outer\" };\n\n    /**\n\t * Enumeration for types.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n    Owl.Type = { Event: \"event\", State: \"state\" };\n\n    /**\n\t * Contains all registered plugins.\n\t * @public\n\t */\n    Owl.Plugins = {};\n\n    /**\n\t * List of workers involved in the update process.\n\t */\n    Owl.Workers = [\n        {\n            filter: [ \"width\", \"settings\" ],\n            run: function() {\n                this._width = this.$element.width();\n            }\n        },\n        {\n            filter: [ \"width\", \"items\", \"settings\" ],\n            run: function(cache) {\n                cache.current = this._items &&\n                    this._items[this.relative(this._current)];\n            }\n        },\n        {\n            filter: [ \"items\", \"settings\" ],\n            run: function() {\n                this.$stage.children(\".cloned\").remove();\n            }\n        },\n        {\n            filter: [ \"width\", \"items\", \"settings\" ],\n            run: function(cache) {\n                var margin = this.settings.margin || \"\",\n                    grid = !this.settings.autoWidth,\n                    rtl = this.settings.rtl,\n                    css = {\n                        width: \"auto\",\n                        \"margin-left\": rtl ? margin : \"\",\n                        \"margin-right\": rtl ? \"\" : margin\n                    };\n\n                !grid && this.$stage.children().css(css);\n\n                cache.css = css;\n            }\n        },\n        {\n            filter: [ \"width\", \"items\", \"settings\" ],\n            run: function(cache) {\n                var width = (this.width() / this.settings.items).toFixed(3) -\n                    this.settings.margin,\n                    merge = null,\n                    iterator = this._items.length,\n                    grid = !this.settings.autoWidth,\n                    widths = [];\n\n                cache.items = { merge: false, width: width };\n\n                while (iterator--) {\n                    merge = this._mergers[iterator];\n                    merge = this.settings.mergeFit &&\n                        Math.min(merge, this.settings.items) ||\n                        merge;\n\n                    cache.items.merge = merge > 1 || cache.items.merge;\n\n                    widths[iterator] = !grid\n                        ? this._items[iterator].width()\n                        : width * merge;\n                }\n\n                this._widths = widths;\n            }\n        },\n        {\n            filter: [ \"items\", \"settings\" ],\n            run: function() {\n                var clones = [],\n                    items = this._items,\n                    settings = this.settings,\n                    view = Math.max(settings.items * 2, 4),\n                    size = Math.ceil(items.length / 2) * 2,\n                    repeat = settings.loop && items.length\n                        ? settings.rewind ? view : Math.max(view, size)\n                        : 0,\n                    append = \"\",\n                    prepend = \"\";\n\n                repeat /= 2;\n\n                while (repeat--) {\n                    clones.push(this.normalize(clones.length / 2, true));\n                    append = append +\n                        items[clones[clones.length - 1]][0].outerHTML;\n                    clones.push(\n                        this.normalize(\n                            items.length - 1 - (clones.length - 1) / 2,\n                            true\n                        )\n                    );\n                    prepend = items[clones[clones.length - 1]][0].outerHTML +\n                        prepend;\n                }\n\n                this._clones = clones;\n\n                $(append).addClass(\"cloned\").appendTo(this.$stage);\n                $(prepend).addClass(\"cloned\").prependTo(this.$stage);\n            }\n        },\n        {\n            filter: [ \"width\", \"items\", \"settings\" ],\n            run: function() {\n                var rtl = this.settings.rtl ? 1 : -1,\n                    size = this._clones.length + this._items.length,\n                    iterator = -1,\n                    previous = 0,\n                    current = 0,\n                    coordinates = [];\n\n                while (++iterator < size) {\n                    previous = coordinates[iterator - 1] || 0;\n                    current = this._widths[this.relative(iterator)] +\n                        this.settings.margin;\n                    coordinates.push(previous + current * rtl);\n                }\n\n                this._coordinates = coordinates;\n            }\n        },\n        {\n            filter: [ \"width\", \"items\", \"settings\" ],\n            run: function() {\n                var padding = this.settings.stagePadding,\n                    coordinates = this._coordinates,\n                    css = {\n                        width: Math.ceil(\n                            Math.abs(coordinates[coordinates.length - 1])\n                        ) +\n                            padding * 2,\n                        \"padding-left\": padding || \"\",\n                        \"padding-right\": padding || \"\"\n                    };\n\n                this.$stage.css(css);\n            }\n        },\n        {\n            filter: [ \"width\", \"items\", \"settings\" ],\n            run: function(cache) {\n                var iterator = this._coordinates.length,\n                    grid = !this.settings.autoWidth,\n                    items = this.$stage.children();\n\n                if (grid && cache.items.merge) {\n                    while (iterator--) {\n                        cache.css.width = this._widths[this.relative(iterator)];\n                        items.eq(iterator).css(cache.css);\n                    }\n                } else if (grid) {\n                    cache.css.width = cache.items.width;\n                    items.css(cache.css);\n                }\n            }\n        },\n        {\n            filter: [ \"items\" ],\n            run: function() {\n                this._coordinates.length < 1 && this.$stage.removeAttr(\"style\");\n            }\n        },\n        {\n            filter: [ \"width\", \"items\", \"settings\" ],\n            run: function(cache) {\n                cache.current = cache.current\n                    ? this.$stage.children().index(cache.current)\n                    : 0;\n                cache.current = Math.max(\n                    this.minimum(),\n                    Math.min(this.maximum(), cache.current)\n                );\n                this.reset(cache.current);\n            }\n        },\n        {\n            filter: [ \"position\" ],\n            run: function() {\n                this.animate(this.coordinates(this._current));\n            }\n        },\n        {\n            filter: [ \"width\", \"position\", \"items\", \"settings\" ],\n            run: function() {\n                var rtl = this.settings.rtl ? 1 : -1,\n                    padding = this.settings.stagePadding * 2,\n                    begin = this.coordinates(this.current()) + padding,\n                    end = begin + this.width() * rtl,\n                    inner,\n                    outer,\n                    matches = [],\n                    i,\n                    n;\n\n                for (i = 0, n = this._coordinates.length; i < n; i++) {\n                    inner = this._coordinates[i - 1] || 0;\n                    outer = Math.abs(this._coordinates[i]) + padding * rtl;\n\n                    if (\n                        this.op(inner, \"<=\", begin) &&\n                            this.op(inner, \">\", end) ||\n                            this.op(outer, \"<\", begin) &&\n                                this.op(outer, \">\", end)\n                    ) {\n                        matches.push(i);\n                    }\n                }\n\n                this.$stage.children(\".active\").removeClass(\"active\");\n                this.$stage\n                    .children(\":eq(\" + matches.join(\"), :eq(\") + \")\")\n                    .addClass(\"active\");\n\n                if (this.settings.center) {\n                    this.$stage.children(\".center\").removeClass(\"center\");\n                    this.$stage\n                        .children()\n                        .eq(this.current())\n                        .addClass(\"center\");\n                }\n            }\n        }\n    ];\n\n    /**\n\t * Initializes the carousel.\n\t * @protected\n\t */\n    Owl.prototype.initialize = function() {\n        this.enter(\"initializing\");\n        this.trigger(\"initialize\");\n\n        this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n        if (this.settings.autoWidth && !this.is(\"pre-loading\")) {\n            var imgs, nestedSelector, width;\n            imgs = this.$element.find(\"img\");\n            nestedSelector = this.settings.nestedItemSelector\n                ? \".\" + this.settings.nestedItemSelector\n                : undefined;\n            width = this.$element.children(nestedSelector).width();\n\n            if (imgs.length && width <= 0) {\n                this.preloadAutoWidthImages(imgs);\n            }\n        }\n\n        this.$element.addClass(this.options.loadingClass);\n\n        // create stage\n        this.$stage = $(\n            \"<\" +\n                this.settings.stageElement +\n                ' class=\"' +\n                this.settings.stageClass +\n                '\"/>'\n        ).wrap('<div class=\"' + this.settings.stageOuterClass + '\"/>');\n\n        // append stage\n        this.$element.append(this.$stage.parent());\n\n        // append content\n        this.replace(this.$element.children().not(this.$stage.parent()));\n\n        // check visibility\n        if (this.$element.is(\":visible\")) {\n            // update view\n            this.refresh();\n        } else {\n            // invalidate width\n            this.invalidate(\"width\");\n        }\n\n        this.$element\n            .removeClass(this.options.loadingClass)\n            .addClass(this.options.loadedClass);\n\n        // register event handlers\n        this.registerEventHandlers();\n\n        this.leave(\"initializing\");\n        this.trigger(\"initialized\");\n    };\n\n    /**\n\t * Setups the current settings.\n\t * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n\t * @todo Support for media queries by using `matchMedia` would be nice.\n\t * @public\n\t */\n    Owl.prototype.setup = function() {\n        var viewport = this.viewport(),\n            overwrites = this.options.responsive,\n            match = -1,\n            settings = null;\n\n        if (!overwrites) {\n            settings = $.extend({}, this.options);\n        } else {\n            $.each(overwrites, function(breakpoint) {\n                if (breakpoint <= viewport && breakpoint > match) {\n                    match = Number(breakpoint);\n                }\n            });\n\n            settings = $.extend({}, this.options, overwrites[match]);\n            if (typeof settings.stagePadding === \"function\") {\n                settings.stagePadding = settings.stagePadding();\n            }\n            delete settings.responsive;\n\n            // responsive class\n            if (settings.responsiveClass) {\n                this.$element.attr(\n                    \"class\",\n                    this.$element\n                        .attr(\"class\")\n                        .replace(\n                            new RegExp(\n                                \"(\" +\n                                    this.options.responsiveClass +\n                                    \"-)\\\\S+\\\\s\",\n                                \"g\"\n                            ),\n                            \"$1\" + match\n                        )\n                );\n            }\n        }\n\n        this.trigger(\"change\", {\n            property: { name: \"settings\", value: settings }\n        });\n        this._breakpoint = match;\n        this.settings = settings;\n        this.invalidate(\"settings\");\n        this.trigger(\"changed\", {\n            property: { name: \"settings\", value: this.settings }\n        });\n    };\n\n    /**\n\t * Updates option logic if necessery.\n\t * @protected\n\t */\n    Owl.prototype.optionsLogic = function() {\n        if (this.settings.autoWidth) {\n            this.settings.stagePadding = false;\n            this.settings.merge = false;\n        }\n    };\n\n    /**\n\t * Prepares an item before add.\n\t * @todo Rename event parameter `content` to `item`.\n\t * @protected\n\t * @returns {jQuery|HTMLElement} - The item container.\n\t */\n    Owl.prototype.prepare = function(item) {\n        var event = this.trigger(\"prepare\", { content: item });\n\n        if (!event.data) {\n            event.data = $(\"<\" + this.settings.itemElement + \"/>\")\n                .addClass(this.options.itemClass)\n                .append(item);\n        }\n\n        this.trigger(\"prepared\", { content: event.data });\n\n        return event.data;\n    };\n\n    /**\n\t * Updates the view.\n\t * @public\n\t */\n    Owl.prototype.update = function() {\n        var i = 0,\n            n = this._pipe.length,\n            filter = $.proxy(\n                function(p) {\n                    return this[p];\n                },\n                this._invalidated\n            ),\n            cache = {};\n\n        while (i < n) {\n            if (\n                this._invalidated.all ||\n                    $.grep(this._pipe[i].filter, filter).length > 0\n            ) {\n                this._pipe[i].run(cache);\n            }\n            i++;\n        }\n\n        this._invalidated = {};\n\n        !this.is(\"valid\") && this.enter(\"valid\");\n    };\n\n    /**\n\t * Gets the width of the view.\n\t * @public\n\t * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n\t * @returns {Number} - The width of the view in pixel.\n\t */\n    Owl.prototype.width = function(dimension) {\n        dimension = dimension || Owl.Width.Default;\n        switch (dimension) {\n            case Owl.Width.Inner:\n            case Owl.Width.Outer:\n                return this._width;\n            default:\n                return this._width -\n                    this.settings.stagePadding * 2 +\n                    this.settings.margin;\n        }\n    };\n\n    /**\n\t * Refreshes the carousel primarily for adaptive purposes.\n\t * @public\n\t */\n    Owl.prototype.refresh = function() {\n        this.enter(\"refreshing\");\n        this.trigger(\"refresh\");\n\n        this.setup();\n\n        this.optionsLogic();\n\n        this.$element.addClass(this.options.refreshClass);\n\n        this.update();\n\n        this.$element.removeClass(this.options.refreshClass);\n\n        this.leave(\"refreshing\");\n        this.trigger(\"refreshed\");\n    };\n\n    /**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n    Owl.prototype.onThrottledResize = function() {\n        window.clearTimeout(this.resizeTimer);\n        this.resizeTimer = window.setTimeout(\n            this._handlers.onResize,\n            this.settings.responsiveRefreshRate\n        );\n    };\n\n    /**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n    Owl.prototype.onResize = function() {\n        if (!this._items.length) {\n            return false;\n        }\n\n        if (this._width === this.$element.width()) {\n            return false;\n        }\n\n        if (!this.$element.is(\":visible\")) {\n            return false;\n        }\n\n        this.enter(\"resizing\");\n\n        if (this.trigger(\"resize\").isDefaultPrevented()) {\n            this.leave(\"resizing\");\n            return false;\n        }\n\n        this.invalidate(\"width\");\n\n        this.refresh();\n\n        this.leave(\"resizing\");\n        this.trigger(\"resized\");\n    };\n\n    /**\n\t * Registers event handlers.\n\t * @todo Check `msPointerEnabled`\n\t * @todo #261\n\t * @protected\n\t */\n    Owl.prototype.registerEventHandlers = function() {\n        if ($.support.transition) {\n            this.$stage.on(\n                $.support.transition.end + \".owl.core\",\n                $.proxy(this.onTransitionEnd, this)\n            );\n        }\n\n        if (this.settings.responsive !== false) {\n            this.on(window, \"resize\", this._handlers.onThrottledResize);\n        }\n\n        if (this.settings.mouseDrag) {\n            this.$element.addClass(this.options.dragClass);\n            this.$stage.on(\n                \"mousedown.owl.core\",\n                $.proxy(this.onDragStart, this)\n            );\n            this.$stage.on(\n                \"dragstart.owl.core selectstart.owl.core\",\n                function() {\n                    return false;\n                }\n            );\n        }\n\n        if (this.settings.touchDrag) {\n            this.$stage.on(\n                \"touchstart.owl.core\",\n                $.proxy(this.onDragStart, this)\n            );\n            this.$stage.on(\n                \"touchcancel.owl.core\",\n                $.proxy(this.onDragEnd, this)\n            );\n        }\n    };\n\n    /**\n\t * Handles `touchstart` and `mousedown` events.\n\t * @todo Horizontal swipe threshold as option\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n    Owl.prototype.onDragStart = function(event) {\n        var stage = null;\n\n        if (event.which === 3) {\n            return;\n        }\n\n        if ($.support.transform) {\n            stage = this.$stage\n                .css(\"transform\")\n                .replace(/.*\\(|\\)| /g, \"\")\n                .split(\",\");\n            stage = {\n                x: stage[stage.length === 16 ? 12 : 4],\n                y: stage[stage.length === 16 ? 13 : 5]\n            };\n        } else {\n            stage = this.$stage.position();\n            stage = {\n                x: this.settings.rtl\n                    ? stage.left +\n                        this.$stage.width() -\n                        this.width() +\n                        this.settings.margin\n                    : stage.left,\n                y: stage.top\n            };\n        }\n\n        if (this.is(\"animating\")) {\n            $.support.transform ? this.animate(stage.x) : this.$stage.stop();\n            this.invalidate(\"position\");\n        }\n\n        this.$element.toggleClass(\n            this.options.grabClass,\n            event.type === \"mousedown\"\n        );\n\n        this.speed(0);\n\n        this._drag.time = new Date().getTime();\n        this._drag.target = $(event.target);\n        this._drag.stage.start = stage;\n        this._drag.stage.current = stage;\n        this._drag.pointer = this.pointer(event);\n\n        $(\n            document\n        ).on(\"mouseup.owl.core touchend.owl.core\", $.proxy(this.onDragEnd, this));\n\n        $(document).one(\n            \"mousemove.owl.core touchmove.owl.core\",\n            $.proxy(\n                function(event) {\n                    var delta = this.difference(\n                        this._drag.pointer,\n                        this.pointer(event)\n                    );\n\n                    $(document).on(\n                        \"mousemove.owl.core touchmove.owl.core\",\n                        $.proxy(this.onDragMove, this)\n                    );\n\n                    if (\n                        Math.abs(delta.x) < Math.abs(delta.y) &&\n                            this.is(\"valid\")\n                    ) {\n                        return;\n                    }\n\n                    event.preventDefault();\n\n                    this.enter(\"dragging\");\n                    this.trigger(\"drag\");\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Handles the `touchmove` and `mousemove` events.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n    Owl.prototype.onDragMove = function(event) {\n        var minimum = null,\n            maximum = null,\n            pull = null,\n            delta = this.difference(this._drag.pointer, this.pointer(event)),\n            stage = this.difference(this._drag.stage.start, delta);\n\n        if (!this.is(\"dragging\")) {\n            return;\n        }\n\n        event.preventDefault();\n\n        if (this.settings.loop) {\n            minimum = this.coordinates(this.minimum());\n            maximum = this.coordinates(this.maximum() + 1) - minimum;\n            stage.x = ((stage.x - minimum) % maximum + maximum) % maximum +\n                minimum;\n        } else {\n            minimum = this.settings.rtl\n                ? this.coordinates(this.maximum())\n                : this.coordinates(this.minimum());\n            maximum = this.settings.rtl\n                ? this.coordinates(this.minimum())\n                : this.coordinates(this.maximum());\n            pull = this.settings.pullDrag ? (-1) * delta.x / 5 : 0;\n            stage.x = Math.max(\n                Math.min(stage.x, minimum + pull),\n                maximum + pull\n            );\n        }\n\n        this._drag.stage.current = stage;\n\n        this.animate(stage.x);\n    };\n\n    /**\n\t * Handles the `touchend` and `mouseup` events.\n\t * @todo #261\n\t * @todo Threshold for click event\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n    Owl.prototype.onDragEnd = function(event) {\n        var delta = this.difference(this._drag.pointer, this.pointer(event)),\n            stage = this._drag.stage.current,\n            direction = delta.x > 0 ^ this.settings.rtl ? \"left\" : \"right\";\n\n        $(document).off(\".owl.core\");\n\n        this.$element.removeClass(this.options.grabClass);\n\n        if (delta.x !== 0 && this.is(\"dragging\") || !this.is(\"valid\")) {\n            this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n            this.current(\n                this.closest(\n                    stage.x,\n                    delta.x !== 0 ? direction : this._drag.direction\n                )\n            );\n            this.invalidate(\"position\");\n            this.update();\n\n            this._drag.direction = direction;\n\n            if (\n                Math.abs(delta.x) > 3 ||\n                    new Date().getTime() - this._drag.time > 300\n            ) {\n                this._drag.target.one(\"click.owl.core\", function() {\n                    return false;\n                });\n            }\n        }\n\n        if (!this.is(\"dragging\")) {\n            return;\n        }\n\n        this.leave(\"dragging\");\n        this.trigger(\"dragged\");\n    };\n\n    /**\n\t * Gets absolute position of the closest item for a coordinate.\n\t * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n\t * @protected\n\t * @param {Number} coordinate - The coordinate in pixel.\n\t * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n\t * @return {Number} - The absolute position of the closest item.\n\t */\n    Owl.prototype.closest = function(coordinate, direction) {\n        var position = -1,\n            pull = 30,\n            width = this.width(),\n            coordinates = this.coordinates();\n\n        if (!this.settings.freeDrag) {\n            // check closest item\n            $.each(\n                coordinates,\n                $.proxy(\n                    function(index, value) {\n                        // on a left pull, check on current index\n                        if (\n                            direction === \"left\" &&\n                                coordinate > value - pull &&\n                                coordinate < value + pull\n                        ) {\n                            position = index;\n                            // on a right pull, check on previous index\n                            // to do so, subtract width from value and set position = index + 1\n                        } else if (\n                            direction === \"right\" &&\n                                coordinate > value - width - pull &&\n                                coordinate < value - width + pull\n                        ) {\n                            position = index + 1;\n                        } else if (\n                            this.op(coordinate, \"<\", value) &&\n                                this.op(\n                                    coordinate,\n                                    \">\",\n                                    coordinates[index + 1] || value - width\n                                )\n                        ) {\n                            position = direction === \"left\" ? index + 1 : index;\n                        }\n                        return position === -1;\n                    },\n                    this\n                )\n            );\n        }\n\n        if (!this.settings.loop) {\n            // non loop boundries\n            if (this.op(coordinate, \">\", coordinates[this.minimum()])) {\n                position = coordinate = this.minimum();\n            } else if (this.op(coordinate, \"<\", coordinates[this.maximum()])) {\n                position = coordinate = this.maximum();\n            }\n        }\n\n        return position;\n    };\n\n    /**\n\t * Animates the stage.\n\t * @todo #270\n\t * @public\n\t * @param {Number} coordinate - The coordinate in pixels.\n\t */\n    Owl.prototype.animate = function(coordinate) {\n        var animate = this.speed() > 0;\n\n        this.is(\"animating\") && this.onTransitionEnd();\n\n        if (animate) {\n            this.enter(\"animating\");\n            this.trigger(\"translate\");\n        }\n\n        if ($.support.transform3d && $.support.transition) {\n            this.$stage.css({\n                transform: \"translate3d(\" + coordinate + \"px,0px,0px)\",\n                transition: this.speed() / 1000 + \"s\"\n            });\n        } else if (animate) {\n            this.$stage.animate(\n                { left: coordinate + \"px\" },\n                this.speed(),\n                this.settings.fallbackEasing,\n                $.proxy(this.onTransitionEnd, this)\n            );\n        } else {\n            this.$stage.css({ left: coordinate + \"px\" });\n        }\n    };\n\n    /**\n\t * Checks whether the carousel is in a specific state or not.\n\t * @param {String} state - The state to check.\n\t * @returns {Boolean} - The flag which indicates if the carousel is busy.\n\t */\n    Owl.prototype.is = function(state) {\n        return this._states.current[state] && this._states.current[state] > 0;\n    };\n\n    /**\n\t * Sets the absolute position of the current item.\n\t * @public\n\t * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n\t * @returns {Number} - The absolute position of the current item.\n\t */\n    Owl.prototype.current = function(position) {\n        if (position === undefined) {\n            return this._current;\n        }\n\n        if (this._items.length === 0) {\n            return undefined;\n        }\n\n        position = this.normalize(position);\n\n        if (this._current !== position) {\n            var event = this.trigger(\"change\", {\n                property: { name: \"position\", value: position }\n            });\n\n            if (event.data !== undefined) {\n                position = this.normalize(event.data);\n            }\n\n            this._current = position;\n\n            this.invalidate(\"position\");\n\n            this.trigger(\"changed\", {\n                property: { name: \"position\", value: this._current }\n            });\n        }\n\n        return this._current;\n    };\n\n    /**\n\t * Invalidates the given part of the update routine.\n\t * @param {String} [part] - The part to invalidate.\n\t * @returns {Array.<String>} - The invalidated parts.\n\t */\n    Owl.prototype.invalidate = function(part) {\n        if ($.type(part) === \"string\") {\n            this._invalidated[part] = true;\n            this.is(\"valid\") && this.leave(\"valid\");\n        }\n        return $.map(this._invalidated, function(v, i) {\n            return i;\n        });\n    };\n\n    /**\n\t * Resets the absolute position of the current item.\n\t * @public\n\t * @param {Number} position - The absolute position of the new item.\n\t */\n    Owl.prototype.reset = function(position) {\n        position = this.normalize(position);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this._speed = 0;\n        this._current = position;\n\n        this.suppress([ \"translate\", \"translated\" ]);\n\n        this.animate(this.coordinates(position));\n\n        this.release([ \"translate\", \"translated\" ]);\n    };\n\n    /**\n\t * Normalizes an absolute or a relative position of an item.\n\t * @public\n\t * @param {Number} position - The absolute or relative position to normalize.\n\t * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n\t * @returns {Number} - The normalized position.\n\t */\n    Owl.prototype.normalize = function(position, relative) {\n        var n = this._items.length, m = relative ? 0 : this._clones.length;\n\n        if (!this.isNumeric(position) || n < 1) {\n            position = undefined;\n        } else if (position < 0 || position >= n + m) {\n            position = ((position - m / 2) % n + n) % n + m / 2;\n        }\n\n        return position;\n    };\n\n    /**\n\t * Converts an absolute position of an item into a relative one.\n\t * @public\n\t * @param {Number} position - The absolute position to convert.\n\t * @returns {Number} - The converted position.\n\t */\n    Owl.prototype.relative = function(position) {\n        position -= this._clones.length / 2;\n        return this.normalize(position, true);\n    };\n\n    /**\n\t * Gets the maximum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n    Owl.prototype.maximum = function(relative) {\n        var settings = this.settings,\n            maximum = this._coordinates.length,\n            iterator,\n            reciprocalItemsWidth,\n            elementWidth;\n\n        if (settings.loop) {\n            maximum = this._clones.length / 2 + this._items.length - 1;\n        } else if (settings.autoWidth || settings.merge) {\n            iterator = this._items.length;\n            reciprocalItemsWidth = this._items[--iterator].width();\n            elementWidth = this.$element.width();\n            while (iterator--) {\n                reciprocalItemsWidth += this._items[iterator].width() +\n                    this.settings.margin;\n                if (reciprocalItemsWidth > elementWidth) {\n                    break;\n                }\n            }\n            maximum = iterator + 1;\n        } else if (settings.center) {\n            maximum = this._items.length - 1;\n        } else {\n            maximum = this._items.length - settings.items;\n        }\n\n        if (relative) {\n            maximum -= this._clones.length / 2;\n        }\n\n        return Math.max(maximum, 0);\n    };\n\n    /**\n\t * Gets the minimum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n    Owl.prototype.minimum = function(relative) {\n        return relative ? 0 : this._clones.length / 2;\n    };\n\n    /**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n    Owl.prototype.items = function(position) {\n        if (position === undefined) {\n            return this._items.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._items[position];\n    };\n\n    /**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n    Owl.prototype.mergers = function(position) {\n        if (position === undefined) {\n            return this._mergers.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._mergers[position];\n    };\n\n    /**\n\t * Gets the absolute positions of clones for an item.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n\t */\n    Owl.prototype.clones = function(position) {\n        var odd = this._clones.length / 2,\n            even = odd + this._items.length,\n            map = function(index) {\n                return index % 2 === 0\n                    ? even + index / 2\n                    : odd - (index + 1) / 2;\n            };\n\n        if (position === undefined) {\n            return $.map(this._clones, function(v, i) {\n                return map(i);\n            });\n        }\n\n        return $.map(this._clones, function(v, i) {\n            return v === position ? map(i) : null;\n        });\n    };\n\n    /**\n\t * Sets the current animation speed.\n\t * @public\n\t * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n\t * @returns {Number} - The current animation speed in milliseconds.\n\t */\n    Owl.prototype.speed = function(speed) {\n        if (speed !== undefined) {\n            this._speed = speed;\n        }\n\n        return this._speed;\n    };\n\n    /**\n\t * Gets the coordinate of an item.\n\t * @todo The name of this method is missleanding.\n\t * @public\n\t * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n\t * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n\t */\n    Owl.prototype.coordinates = function(position) {\n        var multiplier = 1, newPosition = position - 1, coordinate;\n\n        if (position === undefined) {\n            return $.map(\n                this._coordinates,\n                $.proxy(\n                    function(coordinate, index) {\n                        return this.coordinates(index);\n                    },\n                    this\n                )\n            );\n        }\n\n        if (this.settings.center) {\n            if (this.settings.rtl) {\n                multiplier = -1;\n                newPosition = position + 1;\n            }\n\n            coordinate = this._coordinates[position];\n            coordinate += (this.width() -\n                coordinate +\n                (this._coordinates[newPosition] || 0)) /\n                2 *\n                multiplier;\n        } else {\n            coordinate = this._coordinates[newPosition] || 0;\n        }\n\n        coordinate = Math.ceil(coordinate);\n\n        return coordinate;\n    };\n\n    /**\n\t * Calculates the speed for a translation.\n\t * @protected\n\t * @param {Number} from - The absolute position of the start item.\n\t * @param {Number} to - The absolute position of the target item.\n\t * @param {Number} [factor=undefined] - The time factor in milliseconds.\n\t * @returns {Number} - The time in milliseconds for the translation.\n\t */\n    Owl.prototype.duration = function(from, to, factor) {\n        if (factor === 0) {\n            return 0;\n        }\n\n        return Math.min(Math.max(Math.abs(to - from), 1), 6) *\n            Math.abs(factor || this.settings.smartSpeed);\n    };\n\n    /**\n\t * Slides to the specified item.\n\t * @public\n\t * @param {Number} position - The position of the item.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n    Owl.prototype.to = function(position, speed) {\n        var current = this.current(),\n            revert = null,\n            distance = position - this.relative(current),\n            direction = (distance > 0) - (distance < 0),\n            items = this._items.length,\n            minimum = this.minimum(),\n            maximum = this.maximum();\n\n        if (this.settings.loop) {\n            if (!this.settings.rewind && Math.abs(distance) > items / 2) {\n                distance += direction * (-1) * items;\n            }\n\n            position = current + distance;\n            revert = ((position - minimum) % items + items) % items + minimum;\n\n            if (\n                revert !== position &&\n                    revert - distance <= maximum &&\n                    revert - distance > 0\n            ) {\n                current = revert - distance;\n                position = revert;\n                this.reset(current);\n            }\n        } else if (this.settings.rewind) {\n            maximum += 1;\n            position = (position % maximum + maximum) % maximum;\n        } else {\n            position = Math.max(minimum, Math.min(maximum, position));\n        }\n\n        this.speed(this.duration(current, position, speed));\n        this.current(position);\n\n        if (this.$element.is(\":visible\")) {\n            this.update();\n        }\n    };\n\n    /**\n\t * Slides to the next item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n    Owl.prototype.next = function(speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) + 1, speed);\n    };\n\n    /**\n\t * Slides to the previous item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n    Owl.prototype.prev = function(speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) - 1, speed);\n    };\n\n    /**\n\t * Handles the end of an animation.\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n    Owl.prototype.onTransitionEnd = function(event) {\n        // if css2 animation then event object is undefined\n        if (event !== undefined) {\n            event.stopPropagation();\n\n            // Catch only owl-stage transitionEnd event\n            if (\n                (event.target || event.srcElement || event.originalTarget) !==\n                    this.$stage.get(0)\n            ) {\n                return false;\n            }\n        }\n\n        this.leave(\"animating\");\n        this.trigger(\"translated\");\n    };\n\n    /**\n\t * Gets viewport width.\n\t * @protected\n\t * @return {Number} - The width in pixel.\n\t */\n    Owl.prototype.viewport = function() {\n        var width;\n        if (this.options.responsiveBaseElement !== window) {\n            width = $(this.options.responsiveBaseElement).width();\n        } else if (window.innerWidth) {\n            width = window.innerWidth;\n        } else if (\n            document.documentElement && document.documentElement.clientWidth\n        ) {\n            width = document.documentElement.clientWidth;\n        } else {\n            throw \"Can not detect viewport width.\";\n        }\n        return width;\n    };\n\n    /**\n\t * Replaces the current content.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The new content.\n\t */\n    Owl.prototype.replace = function(content) {\n        this.$stage.empty();\n        this._items = [];\n\n        if (content) {\n            content = content instanceof jQuery ? content : $(content);\n        }\n\n        if (this.settings.nestedItemSelector) {\n            content = content.find(\".\" + this.settings.nestedItemSelector);\n        }\n\n        content.filter(function() {\n            return this.nodeType === 1;\n        }).each(\n            $.proxy(\n                function(index, item) {\n                    item = this.prepare(item);\n                    this.$stage.append(item);\n                    this._items.push(item);\n                    this._mergers.push(\n                        item\n                            .find(\"[data-merge]\")\n                            .addBack(\"[data-merge]\")\n                            .attr(\"data-merge\") *\n                            1 ||\n                            1\n                    );\n                },\n                this\n            )\n        );\n\n        this.reset(\n            this.isNumeric(this.settings.startPosition)\n                ? this.settings.startPosition\n                : 0\n        );\n\n        this.invalidate(\"items\");\n    };\n\n    /**\n\t * Adds an item.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The item content to add.\n\t * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n\t */\n    Owl.prototype.add = function(content, position) {\n        var current = this.relative(this._current);\n\n        position = position === undefined\n            ? this._items.length\n            : this.normalize(position, true);\n        content = content instanceof jQuery ? content : $(content);\n\n        this.trigger(\"add\", { content: content, position: position });\n\n        content = this.prepare(content);\n\n        if (this._items.length === 0 || position === this._items.length) {\n            this._items.length === 0 && this.$stage.append(content);\n            this._items.length !== 0 &&\n                this._items[position - 1].after(content);\n            this._items.push(content);\n            this._mergers.push(\n                content\n                    .find(\"[data-merge]\")\n                    .addBack(\"[data-merge]\")\n                    .attr(\"data-merge\") *\n                    1 ||\n                    1\n            );\n        } else {\n            this._items[position].before(content);\n            this._items.splice(position, 0, content);\n            this._mergers.splice(\n                position,\n                0,\n                content\n                    .find(\"[data-merge]\")\n                    .addBack(\"[data-merge]\")\n                    .attr(\"data-merge\") *\n                    1 ||\n                    1\n            );\n        }\n\n        this._items[current] && this.reset(this._items[current].index());\n\n        this.invalidate(\"items\");\n\n        this.trigger(\"added\", { content: content, position: position });\n    };\n\n    /**\n\t * Removes an item by its position.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {Number} position - The relative position of the item to remove.\n\t */\n    Owl.prototype.remove = function(position) {\n        position = this.normalize(position, true);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this.trigger(\"remove\", {\n            content: this._items[position],\n            position: position\n        });\n\n        this._items[position].remove();\n        this._items.splice(position, 1);\n        this._mergers.splice(position, 1);\n\n        this.invalidate(\"items\");\n\n        this.trigger(\"removed\", { content: null, position: position });\n    };\n\n    /**\n\t * Preloads images with auto width.\n\t * @todo Replace by a more generic approach\n\t * @protected\n\t */\n    Owl.prototype.preloadAutoWidthImages = function(images) {\n        images.each(\n            $.proxy(\n                function(i, element) {\n                    this.enter(\"pre-loading\");\n                    element = $(element);\n                    $(new Image()).one(\n                        \"load\",\n                        $.proxy(\n                            function(e) {\n                                element.attr(\"src\", e.target.src);\n                                element.css(\"opacity\", 1);\n                                this.leave(\"pre-loading\");\n                                !this.is(\"pre-loading\") &&\n                                    !this.is(\"initializing\") &&\n                                    this.refresh();\n                            },\n                            this\n                        )\n                    ).attr(\"src\", element.attr(\"src\") || element.attr(\"data-src\") || element.attr(\"data-src-retina\"));\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Destroys the carousel.\n\t * @public\n\t */\n    Owl.prototype.destroy = function() {\n        this.$element.off(\".owl.core\");\n        this.$stage.off(\".owl.core\");\n        $(document).off(\".owl.core\");\n\n        if (this.settings.responsive !== false) {\n            window.clearTimeout(this.resizeTimer);\n            this.off(window, \"resize\", this._handlers.onThrottledResize);\n        }\n\n        for (var i in this._plugins) {\n            this._plugins[i].destroy();\n        }\n\n        this.$stage.children(\".cloned\").remove();\n\n        this.$stage.unwrap();\n        this.$stage.children().contents().unwrap();\n        this.$stage.children().unwrap();\n\n        this.$element\n            .removeClass(this.options.refreshClass)\n            .removeClass(this.options.loadingClass)\n            .removeClass(this.options.loadedClass)\n            .removeClass(this.options.rtlClass)\n            .removeClass(this.options.dragClass)\n            .removeClass(this.options.grabClass)\n            .attr(\n                \"class\",\n                this.$element\n                    .attr(\"class\")\n                    .replace(\n                        new RegExp(\n                            this.options.responsiveClass + \"-\\\\S+\\\\s\",\n                            \"g\"\n                        ),\n                        \"\"\n                    )\n            )\n            .removeData(\"owl.carousel\");\n    };\n\n    /**\n\t * Operators to calculate right-to-left and left-to-right.\n\t * @protected\n\t * @param {Number} [a] - The left side operand.\n\t * @param {String} [o] - The operator.\n\t * @param {Number} [b] - The right side operand.\n\t */\n    Owl.prototype.op = function(a, o, b) {\n        var rtl = this.settings.rtl;\n        switch (o) {\n            case \"<\":\n                return rtl ? a > b : a < b;\n            case \">\":\n                return rtl ? a < b : a > b;\n            case \">=\":\n                return rtl ? a <= b : a >= b;\n            case \"<=\":\n                return rtl ? a >= b : a <= b;\n            default:\n                break;\n        }\n    };\n\n    /**\n\t * Attaches to an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The event handler to attach.\n\t * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n\t */\n    Owl.prototype.on = function(element, event, listener, capture) {\n        if (element.addEventListener) {\n            element.addEventListener(event, listener, capture);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, listener);\n        }\n    };\n\n    /**\n\t * Detaches from an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The attached event handler to detach.\n\t * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n\t */\n    Owl.prototype.off = function(element, event, listener, capture) {\n        if (element.removeEventListener) {\n            element.removeEventListener(event, listener, capture);\n        } else if (element.detachEvent) {\n            element.detachEvent(\"on\" + event, listener);\n        }\n    };\n\n    /**\n\t * Triggers a public event.\n\t * @todo Remove `status`, `relatedTarget` should be used instead.\n\t * @protected\n\t * @param {String} name - The event name.\n\t * @param {*} [data=null] - The event data.\n\t * @param {String} [namespace=carousel] - The event namespace.\n\t * @param {String} [state] - The state which is associated with the event.\n\t * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n\t * @returns {Event} - The event arguments.\n\t */\n    Owl.prototype.trigger = function(name, data, namespace, state, enter) {\n        var status = {\n            item: { count: this._items.length, index: this.current() }\n        },\n            handler = $.camelCase(\n                $.grep([ \"on\", name, namespace ], function(v) {\n                    return v;\n                }).join(\"-\").toLowerCase()\n            ),\n            event = $.Event(\n                [ name, \"owl\", namespace || \"carousel\" ]\n                    .join(\".\")\n                    .toLowerCase(),\n                $.extend({ relatedTarget: this }, status, data)\n            );\n\n        if (!this._supress[name]) {\n            $.each(this._plugins, function(name, plugin) {\n                if (plugin.onTrigger) {\n                    plugin.onTrigger(event);\n                }\n            });\n\n            this.register({ type: Owl.Type.Event, name: name });\n            this.$element.trigger(event);\n\n            if (this.settings && typeof this.settings[handler] === \"function\") {\n                this.settings[handler].call(this, event);\n            }\n        }\n\n        return event;\n    };\n\n    /**\n\t * Enters a state.\n\t * @param name - The state name.\n\t */\n    Owl.prototype.enter = function(name) {\n        $.each(\n            [ name ].concat(this._states.tags[name] || []),\n            $.proxy(\n                function(i, name) {\n                    if (this._states.current[name] === undefined) {\n                        this._states.current[name] = 0;\n                    }\n\n                    this._states.current[name]++;\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Leaves a state.\n\t * @param name - The state name.\n\t */\n    Owl.prototype.leave = function(name) {\n        $.each(\n            [ name ].concat(this._states.tags[name] || []),\n            $.proxy(\n                function(i, name) {\n                    this._states.current[name]--;\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Registers an event or state.\n\t * @public\n\t * @param {Object} object - The event or state to register.\n\t */\n    Owl.prototype.register = function(object) {\n        if (object.type === Owl.Type.Event) {\n            if (!$.event.special[object.name]) {\n                $.event.special[object.name] = {};\n            }\n\n            if (!$.event.special[object.name].owl) {\n                var _default = $.event.special[object.name]._default;\n                $.event.special[object.name]._default = function(e) {\n                    if (\n                        _default &&\n                            _default.apply &&\n                            (!e.namespace || e.namespace.indexOf(\"owl\") === -1)\n                    ) {\n                        return _default.apply(this, arguments);\n                    }\n                    return e.namespace && e.namespace.indexOf(\"owl\") > -1;\n                };\n                $.event.special[object.name].owl = true;\n            }\n        } else if (object.type === Owl.Type.State) {\n            if (!this._states.tags[object.name]) {\n                this._states.tags[object.name] = object.tags;\n            } else {\n                this._states.tags[object.name] = this._states.tags[object.name].concat(\n                    object.tags\n                );\n            }\n\n            this._states.tags[object.name] = $.grep(\n                this._states.tags[object.name],\n                $.proxy(\n                    function(tag, i) {\n                        return $.inArray(\n                            tag,\n                            this._states.tags[object.name]\n                        ) ===\n                            i;\n                    },\n                    this\n                )\n            );\n        }\n    };\n\n    /**\n\t * Suppresses events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to suppress.\n\t */\n    Owl.prototype.suppress = function(events) {\n        $.each(\n            events,\n            $.proxy(\n                function(index, event) {\n                    this._supress[event] = true;\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Releases suppressed events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to release.\n\t */\n    Owl.prototype.release = function(events) {\n        $.each(\n            events,\n            $.proxy(\n                function(index, event) {\n                    delete this._supress[event];\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Gets unified pointer coordinates from event.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} - The `mousedown` or `touchstart` event.\n\t * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n\t */\n    Owl.prototype.pointer = function(event) {\n        var result = { x: null, y: null };\n\n        event = event.originalEvent || event || window.event;\n\n        event = event.touches && event.touches.length\n            ? event.touches[0]\n            : event.changedTouches && event.changedTouches.length\n                ? event.changedTouches[0]\n                : event;\n\n        if (event.pageX) {\n            result.x = event.pageX;\n            result.y = event.pageY;\n        } else {\n            result.x = event.clientX;\n            result.y = event.clientY;\n        }\n\n        return result;\n    };\n\n    /**\n\t * Determines if the input is a Number or something that can be coerced to a Number\n\t * @protected\n\t * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n\t * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n\t */\n    Owl.prototype.isNumeric = function(number) {\n        return !isNaN(parseFloat(number));\n    };\n\n    /**\n\t * Gets the difference of two vectors.\n\t * @todo #261\n\t * @protected\n\t * @param {Object} - The first vector.\n\t * @param {Object} - The second vector.\n\t * @returns {Object} - The difference.\n\t */\n    Owl.prototype.difference = function(first, second) {\n        return { x: first.x - second.x, y: first.y - second.y };\n    };\n\n    /**\n\t * The jQuery Plugin for the Owl Carousel\n\t * @todo Navigation plugin `next` and `prev`\n\t * @public\n\t */\n    $.fn.owlCarousel = function(option) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        return this.each(function() {\n            var $this = $(this), data = $this.data(\"owl.carousel\");\n\n            if (!data) {\n                data = new Owl(this, typeof option == \"object\" && option);\n                $this.data(\"owl.carousel\", data);\n\n                $.each(\n                    [\n                        \"next\",\n                        \"prev\",\n                        \"to\",\n                        \"destroy\",\n                        \"refresh\",\n                        \"replace\",\n                        \"add\",\n                        \"remove\"\n                    ],\n                    function(i, event) {\n                        data.register({ type: Owl.Type.Event, name: event });\n                        data.$element.on(\n                            event + \".owl.carousel.core\",\n                            $.proxy(\n                                function(e) {\n                                    if (\n                                        e.namespace && e.relatedTarget !== this\n                                    ) {\n                                        this.suppress([ event ]);\n                                        data[event].apply(\n                                            this,\n                                            [].slice.call(arguments, 1)\n                                        );\n                                        this.release([ event ]);\n                                    }\n                                },\n                                data\n                            )\n                        );\n                    }\n                );\n            }\n\n            if (typeof option == \"string\" && option.charAt(0) !== \"_\") {\n                data[option].apply(data, args);\n            }\n        });\n    };\n\n    /**\n\t * The constructor for the jQuery Plugin\n\t * @public\n\t */\n    $.fn.owlCarousel.Constructor = Owl;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    /**\n\t * Creates the auto refresh plugin.\n\t * @class The Auto Refresh Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n    var AutoRefresh = function(carousel) {\n        /**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n        this._core = carousel;\n\n        /**\n\t\t * Refresh interval.\n\t\t * @protected\n\t\t * @type {number}\n\t\t */\n        this._interval = null;\n\n        /**\n\t\t * Whether the element is currently visible or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n        this._visible = null;\n\n        /**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._handlers = {\n            \"initialized.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._core.settings.autoRefresh) {\n                        this.watch();\n                    }\n                },\n                this\n            )\n        };\n\n        // set default options\n        this._core.options = $.extend(\n            {},\n            AutoRefresh.Defaults,\n            this._core.options\n        );\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t */\n    AutoRefresh.Defaults = { autoRefresh: true, autoRefreshInterval: 500 };\n\n    /**\n\t * Watches the element.\n\t */\n    AutoRefresh.prototype.watch = function() {\n        if (this._interval) {\n            return;\n        }\n\n        this._visible = this._core.$element.is(\":visible\");\n        this._interval = window.setInterval(\n            $.proxy(this.refresh, this),\n            this._core.settings.autoRefreshInterval\n        );\n    };\n\n    /**\n\t * Refreshes the element.\n\t */\n    AutoRefresh.prototype.refresh = function() {\n        if (this._core.$element.is(\":visible\") === this._visible) {\n            return;\n        }\n\n        this._visible = !this._visible;\n\n        this._core.$element.toggleClass(\"owl-hidden\", !this._visible);\n\n        this._visible &&\n            (this._core.invalidate(\"width\") && this._core.refresh());\n    };\n\n    /**\n\t * Destroys the plugin.\n\t */\n    AutoRefresh.prototype.destroy = function() {\n        var handler, property;\n\n        window.clearInterval(this._interval);\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    /**\n\t * Creates the lazy plugin.\n\t * @class The Lazy Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n    var Lazy = function(carousel) {\n        /**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n        this._core = carousel;\n\n        /**\n\t\t * Already loaded items.\n\t\t * @protected\n\t\t * @type {Array.<jQuery>}\n\t\t */\n        this._loaded = [];\n\n        /**\n\t\t * Event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._handlers = {\n            \"initialized.owl.carousel change.owl.carousel resized.owl.carousel\": $.proxy(\n                function(e) {\n                    if (!e.namespace) {\n                        return;\n                    }\n\n                    if (!this._core.settings || !this._core.settings.lazyLoad) {\n                        return;\n                    }\n\n                    if (\n                        e.property && e.property.name == \"position\" ||\n                            e.type == \"initialized\"\n                    ) {\n                        var settings = this._core.settings,\n                            n = settings.center &&\n                                Math.ceil(settings.items / 2) ||\n                                settings.items,\n                            i = settings.center && n * (-1) || 0,\n                            position = (e.property &&\n                                e.property.value !== undefined\n                                ? e.property.value\n                                : this._core.current()) +\n                                i,\n                            clones = this._core.clones().length,\n                            load = $.proxy(\n                                function(i, v) {\n                                    this.load(v);\n                                },\n                                this\n                            );\n\n                        while (i++ < n) {\n                            this.load(\n                                clones / 2 + this._core.relative(position)\n                            );\n                            clones &&\n                                $.each(\n                                    this._core.clones(\n                                        this._core.relative(position)\n                                    ),\n                                    load\n                                );\n                            position++;\n                        }\n                    }\n                },\n                this\n            )\n        };\n\n        // set the default options\n        this._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n        // register event handler\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t */\n    Lazy.Defaults = { lazyLoad: false };\n\n    /**\n\t * Loads all resources of an item at the specified position.\n\t * @param {Number} position - The absolute position of the item.\n\t * @protected\n\t */\n    Lazy.prototype.load = function(position) {\n        var $item = this._core.$stage.children().eq(position),\n            $elements = $item && $item.find(\".owl-lazy\");\n\n        if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n            return;\n        }\n\n        $elements.each(\n            $.proxy(\n                function(index, element) {\n                    var $element = $(element),\n                        image,\n                        url = window.devicePixelRatio > 1 &&\n                            $element.attr(\"data-src-retina\") ||\n                            $element.attr(\"data-src\");\n\n                    this._core.trigger(\n                        \"load\",\n                        { element: $element, url: url },\n                        \"lazy\"\n                    );\n\n                    if ($element.is(\"img\")) {\n                        $element.one(\n                            \"load.owl.lazy\",\n                            $.proxy(\n                                function() {\n                                    $element.css(\"opacity\", 1);\n                                    this._core.trigger(\n                                        \"loaded\",\n                                        { element: $element, url: url },\n                                        \"lazy\"\n                                    );\n                                },\n                                this\n                            )\n                        ).attr(\"src\", url);\n                    } else {\n                        image = new Image();\n                        image.onload = $.proxy(\n                            function() {\n                                $element.css({\n                                    \"background-image\": \"url(\" + url + \")\",\n                                    opacity: \"1\"\n                                });\n                                this._core.trigger(\n                                    \"loaded\",\n                                    { element: $element, url: url },\n                                    \"lazy\"\n                                );\n                            },\n                            this\n                        );\n                        image.src = url;\n                    }\n                },\n                this\n            )\n        );\n\n        this._loaded.push($item.get(0));\n    };\n\n    /**\n\t * Destroys the plugin.\n\t * @public\n\t */\n    Lazy.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this._core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    /**\n\t * Creates the auto height plugin.\n\t * @class The Auto Height Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n    var AutoHeight = function(carousel) {\n        /**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n        this._core = carousel;\n\n        /**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._handlers = {\n            \"initialized.owl.carousel refreshed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._core.settings.autoHeight) {\n                        this.update();\n                    }\n                },\n                this\n            ),\n            \"changed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (\n                        e.namespace &&\n                            this._core.settings.autoHeight &&\n                            e.property.name == \"position\"\n                    ) {\n                        this.update();\n                    }\n                },\n                this\n            ),\n            \"loaded.owl.lazy\": $.proxy(\n                function(e) {\n                    if (\n                        e.namespace &&\n                            this._core.settings.autoHeight &&\n                            e.element\n                                .closest(\".\" + this._core.settings.itemClass)\n                                .index() ===\n                                this._core.current()\n                    ) {\n                        this.update();\n                    }\n                },\n                this\n            )\n        };\n\n        // set default options\n        this._core.options = $.extend(\n            {},\n            AutoHeight.Defaults,\n            this._core.options\n        );\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t */\n    AutoHeight.Defaults = { autoHeight: false, autoHeightClass: \"owl-height\" };\n\n    /**\n\t * Updates the view.\n\t */\n    AutoHeight.prototype.update = function() {\n        var start = this._core._current,\n            end = start + this._core.settings.items,\n            visible = this._core.$stage.children().toArray().slice(start, end),\n            heights = [],\n            maxheight = 0;\n\n        $.each(visible, function(index, item) {\n            heights.push($(item).height());\n        });\n\n        maxheight = Math.max.apply(null, heights);\n\n        this._core.$stage\n            .parent()\n            .height(maxheight)\n            .addClass(this._core.settings.autoHeightClass);\n    };\n\n    AutoHeight.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    /**\n\t * Creates the video plugin.\n\t * @class The Video Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n    var Video = function(carousel) {\n        /**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n        this._core = carousel;\n\n        /**\n\t\t * Cache all video URLs.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._videos = {};\n\n        /**\n\t\t * Current playing item.\n\t\t * @protected\n\t\t * @type {jQuery}\n\t\t */\n        this._playing = null;\n\n        /**\n\t\t * All event handlers.\n\t\t * @todo The cloned content removale is too late\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._handlers = {\n            \"initialized.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace) {\n                        this._core.register({\n                            type: \"state\",\n                            name: \"playing\",\n                            tags: [ \"interacting\" ]\n                        });\n                    }\n                },\n                this\n            ),\n            \"resize.owl.carousel\": $.proxy(\n                function(e) {\n                    if (\n                        e.namespace &&\n                            this._core.settings.video &&\n                            this.isInFullScreen()\n                    ) {\n                        e.preventDefault();\n                    }\n                },\n                this\n            ),\n            \"refreshed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._core.is(\"resizing\")) {\n                        this._core.$stage\n                            .find(\".cloned .owl-video-frame\")\n                            .remove();\n                    }\n                },\n                this\n            ),\n            \"changed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (\n                        e.namespace &&\n                            e.property.name === \"position\" &&\n                            this._playing\n                    ) {\n                        this.stop();\n                    }\n                },\n                this\n            ),\n            \"prepared.owl.carousel\": $.proxy(\n                function(e) {\n                    if (!e.namespace) {\n                        return;\n                    }\n\n                    var $element = $(e.content).find(\".owl-video\");\n\n                    if ($element.length) {\n                        $element.css(\"display\", \"none\");\n                        this.fetch($element, $(e.content));\n                    }\n                },\n                this\n            )\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n\n        this._core.$element.on(\n            \"click.owl.video\",\n            \".owl-video-play-icon\",\n            $.proxy(\n                function(e) {\n                    this.play(e);\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t */\n    Video.Defaults = { video: false, videoHeight: false, videoWidth: false };\n\n    /**\n\t * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {jQuery} item - The item containing the video.\n\t */\n    Video.prototype.fetch = function(target, item) {\n        var type = (function() {\n            if (target.attr(\"data-vimeo-id\")) {\n                return \"vimeo\";\n            } else if (target.attr(\"data-vzaar-id\")) {\n                return \"vzaar\";\n            } else {\n                return \"youtube\";\n            }\n        })(),\n            id = target.attr(\"data-vimeo-id\") ||\n                target.attr(\"data-youtube-id\") ||\n                target.attr(\"data-vzaar-id\"),\n            width = target.attr(\"data-width\") || this._core.settings.videoWidth,\n            height = target.attr(\"data-height\") ||\n                this._core.settings.videoHeight,\n            url = target.attr(\"href\");\n\n        if (url) {\n            /*\n\t\t\t\t\tParses the id's out of the following urls (and probably more):\n\t\t\t\t\thttps://www.youtube.com/watch?v=:id\n\t\t\t\t\thttps://youtu.be/:id\n\t\t\t\t\thttps://vimeo.com/:id\n\t\t\t\t\thttps://vimeo.com/channels/:channel/:id\n\t\t\t\t\thttps://vimeo.com/groups/:group/videos/:id\n\t\t\t\t\thttps://app.vzaar.com/videos/:id\n\n\t\t\t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n\t\t\t*/\n            id = url.match(\n                /(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/\n            );\n\n            if (id[3].indexOf(\"youtu\") > -1) {\n                type = \"youtube\";\n            } else if (id[3].indexOf(\"vimeo\") > -1) {\n                type = \"vimeo\";\n            } else if (id[3].indexOf(\"vzaar\") > -1) {\n                type = \"vzaar\";\n            } else {\n                throw new Error(\"Video URL not supported.\");\n            }\n            id = id[6];\n        } else {\n            throw new Error(\"Missing video URL.\");\n        }\n\n        this._videos[url] = {\n            type: type,\n            id: id,\n            width: width,\n            height: height\n        };\n\n        item.attr(\"data-video\", url);\n\n        this.thumbnail(target, this._videos[url]);\n    };\n\n    /**\n\t * Creates video thumbnail.\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {Object} info - The video info object.\n\t * @see `fetch`\n\t */\n    Video.prototype.thumbnail = function(target, video) {\n        var tnLink,\n            icon,\n            path,\n            dimensions = video.width && video.height\n                ? 'style=\"width:' +\n                    video.width +\n                    \"px;height:\" +\n                    video.height +\n                    'px;\"'\n                : \"\",\n            customTn = target.find(\"img\"),\n            srcType = \"src\",\n            lazyClass = \"\",\n            settings = this._core.settings,\n            create = function(path) {\n                icon = '<div class=\"owl-video-play-icon\"></div>';\n\n                if (settings.lazyLoad) {\n                    tnLink = '<div class=\"owl-video-tn ' +\n                        lazyClass +\n                        '\" ' +\n                        srcType +\n                        '=\"' +\n                        path +\n                        '\"></div>';\n                } else {\n                    tnLink = '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' +\n                        path +\n                        ')\"></div>';\n                }\n                target.after(tnLink);\n                target.after(icon);\n            };\n\n        // wrap video content into owl-video-wrapper div\n        target.wrap('<div class=\"owl-video-wrapper\"' + dimensions + \"></div>\");\n\n        if (this._core.settings.lazyLoad) {\n            srcType = \"data-src\";\n            lazyClass = \"owl-lazy\";\n        }\n\n        // custom thumbnail\n        if (customTn.length) {\n            create(customTn.attr(srcType));\n            customTn.remove();\n            return false;\n        }\n\n        if (video.type === \"youtube\") {\n            path = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n            create(path);\n        } else if (video.type === \"vimeo\") {\n            $.ajax({\n                type: \"GET\",\n                url: \"//vimeo.com/api/v2/video/\" + video.id + \".json\",\n                jsonp: \"callback\",\n                dataType: \"jsonp\",\n                success: function(data) {\n                    path = data[0].thumbnail_large;\n                    create(path);\n                }\n            });\n        } else if (video.type === \"vzaar\") {\n            $.ajax({\n                type: \"GET\",\n                url: \"//vzaar.com/api/videos/\" + video.id + \".json\",\n                jsonp: \"callback\",\n                dataType: \"jsonp\",\n                success: function(data) {\n                    path = data.framegrab_url;\n                    create(path);\n                }\n            });\n        }\n    };\n\n    /**\n\t * Stops the current video.\n\t * @public\n\t */\n    Video.prototype.stop = function() {\n        this._core.trigger(\"stop\", null, \"video\");\n        this._playing.find(\".owl-video-frame\").remove();\n        this._playing.removeClass(\"owl-video-playing\");\n        this._playing = null;\n        this._core.leave(\"playing\");\n        this._core.trigger(\"stopped\", null, \"video\");\n    };\n\n    /**\n\t * Starts the current video.\n\t * @public\n\t * @param {Event} event - The event arguments.\n\t */\n    Video.prototype.play = function(event) {\n        var target = $(event.target),\n            item = target.closest(\".\" + this._core.settings.itemClass),\n            video = this._videos[item.attr(\"data-video\")],\n            width = video.width || \"100%\",\n            height = video.height || this._core.$stage.height(),\n            html;\n\n        if (this._playing) {\n            return;\n        }\n\n        this._core.enter(\"playing\");\n        this._core.trigger(\"play\", null, \"video\");\n\n        item = this._core.items(this._core.relative(item.index()));\n\n        this._core.reset(item.index());\n\n        if (video.type === \"youtube\") {\n            html = '<iframe width=\"' +\n                width +\n                '\" height=\"' +\n                height +\n                '\" src=\"//www.youtube.com/embed/' +\n                video.id +\n                \"?autoplay=1&v=\" +\n                video.id +\n                '\" frameborder=\"0\" allowfullscreen></iframe>';\n        } else if (video.type === \"vimeo\") {\n            html = '<iframe src=\"//player.vimeo.com/video/' +\n                video.id +\n                '?autoplay=1\" width=\"' +\n                width +\n                '\" height=\"' +\n                height +\n                '\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\n        } else if (video.type === \"vzaar\") {\n            html = '<iframe frameborder=\"0\"' +\n                'height=\"' +\n                height +\n                '\"' +\n                'width=\"' +\n                width +\n                '\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +\n                'src=\"//view.vzaar.com/' +\n                video.id +\n                '/player?autoplay=true\"></iframe>';\n        }\n\n        $(\n            '<div class=\"owl-video-frame\">' + html + \"</div>\"\n        ).insertAfter(item.find(\".owl-video\"));\n\n        this._playing = item.addClass(\"owl-video-playing\");\n    };\n\n    /**\n\t * Checks whether an video is currently in full screen mode or not.\n\t * @todo Bad style because looks like a readonly method but changes members.\n\t * @protected\n\t * @returns {Boolean}\n\t */\n    Video.prototype.isInFullScreen = function() {\n        var element = document.fullscreenElement ||\n            document.mozFullScreenElement ||\n            document.webkitFullscreenElement;\n\n        return element && $(element).parent().hasClass(\"owl-video-frame\");\n    };\n\n    /**\n\t * Destroys the plugin.\n\t */\n    Video.prototype.destroy = function() {\n        var handler, property;\n\n        this._core.$element.off(\"click.owl.video\");\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Video = Video;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    /**\n\t * Creates the animate plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n    var Animate = function(scope) {\n        this.core = scope;\n        this.core.options = $.extend({}, Animate.Defaults, this.core.options);\n        this.swapping = true;\n        this.previous = undefined;\n        this.next = undefined;\n\n        this.handlers = {\n            \"change.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && e.property.name == \"position\") {\n                        this.previous = this.core.current();\n                        this.next = e.property.value;\n                    }\n                },\n                this\n            ),\n            \"drag.owl.carousel dragged.owl.carousel translated.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace) {\n                        this.swapping = e.type == \"translated\";\n                    }\n                },\n                this\n            ),\n            \"translate.owl.carousel\": $.proxy(\n                function(e) {\n                    if (\n                        e.namespace &&\n                            this.swapping &&\n                            (this.core.options.animateOut ||\n                                this.core.options.animateIn)\n                    ) {\n                        this.swap();\n                    }\n                },\n                this\n            )\n        };\n\n        this.core.$element.on(this.handlers);\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t */\n    Animate.Defaults = { animateOut: false, animateIn: false };\n\n    /**\n\t * Toggles the animation classes whenever an translations starts.\n\t * @protected\n\t * @returns {Boolean|undefined}\n\t */\n    Animate.prototype.swap = function() {\n        if (this.core.settings.items !== 1) {\n            return;\n        }\n\n        if (!$.support.animation || !$.support.transition) {\n            return;\n        }\n\n        this.core.speed(0);\n\n        var left,\n            clear = $.proxy(this.clear, this),\n            previous = this.core.$stage.children().eq(this.previous),\n            next = this.core.$stage.children().eq(this.next),\n            incoming = this.core.settings.animateIn,\n            outgoing = this.core.settings.animateOut;\n\n        if (this.core.current() === this.previous) {\n            return;\n        }\n\n        if (outgoing) {\n            left = this.core.coordinates(this.previous) -\n                this.core.coordinates(this.next);\n            previous\n                .one($.support.animation.end, clear)\n                .css({ left: left + \"px\" })\n                .addClass(\"animated owl-animated-out\")\n                .addClass(outgoing);\n        }\n\n        if (incoming) {\n            next\n                .one($.support.animation.end, clear)\n                .addClass(\"animated owl-animated-in\")\n                .addClass(incoming);\n        }\n    };\n\n    Animate.prototype.clear = function(e) {\n        $(e.target)\n            .css({ left: \"\" })\n            .removeClass(\"animated owl-animated-out owl-animated-in\")\n            .removeClass(this.core.settings.animateIn)\n            .removeClass(this.core.settings.animateOut);\n        this.core.onTransitionEnd();\n    };\n\n    /**\n\t * Destroys the plugin.\n\t * @public\n\t */\n    Animate.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this.core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    /**\n\t * Creates the autoplay plugin.\n\t * @class The Autoplay Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n    var Autoplay = function(carousel) {\n        /**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n        this._core = carousel;\n\n        /**\n\t\t * The autoplay timeout.\n\t\t * @type {Timeout}\n\t\t */\n        this._timeout = null;\n\n        /**\n\t\t * Indicates whenever the autoplay is paused.\n\t\t * @type {Boolean}\n\t\t */\n        this._paused = false;\n\n        /**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._handlers = {\n            \"changed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && e.property.name === \"settings\") {\n                        if (this._core.settings.autoplay) {\n                            this.play();\n                        } else {\n                            this.stop();\n                        }\n                    } else if (e.namespace && e.property.name === \"position\") {\n                        //console.log('play?', e);\n                        if (this._core.settings.autoplay) {\n                            this._setAutoPlayInterval();\n                        }\n                    }\n                },\n                this\n            ),\n            \"initialized.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._core.settings.autoplay) {\n                        this.play();\n                    }\n                },\n                this\n            ),\n            \"play.owl.autoplay\": $.proxy(\n                function(e, t, s) {\n                    if (e.namespace) {\n                        this.play(t, s);\n                    }\n                },\n                this\n            ),\n            \"stop.owl.autoplay\": $.proxy(\n                function(e) {\n                    if (e.namespace) {\n                        this.stop();\n                    }\n                },\n                this\n            ),\n            \"mouseover.owl.autoplay\": $.proxy(\n                function() {\n                    if (\n                        this._core.settings.autoplayHoverPause &&\n                            this._core.is(\"rotating\")\n                    ) {\n                        this.pause();\n                    }\n                },\n                this\n            ),\n            \"mouseleave.owl.autoplay\": $.proxy(\n                function() {\n                    if (\n                        this._core.settings.autoplayHoverPause &&\n                            this._core.is(\"rotating\")\n                    ) {\n                        this.play();\n                    }\n                },\n                this\n            ),\n            \"touchstart.owl.core\": $.proxy(\n                function() {\n                    if (\n                        this._core.settings.autoplayHoverPause &&\n                            this._core.is(\"rotating\")\n                    ) {\n                        this.pause();\n                    }\n                },\n                this\n            ),\n            \"touchend.owl.core\": $.proxy(\n                function() {\n                    if (this._core.settings.autoplayHoverPause) {\n                        this.play();\n                    }\n                },\n                this\n            )\n        };\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n\n        // set default options\n        this._core.options = $.extend(\n            {},\n            Autoplay.Defaults,\n            this._core.options\n        );\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t */\n    Autoplay.Defaults = {\n        autoplay: false,\n        autoplayTimeout: 5000,\n        autoplayHoverPause: false,\n        autoplaySpeed: false\n    };\n\n    /**\n\t * Starts the autoplay.\n\t * @public\n\t * @param {Number} [timeout] - The interval before the next animation starts.\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t */\n    Autoplay.prototype.play = function(timeout, speed) {\n        this._paused = false;\n\n        if (this._core.is(\"rotating\")) {\n            return;\n        }\n\n        this._core.enter(\"rotating\");\n\n        this._setAutoPlayInterval();\n    };\n\n    /**\n\t * Gets a new timeout\n\t * @private\n\t * @param {Number} [timeout] - The interval before the next animation starts.\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t * @return {Timeout}\n\t */\n    Autoplay.prototype._getNextTimeout = function(timeout, speed) {\n        if (this._timeout) {\n            window.clearTimeout(this._timeout);\n        }\n        return window.setTimeout(\n            $.proxy(\n                function() {\n                    if (\n                        this._paused ||\n                            this._core.is(\"busy\") ||\n                            this._core.is(\"interacting\") ||\n                            document.hidden\n                    ) {\n                        return;\n                    }\n                    this._core.next(speed || this._core.settings.autoplaySpeed);\n                },\n                this\n            ),\n            timeout || this._core.settings.autoplayTimeout\n        );\n    };\n\n    /**\n\t * Sets autoplay in motion.\n\t * @private\n\t */\n    Autoplay.prototype._setAutoPlayInterval = function() {\n        this._timeout = this._getNextTimeout();\n    };\n\n    /**\n\t * Stops the autoplay.\n\t * @public\n\t */\n    Autoplay.prototype.stop = function() {\n        if (!this._core.is(\"rotating\")) {\n            return;\n        }\n\n        window.clearTimeout(this._timeout);\n        this._core.leave(\"rotating\");\n    };\n\n    /**\n\t * Stops the autoplay.\n\t * @public\n\t */\n    Autoplay.prototype.pause = function() {\n        if (!this._core.is(\"rotating\")) {\n            return;\n        }\n\n        this._paused = true;\n    };\n\n    /**\n\t * Destroys the plugin.\n\t */\n    Autoplay.prototype.destroy = function() {\n        var handler, property;\n\n        this.stop();\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    \"use strict\";\n    /**\n\t * Creates the navigation plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} carousel - The Owl Carousel.\n\t */\n    var Navigation = function(carousel) {\n        /**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n        this._core = carousel;\n\n        /**\n\t\t * Indicates whether the plugin is initialized or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n        this._initialized = false;\n\n        /**\n\t\t * The current paging indexes.\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n        this._pages = [];\n\n        /**\n\t\t * All DOM elements of the user interface.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._controls = {};\n\n        /**\n\t\t * Markup for an indicator.\n\t\t * @protected\n\t\t * @type {Array.<String>}\n\t\t */\n        this._templates = [];\n\n        /**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n        this.$element = this._core.$element;\n\n        /**\n\t\t * Overridden methods of the carousel.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._overrides = {\n            next: this._core.next,\n            prev: this._core.prev,\n            to: this._core.to\n        };\n\n        /**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._handlers = {\n            \"prepared.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._core.settings.dotsData) {\n                        this._templates.push(\n                            '<div class=\"' +\n                                this._core.settings.dotClass +\n                                '\">' +\n                                $(e.content)\n                                    .find(\"[data-dot]\")\n                                    .addBack(\"[data-dot]\")\n                                    .attr(\"data-dot\") +\n                                \"</div>\"\n                        );\n                    }\n                },\n                this\n            ),\n            \"added.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._core.settings.dotsData) {\n                        this._templates.splice(\n                            e.position,\n                            0,\n                            this._templates.pop()\n                        );\n                    }\n                },\n                this\n            ),\n            \"remove.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._core.settings.dotsData) {\n                        this._templates.splice(e.position, 1);\n                    }\n                },\n                this\n            ),\n            \"changed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && e.property.name == \"position\") {\n                        this.draw();\n                    }\n                },\n                this\n            ),\n            \"initialized.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && !this._initialized) {\n                        this._core.trigger(\"initialize\", null, \"navigation\");\n                        this.initialize();\n                        this.update();\n                        this.draw();\n                        this._initialized = true;\n                        this._core.trigger(\"initialized\", null, \"navigation\");\n                    }\n                },\n                this\n            ),\n            \"refreshed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && this._initialized) {\n                        this._core.trigger(\"refresh\", null, \"navigation\");\n                        this.update();\n                        this.draw();\n                        this._core.trigger(\"refreshed\", null, \"navigation\");\n                    }\n                },\n                this\n            )\n        };\n\n        // set default options\n        this._core.options = $.extend(\n            {},\n            Navigation.Defaults,\n            this._core.options\n        );\n\n        // register event handlers\n        this.$element.on(this._handlers);\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t * @todo Rename `slideBy` to `navBy`\n\t */\n    Navigation.Defaults = {\n        nav: false,\n        navText: [ \"prev\", \"next\" ],\n        navSpeed: false,\n        navElement: \"div\",\n        navContainer: false,\n        navContainerClass: \"owl-nav\",\n        navClass: [ \"owl-prev\", \"owl-next\" ],\n        slideBy: 1,\n        dotClass: \"owl-dot\",\n        dotsClass: \"owl-dots\",\n        dots: true,\n        dotsEach: false,\n        dotsData: false,\n        dotsSpeed: false,\n        dotsContainer: false\n    };\n\n    /**\n\t * Initializes the layout of the plugin and extends the carousel.\n\t * @protected\n\t */\n    Navigation.prototype.initialize = function() {\n        var override, settings = this._core.settings;\n\n        // create DOM structure for relative navigation\n        this._controls.$relative = (settings.navContainer\n            ? $(settings.navContainer)\n            : $(\"<div>\")\n                .addClass(settings.navContainerClass)\n                .appendTo(this.$element)).addClass(\"disabled\");\n\n        this._controls.$previous = $(\"<\" + settings.navElement + \">\")\n            .addClass(settings.navClass[0])\n            .html(settings.navText[0])\n            .prependTo(this._controls.$relative)\n            .on(\n                \"click\",\n                $.proxy(\n                    function(e) {\n                        this.prev(settings.navSpeed);\n                    },\n                    this\n                )\n            );\n        this._controls.$next = $(\"<\" + settings.navElement + \">\")\n            .addClass(settings.navClass[1])\n            .html(settings.navText[1])\n            .appendTo(this._controls.$relative)\n            .on(\n                \"click\",\n                $.proxy(\n                    function(e) {\n                        this.next(settings.navSpeed);\n                    },\n                    this\n                )\n            );\n\n        // create DOM structure for absolute navigation\n        if (!settings.dotsData) {\n            this._templates = [\n                $(\"<div>\")\n                    .addClass(settings.dotClass)\n                    .append($(\"<span>\"))\n                    .prop(\"outerHTML\")\n            ];\n        }\n\n        this._controls.$absolute = (settings.dotsContainer\n            ? $(settings.dotsContainer)\n            : $(\"<div>\")\n                .addClass(settings.dotsClass)\n                .appendTo(this.$element)).addClass(\"disabled\");\n\n        this._controls.$absolute.on(\n            \"click\",\n            \"div\",\n            $.proxy(\n                function(e) {\n                    var index = $(e.target)\n                        .parent()\n                        .is(this._controls.$absolute)\n                        ? $(e.target).index()\n                        : $(e.target).parent().index();\n\n                    e.preventDefault();\n\n                    this.to(index, settings.dotsSpeed);\n                },\n                this\n            )\n        );\n\n        // override public methods of the carousel\n        for (override in this._overrides) {\n            this._core[override] = $.proxy(this[override], this);\n        }\n    };\n\n    /**\n\t * Destroys the plugin.\n\t * @protected\n\t */\n    Navigation.prototype.destroy = function() {\n        var handler, control, property, override;\n\n        for (handler in this._handlers) {\n            this.$element.off(handler, this._handlers[handler]);\n        }\n        for (control in this._controls) {\n            this._controls[control].remove();\n        }\n        for (override in this.overides) {\n            this._core[override] = this._overrides[override];\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    /**\n\t * Updates the internal state.\n\t * @protected\n\t */\n    Navigation.prototype.update = function() {\n        var i,\n            j,\n            k,\n            lower = this._core.clones().length / 2,\n            upper = lower + this._core.items().length,\n            maximum = this._core.maximum(true),\n            settings = this._core.settings,\n            size = settings.center || settings.autoWidth || settings.dotsData\n                ? 1\n                : settings.dotsEach || settings.items;\n\n        if (settings.slideBy !== \"page\") {\n            settings.slideBy = Math.min(settings.slideBy, settings.items);\n        }\n\n        if (settings.dots || settings.slideBy == \"page\") {\n            this._pages = [];\n\n            for (i = lower, j = 0, k = 0; i < upper; i++) {\n                if (j >= size || j === 0) {\n                    this._pages.push({\n                        start: Math.min(maximum, i - lower),\n                        end: i - lower + size - 1\n                    });\n                    if (Math.min(maximum, i - lower) === maximum) {\n                        break;\n                    }\n                    j = 0, ++k;\n                }\n                j += this._core.mergers(this._core.relative(i));\n            }\n        }\n    };\n\n    /**\n\t * Draws the user interface.\n\t * @todo The option `dotsData` wont work.\n\t * @protected\n\t */\n    Navigation.prototype.draw = function() {\n        var difference,\n            settings = this._core.settings,\n            disabled = this._core.items().length <= settings.items,\n            index = this._core.relative(this._core.current()),\n            loop = settings.loop || settings.rewind;\n\n        this._controls.$relative.toggleClass(\n            \"disabled\",\n            !settings.nav || disabled\n        );\n\n        if (settings.nav) {\n            this._controls.$previous.toggleClass(\n                \"disabled\",\n                !loop && index <= this._core.minimum(true)\n            );\n            this._controls.$next.toggleClass(\n                \"disabled\",\n                !loop && index >= this._core.maximum(true)\n            );\n        }\n\n        this._controls.$absolute.toggleClass(\n            \"disabled\",\n            !settings.dots || disabled\n        );\n\n        if (settings.dots) {\n            difference = this._pages.length -\n                this._controls.$absolute.children().length;\n\n            if (settings.dotsData && difference !== 0) {\n                this._controls.$absolute.html(this._templates.join(\"\"));\n            } else if (difference > 0) {\n                this._controls.$absolute.append(\n                    new Array(difference + 1).join(this._templates[0])\n                );\n            } else if (difference < 0) {\n                this._controls.$absolute.children().slice(difference).remove();\n            }\n\n            this._controls.$absolute.find(\".active\").removeClass(\"active\");\n            this._controls.$absolute\n                .children()\n                .eq($.inArray(this.current(), this._pages))\n                .addClass(\"active\");\n        }\n    };\n\n    /**\n\t * Extends event data.\n\t * @protected\n\t * @param {Event} event - The event object which gets thrown.\n\t */\n    Navigation.prototype.onTrigger = function(event) {\n        var settings = this._core.settings;\n\n        event.page = {\n            index: $.inArray(this.current(), this._pages),\n            count: this._pages.length,\n            size: settings &&\n                (settings.center || settings.autoWidth || settings.dotsData\n                    ? 1\n                    : settings.dotsEach || settings.items)\n        };\n    };\n\n    /**\n\t * Gets the current page position of the carousel.\n\t * @protected\n\t * @returns {Number}\n\t */\n    Navigation.prototype.current = function() {\n        var current = this._core.relative(this._core.current());\n        return $.grep(\n            this._pages,\n            $.proxy(\n                function(page, index) {\n                    return page.start <= current && page.end >= current;\n                },\n                this\n            )\n        ).pop();\n    };\n\n    /**\n\t * Gets the current succesor/predecessor position.\n\t * @protected\n\t * @returns {Number}\n\t */\n    Navigation.prototype.getPosition = function(successor) {\n        var position, length, settings = this._core.settings;\n\n        if (settings.slideBy == \"page\") {\n            position = $.inArray(this.current(), this._pages);\n            length = this._pages.length;\n            successor ? ++position : --position;\n            position = this._pages[(position % length + length) % length].start;\n        } else {\n            position = this._core.relative(this._core.current());\n            length = this._core.items().length;\n            successor\n                ? position += settings.slideBy\n                : position -= settings.slideBy;\n        }\n\n        return position;\n    };\n\n    /**\n\t * Slides to the next item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n    Navigation.prototype.next = function(speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n    };\n\n    /**\n\t * Slides to the previous item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n    Navigation.prototype.prev = function(speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n    };\n\n    /**\n\t * Slides to the specified item or page.\n\t * @public\n\t * @param {Number} position - The position of the item or page.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n\t */\n    Navigation.prototype.to = function(position, speed, standard) {\n        var length;\n\n        if (!standard && this._pages.length) {\n            length = this._pages.length;\n            $.proxy(\n                this._overrides.to,\n                this._core\n            )(this._pages[(position % length + length) % length].start, speed);\n        } else {\n            $.proxy(this._overrides.to, this._core)(position, speed);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    \"use strict\";\n    /**\n\t * Creates the hash plugin.\n\t * @class The Hash Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n    var Hash = function(carousel) {\n        /**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n        this._core = carousel;\n\n        /**\n\t\t * Hash index for the items.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._hashes = {};\n\n        /**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n        this.$element = this._core.$element;\n\n        /**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n        this._handlers = {\n            \"initialized.owl.carousel\": $.proxy(\n                function(e) {\n                    if (\n                        e.namespace &&\n                            this._core.settings.startPosition === \"URLHash\"\n                    ) {\n                        $(window).trigger(\"hashchange.owl.navigation\");\n                    }\n                },\n                this\n            ),\n            \"prepared.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace) {\n                        var hash = $(e.content)\n                            .find(\"[data-hash]\")\n                            .addBack(\"[data-hash]\")\n                            .attr(\"data-hash\");\n\n                        if (!hash) {\n                            return;\n                        }\n\n                        this._hashes[hash] = e.content;\n                    }\n                },\n                this\n            ),\n            \"changed.owl.carousel\": $.proxy(\n                function(e) {\n                    if (e.namespace && e.property.name === \"position\") {\n                        var current = this._core.items(\n                            this._core.relative(this._core.current())\n                        ),\n                            hash = $.map(this._hashes, function(item, hash) {\n                                return item === current ? hash : null;\n                            }).join();\n\n                        if (!hash || window.location.hash.slice(1) === hash) {\n                            return;\n                        }\n\n                        window.location.hash = hash;\n                    }\n                },\n                this\n            )\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n        // register the event handlers\n        this.$element.on(this._handlers);\n\n        // register event listener for hash navigation\n        $(window).on(\n            \"hashchange.owl.navigation\",\n            $.proxy(\n                function(e) {\n                    var hash = window.location.hash.substring(1),\n                        items = this._core.$stage.children(),\n                        position = this._hashes[hash] &&\n                            items.index(this._hashes[hash]);\n\n                    if (\n                        position === undefined ||\n                            position === this._core.current()\n                    ) {\n                        return;\n                    }\n\n                    this._core.to(this._core.relative(position), false, true);\n                },\n                this\n            )\n        );\n    };\n\n    /**\n\t * Default options.\n\t * @public\n\t */\n    Hash.Defaults = { URLhashListener: false };\n\n    /**\n\t * Destroys the plugin.\n\t * @public\n\t */\n    Hash.prototype.destroy = function() {\n        var handler, property;\n\n        $(window).off(\"hashchange.owl.navigation\");\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != \"function\" && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n(function($, window, document, undefined) {\n    var style = $(\"<support>\").get(0).style,\n        prefixes = \"Webkit Moz O ms\".split(\" \"),\n        events = {\n            transition: {\n                end: {\n                    WebkitTransition: \"webkitTransitionEnd\",\n                    MozTransition: \"transitionend\",\n                    OTransition: \"oTransitionEnd\",\n                    transition: \"transitionend\"\n                }\n            },\n            animation: {\n                end: {\n                    WebkitAnimation: \"webkitAnimationEnd\",\n                    MozAnimation: \"animationend\",\n                    OAnimation: \"oAnimationEnd\",\n                    animation: \"animationend\"\n                }\n            }\n        },\n        tests = {\n            csstransforms: function() {\n                return !!test(\"transform\");\n            },\n            csstransforms3d: function() {\n                return !!test(\"perspective\");\n            },\n            csstransitions: function() {\n                return !!test(\"transition\");\n            },\n            cssanimations: function() {\n                return !!test(\"animation\");\n            }\n        };\n\n    function test(property, prefixed) {\n        var result = false,\n            upper = property.charAt(0).toUpperCase() + property.slice(1);\n\n        $.each(\n            (property + \" \" + prefixes.join(upper + \" \") + upper).split(\" \"),\n            function(i, property) {\n                if (style[property] !== undefined) {\n                    result = prefixed ? property : true;\n                    return false;\n                }\n            }\n        );\n\n        return result;\n    }\n\n    function prefixed(property) {\n        return test(property, true);\n    }\n\n    if (tests.csstransitions()) {\n        /* jshint -W053 */\n        $.support.transition = new String(prefixed(\"transition\"));\n        $.support.transition.end = events.transition.end[$.support.transition];\n    }\n\n    if (tests.cssanimations()) {\n        /* jshint -W053 */\n        $.support.animation = new String(prefixed(\"animation\"));\n        $.support.animation.end = events.animation.end[$.support.animation];\n    }\n\n    if (tests.csstransforms()) {\n        /* jshint -W053 */\n        $.support.transform = new String(prefixed(\"transform\"));\n        $.support.transform3d = tests.csstransforms3d();\n    }\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9DOi9Vc2Vycy9EYW5nby9sZWFybi9vYm9sb24vfi9vd2wuY2Fyb3VzZWwvZGlzdC9vd2wuY2Fyb3VzZWwuanM/NDZiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG4gICAgLyoqXG5cdCAqIENyZWF0ZXMgYSBjYXJvdXNlbC5cblx0ICogQGNsYXNzIFRoZSBPd2wgQ2Fyb3VzZWwuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGNhcm91c2VsIGZvci5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zXG5cdCAqL1xuICAgIGZ1bmN0aW9uIE93bChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuXHRcdCAqIEN1cnJlbnQgc2V0dGluZ3MgZm9yIHRoZSBjYXJvdXNlbC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIEN1cnJlbnQgb3B0aW9ucyBzZXQgYnkgdGhlIGNhbGxlciBpbmNsdWRpbmcgZGVmYXVsdHMuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT3dsLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICAvKipcblx0XHQgKiBQbHVnaW4gZWxlbWVudC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIFByb3hpZWQgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIFJlZmVyZW5jZXMgdG8gdGhlIHJ1bm5pbmcgcGx1Z2lucyBvZiB0aGlzIGNhcm91c2VsLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IHt9O1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIEN1cnJlbnRseSBzdXBwcmVzc2VkIGV2ZW50cyB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWVpbmcgcmV0cmlnZ2VyZWQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9zdXByZXNzID0ge307XG5cbiAgICAgICAgLyoqXG5cdFx0ICogQWJzb2x1dGUgY3VycmVudCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIEFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9zcGVlZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG5cdFx0ICogQ29vcmRpbmF0ZXMgb2YgYWxsIGl0ZW1zIGluIHBpeGVsLlxuXHRcdCAqIEB0b2RvIFRoZSBuYW1lIG9mIHRoaXMgbWVtYmVyIGlzIG1pc3NsZWFkaW5nLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cbiAgICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBbXTtcblxuICAgICAgICAvKipcblx0XHQgKiBDdXJyZW50IGJyZWFrcG9pbnQuXG5cdFx0ICogQHRvZG8gUmVhbCBtZWRpYSBxdWVyaWVzIHdvdWxkIGJlIG5pY2UuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9icmVha3BvaW50ID0gbnVsbDtcblxuICAgICAgICAvKipcblx0XHQgKiBDdXJyZW50IHdpZHRoIG9mIHRoZSBwbHVnaW4gZWxlbWVudC5cblx0XHQgKi9cbiAgICAgICAgdGhpcy5fd2lkdGggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIEFsbCByZWFsIGl0ZW1zLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcblxuICAgICAgICAvKipcblx0XHQgKiBBbGwgY2xvbmVkIGl0ZW1zLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cbiAgICAgICAgdGhpcy5fY2xvbmVzID0gW107XG5cbiAgICAgICAgLyoqXG5cdFx0ICogTWVyZ2UgdmFsdWVzIG9mIGFsbCBpdGVtcy5cblx0XHQgKiBAdG9kbyBNYXliZSB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgYSBwbHVnaW4uXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9tZXJnZXJzID0gW107XG5cbiAgICAgICAgLyoqXG5cdFx0ICogV2lkdGhzIG9mIGFsbCBpdGVtcy5cblx0XHQgKi9cbiAgICAgICAgdGhpcy5fd2lkdGhzID0gW107XG5cbiAgICAgICAgLyoqXG5cdFx0ICogSW52YWxpZGF0ZWQgcGFydHMgd2l0aGluIHRoZSB1cGRhdGUgcHJvY2Vzcy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVkID0ge307XG5cbiAgICAgICAgLyoqXG5cdFx0ICogT3JkZXJlZCBsaXN0IG9mIHdvcmtlcnMgZm9yIHRoZSB1cGRhdGUgcHJvY2Vzcy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG4gICAgICAgIHRoaXMuX3BpcGUgPSBbXTtcblxuICAgICAgICAvKipcblx0XHQgKiBDdXJyZW50IHN0YXRlIGluZm9ybWF0aW9uIGZvciB0aGUgZHJhZyBvcGVyYXRpb24uXG5cdFx0ICogQHRvZG8gIzI2MVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cbiAgICAgICAgdGhpcy5fZHJhZyA9IHtcbiAgICAgICAgICAgIHRpbWU6IG51bGwsXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICBwb2ludGVyOiBudWxsLFxuICAgICAgICAgICAgc3RhZ2U6IHsgc3RhcnQ6IG51bGwsIGN1cnJlbnQ6IG51bGwgfSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIEN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gYW5kIHRoZWlyIHRhZ3MuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IHtcbiAgICAgICAgICAgIGN1cnJlbnQ6IHt9LFxuICAgICAgICAgICAgdGFnczoge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemluZzogWyBcImJ1c3lcIiBdLFxuICAgICAgICAgICAgICAgIGFuaW1hdGluZzogWyBcImJ1c3lcIiBdLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBbIFwiaW50ZXJhY3RpbmdcIiBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgWyBcIm9uUmVzaXplXCIsIFwib25UaHJvdHRsZWRSZXNpemVcIiBdLFxuICAgICAgICAgICAgJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihpLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdID0gJC5wcm94eSh0aGlzW2hhbmRsZXJdLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAkLmVhY2goXG4gICAgICAgICAgICBPd2wuUGx1Z2lucyxcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oa2V5LCBwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGx1Z2luc1trZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnNsaWNlKDEpXSA9IG5ldyBwbHVnaW4odGhpcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgT3dsLldvcmtlcnMsXG4gICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHByaW9yaXR5LCB3b3JrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGlwZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogd29ya2VyLmZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjogJC5wcm94eSh3b3JrZXIucnVuLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNldHVwKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBjYXJvdXNlbC5cblx0ICogQHB1YmxpY1xuXHQgKi9cbiAgICBPd2wuRGVmYXVsdHMgPSB7XG4gICAgICAgIGl0ZW1zOiAzLFxuICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgY2VudGVyOiBmYWxzZSxcbiAgICAgICAgcmV3aW5kOiBmYWxzZSxcbiAgICAgICAgbW91c2VEcmFnOiB0cnVlLFxuICAgICAgICB0b3VjaERyYWc6IHRydWUsXG4gICAgICAgIHB1bGxEcmFnOiB0cnVlLFxuICAgICAgICBmcmVlRHJhZzogZmFsc2UsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgc3RhZ2VQYWRkaW5nOiAwLFxuICAgICAgICBtZXJnZTogZmFsc2UsXG4gICAgICAgIG1lcmdlRml0OiB0cnVlLFxuICAgICAgICBhdXRvV2lkdGg6IGZhbHNlLFxuICAgICAgICBzdGFydFBvc2l0aW9uOiAwLFxuICAgICAgICBydGw6IGZhbHNlLFxuICAgICAgICBzbWFydFNwZWVkOiAyNTAsXG4gICAgICAgIGZsdWlkU3BlZWQ6IGZhbHNlLFxuICAgICAgICBkcmFnRW5kU3BlZWQ6IGZhbHNlLFxuICAgICAgICByZXNwb25zaXZlOiB7fSxcbiAgICAgICAgcmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiAyMDAsXG4gICAgICAgIHJlc3BvbnNpdmVCYXNlRWxlbWVudDogd2luZG93LFxuICAgICAgICBmYWxsYmFja0Vhc2luZzogXCJzd2luZ1wiLFxuICAgICAgICBpbmZvOiBmYWxzZSxcbiAgICAgICAgbmVzdGVkSXRlbVNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgaXRlbUVsZW1lbnQ6IFwiZGl2XCIsXG4gICAgICAgIHN0YWdlRWxlbWVudDogXCJkaXZcIixcbiAgICAgICAgcmVmcmVzaENsYXNzOiBcIm93bC1yZWZyZXNoXCIsXG4gICAgICAgIGxvYWRlZENsYXNzOiBcIm93bC1sb2FkZWRcIixcbiAgICAgICAgbG9hZGluZ0NsYXNzOiBcIm93bC1sb2FkaW5nXCIsXG4gICAgICAgIHJ0bENsYXNzOiBcIm93bC1ydGxcIixcbiAgICAgICAgcmVzcG9uc2l2ZUNsYXNzOiBcIm93bC1yZXNwb25zaXZlXCIsXG4gICAgICAgIGRyYWdDbGFzczogXCJvd2wtZHJhZ1wiLFxuICAgICAgICBpdGVtQ2xhc3M6IFwib3dsLWl0ZW1cIixcbiAgICAgICAgc3RhZ2VDbGFzczogXCJvd2wtc3RhZ2VcIixcbiAgICAgICAgc3RhZ2VPdXRlckNsYXNzOiBcIm93bC1zdGFnZS1vdXRlclwiLFxuICAgICAgICBncmFiQ2xhc3M6IFwib3dsLWdyYWJcIlxuICAgIH07XG5cbiAgICAvKipcblx0ICogRW51bWVyYXRpb24gZm9yIHdpZHRoLlxuXHQgKiBAcHVibGljXG5cdCAqIEByZWFkb25seVxuXHQgKiBAZW51bSB7U3RyaW5nfVxuXHQgKi9cbiAgICBPd2wuV2lkdGggPSB7IERlZmF1bHQ6IFwiZGVmYXVsdFwiLCBJbm5lcjogXCJpbm5lclwiLCBPdXRlcjogXCJvdXRlclwiIH07XG5cbiAgICAvKipcblx0ICogRW51bWVyYXRpb24gZm9yIHR5cGVzLlxuXHQgKiBAcHVibGljXG5cdCAqIEByZWFkb25seVxuXHQgKiBAZW51bSB7U3RyaW5nfVxuXHQgKi9cbiAgICBPd2wuVHlwZSA9IHsgRXZlbnQ6IFwiZXZlbnRcIiwgU3RhdGU6IFwic3RhdGVcIiB9O1xuXG4gICAgLyoqXG5cdCAqIENvbnRhaW5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgT3dsLlBsdWdpbnMgPSB7fTtcblxuICAgIC8qKlxuXHQgKiBMaXN0IG9mIHdvcmtlcnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZSBwcm9jZXNzLlxuXHQgKi9cbiAgICBPd2wuV29ya2VycyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyOiBbIFwid2lkdGhcIiwgXCJzZXR0aW5nc1wiIF0sXG4gICAgICAgICAgICBydW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBmaWx0ZXI6IFsgXCJ3aWR0aFwiLCBcIml0ZW1zXCIsIFwic2V0dGluZ3NcIiBdLFxuICAgICAgICAgICAgcnVuOiBmdW5jdGlvbihjYWNoZSkge1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnQgPSB0aGlzLl9pdGVtcyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc1t0aGlzLnJlbGF0aXZlKHRoaXMuX2N1cnJlbnQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyOiBbIFwiaXRlbXNcIiwgXCJzZXR0aW5nc1wiIF0sXG4gICAgICAgICAgICBydW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YWdlLmNoaWxkcmVuKFwiLmNsb25lZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyOiBbIFwid2lkdGhcIiwgXCJpdGVtc1wiLCBcInNldHRpbmdzXCIgXSxcbiAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gdGhpcy5zZXR0aW5ncy5tYXJnaW4gfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwsXG4gICAgICAgICAgICAgICAgICAgIGNzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogcnRsID8gbWFyZ2luIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IHJ0bCA/IFwiXCIgOiBtYXJnaW5cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICFncmlkICYmIHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuY3NzKGNzcyk7XG5cbiAgICAgICAgICAgICAgICBjYWNoZS5jc3MgPSBjc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpbHRlcjogWyBcIndpZHRoXCIsIFwiaXRlbXNcIiwgXCJzZXR0aW5nc1wiIF0sXG4gICAgICAgICAgICBydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gKHRoaXMud2lkdGgoKSAvIHRoaXMuc2V0dGluZ3MuaXRlbXMpLnRvRml4ZWQoMykgLVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2UgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhzID0gW107XG5cbiAgICAgICAgICAgICAgICBjYWNoZS5pdGVtcyA9IHsgbWVyZ2U6IGZhbHNlLCB3aWR0aDogd2lkdGggfTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlID0gdGhpcy5fbWVyZ2Vyc1tpdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlID0gdGhpcy5zZXR0aW5ncy5tZXJnZUZpdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4obWVyZ2UsIHRoaXMuc2V0dGluZ3MuaXRlbXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZTtcblxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5pdGVtcy5tZXJnZSA9IG1lcmdlID4gMSB8fCBjYWNoZS5pdGVtcy5tZXJnZTtcblxuICAgICAgICAgICAgICAgICAgICB3aWR0aHNbaXRlcmF0b3JdID0gIWdyaWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5faXRlbXNbaXRlcmF0b3JdLndpZHRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogd2lkdGggKiBtZXJnZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aHMgPSB3aWR0aHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpbHRlcjogWyBcIml0ZW1zXCIsIFwic2V0dGluZ3NcIiBdLFxuICAgICAgICAgICAgcnVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gdGhpcy5faXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgdmlldyA9IE1hdGgubWF4KHNldHRpbmdzLml0ZW1zICogMiwgNCksXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLmNlaWwoaXRlbXMubGVuZ3RoIC8gMikgKiAyLFxuICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSBzZXR0aW5ncy5sb29wICYmIGl0ZW1zLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXR0aW5ncy5yZXdpbmQgPyB2aWV3IDogTWF0aC5tYXgodmlldywgc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kID0gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgcHJlcGVuZCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICByZXBlYXQgLz0gMjtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChyZXBlYXQtLSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZXMucHVzaCh0aGlzLm5vcm1hbGl6ZShjbG9uZXMubGVuZ3RoIC8gMiwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmQgPSBhcHBlbmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbY2xvbmVzW2Nsb25lcy5sZW5ndGggLSAxXV1bMF0ub3V0ZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLmxlbmd0aCAtIDEgLSAoY2xvbmVzLmxlbmd0aCAtIDEpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHByZXBlbmQgPSBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGVuZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9uZXMgPSBjbG9uZXM7XG5cbiAgICAgICAgICAgICAgICAkKGFwcGVuZCkuYWRkQ2xhc3MoXCJjbG9uZWRcIikuYXBwZW5kVG8odGhpcy4kc3RhZ2UpO1xuICAgICAgICAgICAgICAgICQocHJlcGVuZCkuYWRkQ2xhc3MoXCJjbG9uZWRcIikucHJlcGVuZFRvKHRoaXMuJHN0YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyOiBbIFwid2lkdGhcIiwgXCJpdGVtc1wiLCBcInNldHRpbmdzXCIgXSxcbiAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5fY2xvbmVzLmxlbmd0aCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSAwLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2l0ZXJhdG9yIDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGNvb3JkaW5hdGVzW2l0ZXJhdG9yIC0gMV0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuX3dpZHRoc1t0aGlzLnJlbGF0aXZlKGl0ZXJhdG9yKV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5tYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2gocHJldmlvdXMgKyBjdXJyZW50ICogcnRsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBmaWx0ZXI6IFsgXCJ3aWR0aFwiLCBcIml0ZW1zXCIsIFwic2V0dGluZ3NcIiBdLFxuICAgICAgICAgICAgcnVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IHRoaXMuX2Nvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgICAgICBjc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyAqIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiOiBwYWRkaW5nIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctcmlnaHRcIjogcGFkZGluZyB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRzdGFnZS5jc3MoY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyOiBbIFwid2lkdGhcIiwgXCJpdGVtc1wiLCBcInNldHRpbmdzXCIgXSxcbiAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKTtcblxuICAgICAgICAgICAgICAgIGlmIChncmlkICYmIGNhY2hlLml0ZW1zLm1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5jc3Mud2lkdGggPSB0aGlzLl93aWR0aHNbdGhpcy5yZWxhdGl2ZShpdGVyYXRvcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMuZXEoaXRlcmF0b3IpLmNzcyhjYWNoZS5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChncmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmNzcy53aWR0aCA9IGNhY2hlLml0ZW1zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5jc3MoY2FjaGUuY3NzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpbHRlcjogWyBcIml0ZW1zXCIgXSxcbiAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoIDwgMSAmJiB0aGlzLiRzdGFnZS5yZW1vdmVBdHRyKFwic3R5bGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpbHRlcjogWyBcIndpZHRoXCIsIFwiaXRlbXNcIiwgXCJzZXR0aW5nc1wiIF0sXG4gICAgICAgICAgICBydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudCA9IGNhY2hlLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmluZGV4KGNhY2hlLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICBjYWNoZS5jdXJyZW50ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluaW11bSgpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLm1heGltdW0oKSwgY2FjaGUuY3VycmVudClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoY2FjaGUuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpbHRlcjogWyBcInBvc2l0aW9uXCIgXSxcbiAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKHRoaXMuY29vcmRpbmF0ZXModGhpcy5fY3VycmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBmaWx0ZXI6IFsgXCJ3aWR0aFwiLCBcInBvc2l0aW9uXCIsIFwiaXRlbXNcIiwgXCJzZXR0aW5nc1wiIF0sXG4gICAgICAgICAgICBydW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMixcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMuY3VycmVudCgpKSArIHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGJlZ2luICsgdGhpcy53aWR0aCgpICogcnRsLFxuICAgICAgICAgICAgICAgICAgICBpbm5lcixcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXIsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSB0aGlzLl9jb29yZGluYXRlc1tpIC0gMV0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXIgPSBNYXRoLmFicyh0aGlzLl9jb29yZGluYXRlc1tpXSkgKyBwYWRkaW5nICogcnRsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3AoaW5uZXIsIFwiPD1cIiwgYmVnaW4pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcChpbm5lciwgXCI+XCIsIGVuZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wKG91dGVyLCBcIjxcIiwgYmVnaW4pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3Aob3V0ZXIsIFwiPlwiLCBlbmQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhZ2UuY2hpbGRyZW4oXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YWdlXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbihcIjplcShcIiArIG1hdGNoZXMuam9pbihcIiksIDplcShcIikgKyBcIilcIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHN0YWdlLmNoaWxkcmVuKFwiLmNlbnRlclwiKS5yZW1vdmVDbGFzcyhcImNlbnRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3RhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXEodGhpcy5jdXJyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJjZW50ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXTtcblxuICAgIC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZW50ZXIoXCJpbml0aWFsaXppbmdcIik7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcImluaXRpYWxpemVcIik7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLnNldHRpbmdzLnJ0bENsYXNzLCB0aGlzLnNldHRpbmdzLnJ0bCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoICYmICF0aGlzLmlzKFwicHJlLWxvYWRpbmdcIikpIHtcbiAgICAgICAgICAgIHZhciBpbWdzLCBuZXN0ZWRTZWxlY3Rvciwgd2lkdGg7XG4gICAgICAgICAgICBpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKFwiaW1nXCIpO1xuICAgICAgICAgICAgbmVzdGVkU2VsZWN0b3IgPSB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvclxuICAgICAgICAgICAgICAgID8gXCIuXCIgKyB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKG5lc3RlZFNlbGVjdG9yKS53aWR0aCgpO1xuXG4gICAgICAgICAgICBpZiAoaW1ncy5sZW5ndGggJiYgd2lkdGggPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlbG9hZEF1dG9XaWR0aEltYWdlcyhpbWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHN0YWdlXG4gICAgICAgIHRoaXMuJHN0YWdlID0gJChcbiAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN0YWdlRWxlbWVudCArXG4gICAgICAgICAgICAgICAgJyBjbGFzcz1cIicgK1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc3RhZ2VDbGFzcyArXG4gICAgICAgICAgICAgICAgJ1wiLz4nXG4gICAgICAgICkud3JhcCgnPGRpdiBjbGFzcz1cIicgKyB0aGlzLnNldHRpbmdzLnN0YWdlT3V0ZXJDbGFzcyArICdcIi8+Jyk7XG5cbiAgICAgICAgLy8gYXBwZW5kIHN0YWdlXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXBwZW5kKHRoaXMuJHN0YWdlLnBhcmVudCgpKTtcblxuICAgICAgICAvLyBhcHBlbmQgY29udGVudFxuICAgICAgICB0aGlzLnJlcGxhY2UodGhpcy4kZWxlbWVudC5jaGlsZHJlbigpLm5vdCh0aGlzLiRzdGFnZS5wYXJlbnQoKSkpO1xuXG4gICAgICAgIC8vIGNoZWNrIHZpc2liaWxpdHlcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHZpZXdcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW52YWxpZGF0ZSB3aWR0aFxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKFwid2lkdGhcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcylcbiAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAgICAgdGhpcy5sZWF2ZShcImluaXRpYWxpemluZ1wiKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiaW5pdGlhbGl6ZWRcIik7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBTZXR1cHMgdGhlIGN1cnJlbnQgc2V0dGluZ3MuXG5cdCAqIEB0b2RvIFJlbW92ZSByZXNwb25zaXZlIGNsYXNzZXMuIFdoeSBzaG91bGQgYWRhcHRpdmUgZGVzaWducyBiZSBicm91Z2h0IGludG8gSUU4P1xuXHQgKiBAdG9kbyBTdXBwb3J0IGZvciBtZWRpYSBxdWVyaWVzIGJ5IHVzaW5nIGBtYXRjaE1lZGlhYCB3b3VsZCBiZSBuaWNlLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydCgpLFxuICAgICAgICAgICAgb3ZlcndyaXRlcyA9IHRoaXMub3B0aW9ucy5yZXNwb25zaXZlLFxuICAgICAgICAgICAgbWF0Y2ggPSAtMSxcbiAgICAgICAgICAgIHNldHRpbmdzID0gbnVsbDtcblxuICAgICAgICBpZiAoIW92ZXJ3cml0ZXMpIHtcbiAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVhY2gob3ZlcndyaXRlcywgZnVuY3Rpb24oYnJlYWtwb2ludCkge1xuICAgICAgICAgICAgICAgIGlmIChicmVha3BvaW50IDw9IHZpZXdwb3J0ICYmIGJyZWFrcG9pbnQgPiBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IE51bWJlcihicmVha3BvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvdmVyd3JpdGVzW21hdGNoXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnN0YWdlUGFkZGluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gc2V0dGluZ3Muc3RhZ2VQYWRkaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgc2V0dGluZ3MucmVzcG9uc2l2ZTtcblxuICAgICAgICAgICAgLy8gcmVzcG9uc2l2ZSBjbGFzc1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJlc3BvbnNpdmVDbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cihcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLSlcXFxcUytcXFxcc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkMVwiICsgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcbiAgICAgICAgICAgIHByb3BlcnR5OiB7IG5hbWU6IFwic2V0dGluZ3NcIiwgdmFsdWU6IHNldHRpbmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JyZWFrcG9pbnQgPSBtYXRjaDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoXCJzZXR0aW5nc1wiKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiY2hhbmdlZFwiLCB7XG4gICAgICAgICAgICBwcm9wZXJ0eTogeyBuYW1lOiBcInNldHRpbmdzXCIsIHZhbHVlOiB0aGlzLnNldHRpbmdzIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBVcGRhdGVzIG9wdGlvbiBsb2dpYyBpZiBuZWNlc3NlcnkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5vcHRpb25zTG9naWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5tZXJnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBQcmVwYXJlcyBhbiBpdGVtIGJlZm9yZSBhZGQuXG5cdCAqIEB0b2RvIFJlbmFtZSBldmVudCBwYXJhbWV0ZXIgYGNvbnRlbnRgIHRvIGBpdGVtYC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJucyB7alF1ZXJ5fEhUTUxFbGVtZW50fSAtIFRoZSBpdGVtIGNvbnRhaW5lci5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLnRyaWdnZXIoXCJwcmVwYXJlXCIsIHsgY29udGVudDogaXRlbSB9KTtcblxuICAgICAgICBpZiAoIWV2ZW50LmRhdGEpIHtcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgPSAkKFwiPFwiICsgdGhpcy5zZXR0aW5ncy5pdGVtRWxlbWVudCArIFwiLz5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5vcHRpb25zLml0ZW1DbGFzcylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKFwicHJlcGFyZWRcIiwgeyBjb250ZW50OiBldmVudC5kYXRhIH0pO1xuXG4gICAgICAgIHJldHVybiBldmVudC5kYXRhO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogVXBkYXRlcyB0aGUgdmlldy5cblx0ICogQHB1YmxpY1xuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBuID0gdGhpcy5fcGlwZS5sZW5ndGgsXG4gICAgICAgICAgICBmaWx0ZXIgPSAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlZFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNhY2hlID0ge307XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZWQuYWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICQuZ3JlcCh0aGlzLl9waXBlW2ldLmZpbHRlciwgZmlsdGVyKS5sZW5ndGggPiAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9waXBlW2ldLnJ1bihjYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlZCA9IHt9O1xuXG4gICAgICAgICF0aGlzLmlzKFwidmFsaWRcIikgJiYgdGhpcy5lbnRlcihcInZhbGlkXCIpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIHZpZXcuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtPd2wuV2lkdGh9IFtkaW1lbnNpb249T3dsLldpZHRoLkRlZmF1bHRdIC0gVGhlIGRpbWVuc2lvbiB0byByZXR1cm4uXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHdpZHRoIG9mIHRoZSB2aWV3IGluIHBpeGVsLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiB8fCBPd2wuV2lkdGguRGVmYXVsdDtcbiAgICAgICAgc3dpdGNoIChkaW1lbnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgT3dsLldpZHRoLklubmVyOlxuICAgICAgICAgICAgY2FzZSBPd2wuV2lkdGguT3V0ZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggLVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyAqIDIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1hcmdpbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcblx0ICogUmVmcmVzaGVzIHRoZSBjYXJvdXNlbCBwcmltYXJpbHkgZm9yIGFkYXB0aXZlIHB1cnBvc2VzLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVudGVyKFwicmVmcmVzaGluZ1wiKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwicmVmcmVzaFwiKTtcblxuICAgICAgICB0aGlzLnNldHVwKCk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zTG9naWMoKTtcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKTtcblxuICAgICAgICB0aGlzLmxlYXZlKFwicmVmcmVzaGluZ1wiKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwicmVmcmVzaGVkXCIpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLm9uVGhyb3R0bGVkUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lcik7XG4gICAgICAgIHRoaXMucmVzaXplVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzLm9uUmVzaXplLFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlUmVmcmVzaFJhdGVcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIENoZWNrcyB3aW5kb3cgYHJlc2l6ZWAgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3dpZHRoID09PSB0aGlzLiRlbGVtZW50LndpZHRoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy4kZWxlbWVudC5pcyhcIjp2aXNpYmxlXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVudGVyKFwicmVzaXppbmdcIik7XG5cbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlcihcInJlc2l6ZVwiKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWF2ZShcInJlc2l6aW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKFwid2lkdGhcIik7XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgdGhpcy5sZWF2ZShcInJlc2l6aW5nXCIpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJyZXNpemVkXCIpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogUmVnaXN0ZXJzIGV2ZW50IGhhbmRsZXJzLlxuXHQgKiBAdG9kbyBDaGVjayBgbXNQb2ludGVyRW5hYmxlZGBcblx0ICogQHRvZG8gIzI2MVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUucmVnaXN0ZXJFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdGhpcy4kc3RhZ2Uub24oXG4gICAgICAgICAgICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kICsgXCIub3dsLmNvcmVcIixcbiAgICAgICAgICAgICAgICAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlcnMub25UaHJvdHRsZWRSZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubW91c2VEcmFnKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy4kc3RhZ2Uub24oXG4gICAgICAgICAgICAgICAgXCJtb3VzZWRvd24ub3dsLmNvcmVcIixcbiAgICAgICAgICAgICAgICAkLnByb3h5KHRoaXMub25EcmFnU3RhcnQsIHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy4kc3RhZ2Uub24oXG4gICAgICAgICAgICAgICAgXCJkcmFnc3RhcnQub3dsLmNvcmUgc2VsZWN0c3RhcnQub3dsLmNvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50b3VjaERyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuJHN0YWdlLm9uKFxuICAgICAgICAgICAgICAgIFwidG91Y2hzdGFydC5vd2wuY29yZVwiLFxuICAgICAgICAgICAgICAgICQucHJveHkodGhpcy5vbkRyYWdTdGFydCwgdGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLiRzdGFnZS5vbihcbiAgICAgICAgICAgICAgICBcInRvdWNoY2FuY2VsLm93bC5jb3JlXCIsXG4gICAgICAgICAgICAgICAgJC5wcm94eSh0aGlzLm9uRHJhZ0VuZCwgdGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIEhhbmRsZXMgYHRvdWNoc3RhcnRgIGFuZCBgbW91c2Vkb3duYCBldmVudHMuXG5cdCAqIEB0b2RvIEhvcml6b250YWwgc3dpcGUgdGhyZXNob2xkIGFzIG9wdGlvblxuXHQgKiBAdG9kbyAjMjYxXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHN0YWdlID0gbnVsbDtcblxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkLnN1cHBvcnQudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBzdGFnZSA9IHRoaXMuJHN0YWdlXG4gICAgICAgICAgICAgICAgLmNzcyhcInRyYW5zZm9ybVwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8uKlxcKHxcXCl8IC9nLCBcIlwiKVxuICAgICAgICAgICAgICAgIC5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBzdGFnZSA9IHtcbiAgICAgICAgICAgICAgICB4OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTIgOiA0XSxcbiAgICAgICAgICAgICAgICB5OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTMgOiA1XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWdlID0gdGhpcy4kc3RhZ2UucG9zaXRpb24oKTtcbiAgICAgICAgICAgIHN0YWdlID0ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuc2V0dGluZ3MucnRsXG4gICAgICAgICAgICAgICAgICAgID8gc3RhZ2UubGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzdGFnZS53aWR0aCgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2lkdGgoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1hcmdpblxuICAgICAgICAgICAgICAgICAgICA6IHN0YWdlLmxlZnQsXG4gICAgICAgICAgICAgICAgeTogc3RhZ2UudG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXMoXCJhbmltYXRpbmdcIikpIHtcbiAgICAgICAgICAgICQuc3VwcG9ydC50cmFuc2Zvcm0gPyB0aGlzLmFuaW1hdGUoc3RhZ2UueCkgOiB0aGlzLiRzdGFnZS5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoXCJwb3NpdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzLFxuICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gXCJtb3VzZWRvd25cIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3BlZWQoMCk7XG5cbiAgICAgICAgdGhpcy5fZHJhZy50aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMuX2RyYWcudGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xuICAgICAgICB0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0ID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCA9IHN0YWdlO1xuICAgICAgICB0aGlzLl9kcmFnLnBvaW50ZXIgPSB0aGlzLnBvaW50ZXIoZXZlbnQpO1xuXG4gICAgICAgICQoXG4gICAgICAgICAgICBkb2N1bWVudFxuICAgICAgICApLm9uKFwibW91c2V1cC5vd2wuY29yZSB0b3VjaGVuZC5vd2wuY29yZVwiLCAkLnByb3h5KHRoaXMub25EcmFnRW5kLCB0aGlzKSk7XG5cbiAgICAgICAgJChkb2N1bWVudCkub25lKFxuICAgICAgICAgICAgXCJtb3VzZW1vdmUub3dsLmNvcmUgdG91Y2htb3ZlLm93bC5jb3JlXCIsXG4gICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHRoaXMuZGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWcucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcihldmVudClcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibW91c2Vtb3ZlLm93bC5jb3JlIHRvdWNobW92ZS5vd2wuY29yZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5wcm94eSh0aGlzLm9uRHJhZ01vdmUsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoZGVsdGEueCkgPCBNYXRoLmFicyhkZWx0YS55KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXMoXCJ2YWxpZFwiKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRlcihcImRyYWdnaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJkcmFnXCIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogSGFuZGxlcyB0aGUgYHRvdWNobW92ZWAgYW5kIGBtb3VzZW1vdmVgIGV2ZW50cy5cblx0ICogQHRvZG8gIzI2MVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5vbkRyYWdNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIG1pbmltdW0gPSBudWxsLFxuICAgICAgICAgICAgbWF4aW11bSA9IG51bGwsXG4gICAgICAgICAgICBwdWxsID0gbnVsbCxcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSksXG4gICAgICAgICAgICBzdGFnZSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0LCBkZWx0YSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzKFwiZHJhZ2dpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubG9vcCkge1xuICAgICAgICAgICAgbWluaW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xuICAgICAgICAgICAgbWF4aW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkgKyAxKSAtIG1pbmltdW07XG4gICAgICAgICAgICBzdGFnZS54ID0gKChzdGFnZS54IC0gbWluaW11bSkgJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtICtcbiAgICAgICAgICAgICAgICBtaW5pbXVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluaW11bSA9IHRoaXMuc2V0dGluZ3MucnRsXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKVxuICAgICAgICAgICAgICAgIDogdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSk7XG4gICAgICAgICAgICBtYXhpbXVtID0gdGhpcy5zZXR0aW5ncy5ydGxcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKTtcbiAgICAgICAgICAgIHB1bGwgPSB0aGlzLnNldHRpbmdzLnB1bGxEcmFnID8gKC0xKSAqIGRlbHRhLnggLyA1IDogMDtcbiAgICAgICAgICAgIHN0YWdlLnggPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihzdGFnZS54LCBtaW5pbXVtICsgcHVsbCksXG4gICAgICAgICAgICAgICAgbWF4aW11bSArIHB1bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQgPSBzdGFnZTtcblxuICAgICAgICB0aGlzLmFuaW1hdGUoc3RhZ2UueCk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBgdG91Y2hlbmRgIGFuZCBgbW91c2V1cGAgZXZlbnRzLlxuXHQgKiBAdG9kbyAjMjYxXG5cdCAqIEB0b2RvIFRocmVzaG9sZCBmb3IgY2xpY2sgZXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUub25EcmFnRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSksXG4gICAgICAgICAgICBzdGFnZSA9IHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGRlbHRhLnggPiAwIF4gdGhpcy5zZXR0aW5ncy5ydGwgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcblxuICAgICAgICAkKGRvY3VtZW50KS5vZmYoXCIub3dsLmNvcmVcIik7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzKTtcblxuICAgICAgICBpZiAoZGVsdGEueCAhPT0gMCAmJiB0aGlzLmlzKFwiZHJhZ2dpbmdcIikgfHwgIXRoaXMuaXMoXCJ2YWxpZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCh0aGlzLnNldHRpbmdzLmRyYWdFbmRTcGVlZCB8fCB0aGlzLnNldHRpbmdzLnNtYXJ0U3BlZWQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50KFxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VzdChcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UueCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEueCAhPT0gMCA/IGRpcmVjdGlvbiA6IHRoaXMuX2RyYWcuZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShcInBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICAgICAgdGhpcy5fZHJhZy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhkZWx0YS54KSA+IDMgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9kcmFnLnRpbWUgPiAzMDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWcudGFyZ2V0Lm9uZShcImNsaWNrLm93bC5jb3JlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXMoXCJkcmFnZ2luZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sZWF2ZShcImRyYWdnaW5nXCIpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJkcmFnZ2VkXCIpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogR2V0cyBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCBpdGVtIGZvciBhIGNvb3JkaW5hdGUuXG5cdCAqIEB0b2RvIFNldHRpbmcgYGZyZWVEcmFnYCBtYWtlcyBgY2xvc2VzdGAgbm90IHJldXNhYmxlLiBTZWUgIzE2NS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29vcmRpbmF0ZSAtIFRoZSBjb29yZGluYXRlIGluIHBpeGVsLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiB0byBjaGVjayBmb3IgdGhlIGNsb3Nlc3QgaXRlbS4gRXRoZXIgYGxlZnRgIG9yIGByaWdodGAuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbS5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IC0xLFxuICAgICAgICAgICAgcHVsbCA9IDMwLFxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLndpZHRoKCksXG4gICAgICAgICAgICBjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXMoKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuZnJlZURyYWcpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGNsb3Nlc3QgaXRlbVxuICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gYSBsZWZ0IHB1bGwsIGNoZWNrIG9uIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09IFwibGVmdFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHB1bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZSA8IHZhbHVlICsgcHVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiBhIHJpZ2h0IHB1bGwsIGNoZWNrIG9uIHByZXZpb3VzIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gZG8gc28sIHN1YnRyYWN0IHdpZHRoIGZyb20gdmFsdWUgYW5kIHNldCBwb3NpdGlvbiA9IGluZGV4ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09IFwicmlnaHRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlID4gdmFsdWUgLSB3aWR0aCAtIHB1bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZSA8IHZhbHVlIC0gd2lkdGggKyBwdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcChjb29yZGluYXRlLCBcIjxcIiwgdmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3AoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlc1tpbmRleCArIDFdIHx8IHZhbHVlIC0gd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBkaXJlY3Rpb24gPT09IFwibGVmdFwiID8gaW5kZXggKyAxIDogaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gPT09IC0xO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5sb29wKSB7XG4gICAgICAgICAgICAvLyBub24gbG9vcCBib3VuZHJpZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsIFwiPlwiLCBjb29yZGluYXRlc1t0aGlzLm1pbmltdW0oKV0pKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjb29yZGluYXRlID0gdGhpcy5taW5pbXVtKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgXCI8XCIsIGNvb3JkaW5hdGVzW3RoaXMubWF4aW11bSgpXSkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGNvb3JkaW5hdGUgPSB0aGlzLm1heGltdW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIEFuaW1hdGVzIHRoZSBzdGFnZS5cblx0ICogQHRvZG8gIzI3MFxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbihjb29yZGluYXRlKSB7XG4gICAgICAgIHZhciBhbmltYXRlID0gdGhpcy5zcGVlZCgpID4gMDtcblxuICAgICAgICB0aGlzLmlzKFwiYW5pbWF0aW5nXCIpICYmIHRoaXMub25UcmFuc2l0aW9uRW5kKCk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW50ZXIoXCJhbmltYXRpbmdcIik7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJ0cmFuc2xhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJC5zdXBwb3J0LnRyYW5zZm9ybTNkICYmICQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLiRzdGFnZS5jc3Moe1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZChcIiArIGNvb3JkaW5hdGUgKyBcInB4LDBweCwwcHgpXCIsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5zcGVlZCgpIC8gMTAwMCArIFwic1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLiRzdGFnZS5hbmltYXRlKFxuICAgICAgICAgICAgICAgIHsgbGVmdDogY29vcmRpbmF0ZSArIFwicHhcIiB9LFxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZhbGxiYWNrRWFzaW5nLFxuICAgICAgICAgICAgICAgICQucHJveHkodGhpcy5vblRyYW5zaXRpb25FbmQsIHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kc3RhZ2UuY3NzKHsgbGVmdDogY29vcmRpbmF0ZSArIFwicHhcIiB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcblx0ICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGluIGEgc3BlY2lmaWMgc3RhdGUgb3Igbm90LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGUgLSBUaGUgc3RhdGUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSAtIFRoZSBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgY2Fyb3VzZWwgaXMgYnVzeS5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXMuY3VycmVudFtzdGF0ZV0gJiYgdGhpcy5fc3RhdGVzLmN1cnJlbnRbc3RhdGVdID4gMDtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgbmV3IGFic29sdXRlIHBvc2l0aW9uIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgIT09IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIiwge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7IG5hbWU6IFwicG9zaXRpb25cIiwgdmFsdWU6IHBvc2l0aW9uIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xuXG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoXCJwb3NpdGlvblwiKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiY2hhbmdlZFwiLCB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHsgbmFtZTogXCJwb3NpdGlvblwiLCB2YWx1ZTogdGhpcy5fY3VycmVudCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH07XG5cbiAgICAvKipcblx0ICogSW52YWxpZGF0ZXMgdGhlIGdpdmVuIHBhcnQgb2YgdGhlIHVwZGF0ZSByb3V0aW5lLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcnRdIC0gVGhlIHBhcnQgdG8gaW52YWxpZGF0ZS5cblx0ICogQHJldHVybnMge0FycmF5LjxTdHJpbmc+fSAtIFRoZSBpbnZhbGlkYXRlZCBwYXJ0cy5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24ocGFydCkge1xuICAgICAgICBpZiAoJC50eXBlKHBhcnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlZFtwYXJ0XSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmlzKFwidmFsaWRcIikgJiYgdGhpcy5sZWF2ZShcInZhbGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkLm1hcCh0aGlzLl9pbnZhbGlkYXRlZCwgZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogUmVzZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbmV3IGl0ZW0uXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3BlZWQgPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gcG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5zdXBwcmVzcyhbIFwidHJhbnNsYXRlXCIsIFwidHJhbnNsYXRlZFwiIF0pO1xuXG4gICAgICAgIHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHBvc2l0aW9uKSk7XG5cbiAgICAgICAgdGhpcy5yZWxlYXNlKFsgXCJ0cmFuc2xhdGVcIiwgXCJ0cmFuc2xhdGVkXCIgXSk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBOb3JtYWxpemVzIGFuIGFic29sdXRlIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24gb2YgYW4gaXRlbS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcG9zaXRpb24gdG8gbm9ybWFsaXplLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyByZWxhdGl2ZSBvciBub3QuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIG5vcm1hbGl6ZWQgcG9zaXRpb24uXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24ocG9zaXRpb24sIHJlbGF0aXZlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5faXRlbXMubGVuZ3RoLCBtID0gcmVsYXRpdmUgPyAwIDogdGhpcy5fY2xvbmVzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNOdW1lcmljKHBvc2l0aW9uKSB8fCBuIDwgMSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IG4gKyBtKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9ICgocG9zaXRpb24gLSBtIC8gMikgJSBuICsgbikgJSBuICsgbSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBpdGVtIGludG8gYSByZWxhdGl2ZSBvbmUuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIGNvbnZlcnRlZCBwb3NpdGlvbi5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5yZWxhdGl2ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uIC09IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogR2V0cyB0aGUgbWF4aW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvciBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLm1heGltdW0gPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgICAgbWF4aW11bSA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICAgICAgcmVjaXByb2NhbEl0ZW1zV2lkdGgsXG4gICAgICAgICAgICBlbGVtZW50V2lkdGg7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxvb3ApIHtcbiAgICAgICAgICAgIG1heGltdW0gPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMiArIHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLm1lcmdlKSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIHJlY2lwcm9jYWxJdGVtc1dpZHRoID0gdGhpcy5faXRlbXNbLS1pdGVyYXRvcl0ud2lkdGgoKTtcbiAgICAgICAgICAgIGVsZW1lbnRXaWR0aCA9IHRoaXMuJGVsZW1lbnQud2lkdGgoKTtcbiAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci0tKSB7XG4gICAgICAgICAgICAgICAgcmVjaXByb2NhbEl0ZW1zV2lkdGggKz0gdGhpcy5faXRlbXNbaXRlcmF0b3JdLndpZHRoKCkgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1hcmdpbjtcbiAgICAgICAgICAgICAgICBpZiAocmVjaXByb2NhbEl0ZW1zV2lkdGggPiBlbGVtZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4aW11bSA9IGl0ZXJhdG9yICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5jZW50ZXIpIHtcbiAgICAgICAgICAgIG1heGltdW0gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4aW11bSA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIHNldHRpbmdzLml0ZW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICBtYXhpbXVtIC09IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1heGltdW0sIDApO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogR2V0cyB0aGUgbWluaW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvciBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICAgICAgICByZXR1cm4gcmVsYXRpdmUgPyAwIDogdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBHZXRzIGFuIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwb3NpdGlvbi5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cblx0ICogQHJldHVybiB7alF1ZXJ5fEFycmF5LjxqUXVlcnk+fSAtIFRoZSBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvciBhbGwgaXRlbXMgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLml0ZW1zID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1twb3NpdGlvbl07XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBHZXRzIGFuIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwb3NpdGlvbi5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cblx0ICogQHJldHVybiB7alF1ZXJ5fEFycmF5LjxqUXVlcnk+fSAtIFRoZSBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvciBhbGwgaXRlbXMgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLm1lcmdlcnMgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlcnMuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2Vyc1twb3NpdGlvbl07XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBHZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciBhbiBpdGVtLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59IC0gVGhlIGFic29sdXRlIHBvc2l0aW9ucyBvZiBjbG9uZXMgZm9yIHRoZSBpdGVtIG9yIGFsbCBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUuY2xvbmVzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG9kZCA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyLFxuICAgICAgICAgICAgZXZlbiA9IG9kZCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIG1hcCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICUgMiA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGV2ZW4gKyBpbmRleCAvIDJcbiAgICAgICAgICAgICAgICAgICAgOiBvZGQgLSAoaW5kZXggKyAxKSAvIDI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5tYXAodGhpcy5fY2xvbmVzLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcChpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHYgPT09IHBvc2l0aW9uID8gbWFwKGkpIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBTZXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzcGVlZC5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUuc3BlZWQgPSBmdW5jdGlvbihzcGVlZCkge1xuICAgICAgICBpZiAoc3BlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zcGVlZDtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIEdldHMgdGhlIGNvb3JkaW5hdGUgb2YgYW4gaXRlbS5cblx0ICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgbWlzc2xlYW5kaW5nLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB3aXRoaW4gYG1pbmltdW0oKWAgYW5kIGBtYXhpbXVtKClgLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfEFycmF5LjxOdW1iZXI+fSAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSBpdGVtIGluIHBpeGVsIG9yIGFsbCBjb29yZGluYXRlcy5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5jb29yZGluYXRlcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gMSwgbmV3UG9zaXRpb24gPSBwb3NpdGlvbiAtIDEsIGNvb3JkaW5hdGU7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkLm1hcChcbiAgICAgICAgICAgICAgICB0aGlzLl9jb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjb29yZGluYXRlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNlbnRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucnRsKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IC0xO1xuICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb29yZGluYXRlID0gdGhpcy5fY29vcmRpbmF0ZXNbcG9zaXRpb25dO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSArPSAodGhpcy53aWR0aCgpIC1cbiAgICAgICAgICAgICAgICBjb29yZGluYXRlICtcbiAgICAgICAgICAgICAgICAodGhpcy5fY29vcmRpbmF0ZXNbbmV3UG9zaXRpb25dIHx8IDApKSAvXG4gICAgICAgICAgICAgICAgMiAqXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb3JkaW5hdGUgPSBNYXRoLmNlaWwoY29vcmRpbmF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBzcGVlZCBmb3IgYSB0cmFuc2xhdGlvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJvbSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgaXRlbS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgaXRlbS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtmYWN0b3I9dW5kZWZpbmVkXSAtIFRoZSB0aW1lIGZhY3RvciBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNsYXRpb24uXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgICAgIGlmIChmYWN0b3IgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KE1hdGguYWJzKHRvIC0gZnJvbSksIDEpLCA2KSAqXG4gICAgICAgICAgICBNYXRoLmFicyhmYWN0b3IgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQoKSxcbiAgICAgICAgICAgIHJldmVydCA9IG51bGwsXG4gICAgICAgICAgICBkaXN0YW5jZSA9IHBvc2l0aW9uIC0gdGhpcy5yZWxhdGl2ZShjdXJyZW50KSxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IChkaXN0YW5jZSA+IDApIC0gKGRpc3RhbmNlIDwgMCksXG4gICAgICAgICAgICBpdGVtcyA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIG1pbmltdW0gPSB0aGlzLm1pbmltdW0oKSxcbiAgICAgICAgICAgIG1heGltdW0gPSB0aGlzLm1heGltdW0oKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sb29wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmV3aW5kICYmIE1hdGguYWJzKGRpc3RhbmNlKSA+IGl0ZW1zIC8gMikge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlICs9IGRpcmVjdGlvbiAqICgtMSkgKiBpdGVtcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24gPSBjdXJyZW50ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICByZXZlcnQgPSAoKHBvc2l0aW9uIC0gbWluaW11bSkgJSBpdGVtcyArIGl0ZW1zKSAlIGl0ZW1zICsgbWluaW11bTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHJldmVydCAhPT0gcG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0IC0gZGlzdGFuY2UgPD0gbWF4aW11bSAmJlxuICAgICAgICAgICAgICAgICAgICByZXZlcnQgLSBkaXN0YW5jZSA+IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlcnQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHJldmVydDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MucmV3aW5kKSB7XG4gICAgICAgICAgICBtYXhpbXVtICs9IDE7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IChwb3NpdGlvbiAlIG1heGltdW0gKyBtYXhpbXVtKSAlIG1heGltdW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IE1hdGgubWF4KG1pbmltdW0sIE1hdGgubWluKG1heGltdW0sIHBvc2l0aW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNwZWVkKHRoaXMuZHVyYXRpb24oY3VycmVudCwgcG9zaXRpb24sIHNwZWVkKSk7XG4gICAgICAgIHRoaXMuY3VycmVudChwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcblx0ICogU2xpZGVzIHRvIHRoZSBuZXh0IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihzcGVlZCkge1xuICAgICAgICBzcGVlZCA9IHNwZWVkIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnRvKHRoaXMucmVsYXRpdmUodGhpcy5jdXJyZW50KCkpICsgMSwgc3BlZWQpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oc3BlZWQpIHtcbiAgICAgICAgc3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy50byh0aGlzLnJlbGF0aXZlKHRoaXMuY3VycmVudCgpKSAtIDEsIHNwZWVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIEhhbmRsZXMgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIGlmIGNzczIgYW5pbWF0aW9uIHRoZW4gZXZlbnQgb2JqZWN0IGlzIHVuZGVmaW5lZFxuICAgICAgICBpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIENhdGNoIG9ubHkgb3dsLXN0YWdlIHRyYW5zaXRpb25FbmQgZXZlbnRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQub3JpZ2luYWxUYXJnZXQpICE9PVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzdGFnZS5nZXQoMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGVhdmUoXCJhbmltYXRpbmdcIik7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInRyYW5zbGF0ZWRcIik7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBHZXRzIHZpZXdwb3J0IHdpZHRoLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgd2lkdGggaW4gcGl4ZWwuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUudmlld3BvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCAhPT0gd2luZG93KSB7XG4gICAgICAgICAgICB3aWR0aCA9ICQodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCkud2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2FuIG5vdCBkZXRlY3Qgdmlld3BvcnQgd2lkdGguXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgY29udGVudC5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgbmV3IGNvbnRlbnQuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy4kc3RhZ2UuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcblxuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZW50IDogJChjb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3Rvcikge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmluZChcIi5cIiArIHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT09IDE7XG4gICAgICAgIH0pLmVhY2goXG4gICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnByZXBhcmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHN0YWdlLmFwcGVuZChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVyZ2Vycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKFwiW2RhdGEtbWVyZ2VdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZEJhY2soXCJbZGF0YS1tZXJnZV1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtbWVyZ2VcIikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5yZXNldChcbiAgICAgICAgICAgIHRoaXMuaXNOdW1lcmljKHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbilcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvblxuICAgICAgICAgICAgICAgIDogMFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShcIml0ZW1zXCIpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogQWRkcyBhbiBpdGVtLlxuXHQgKiBAdG9kbyBVc2UgYGl0ZW1gIGluc3RlYWQgb2YgYGNvbnRlbnRgIGZvciB0aGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gY29udGVudCAtIFRoZSBpdGVtIGNvbnRlbnQgdG8gYWRkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGl0ZW0gb3RoZXJ3aXNlIHRoZSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjb250ZW50LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMucmVsYXRpdmUodGhpcy5fY3VycmVudCk7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRoaXMuX2l0ZW1zLmxlbmd0aFxuICAgICAgICAgICAgOiB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGVudCA6ICQoY29udGVudCk7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiYWRkXCIsIHsgY29udGVudDogY29udGVudCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuXG4gICAgICAgIGNvbnRlbnQgPSB0aGlzLnByZXBhcmUoY29udGVudCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCB8fCBwb3NpdGlvbiA9PT0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5sZW5ndGggPT09IDAgJiYgdGhpcy4kc3RhZ2UuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5faXRlbXMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNbcG9zaXRpb24gLSAxXS5hZnRlcihjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAuZmluZChcIltkYXRhLW1lcmdlXVwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQmFjayhcIltkYXRhLW1lcmdlXVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtbWVyZ2VcIikgKlxuICAgICAgICAgICAgICAgICAgICAxIHx8XG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1twb3NpdGlvbl0uYmVmb3JlKGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX21lcmdlcnMuc3BsaWNlKFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAuZmluZChcIltkYXRhLW1lcmdlXVwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQmFjayhcIltkYXRhLW1lcmdlXVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtbWVyZ2VcIikgKlxuICAgICAgICAgICAgICAgICAgICAxIHx8XG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pdGVtc1tjdXJyZW50XSAmJiB0aGlzLnJlc2V0KHRoaXMuX2l0ZW1zW2N1cnJlbnRdLmluZGV4KCkpO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShcIml0ZW1zXCIpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcihcImFkZGVkXCIsIHsgY29udGVudDogY29udGVudCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogUmVtb3ZlcyBhbiBpdGVtIGJ5IGl0cyBwb3NpdGlvbi5cblx0ICogQHRvZG8gVXNlIGBpdGVtYCBpbnN0ZWFkIG9mIGBjb250ZW50YCBmb3IgdGhlIGV2ZW50IGFyZ3VtZW50cy5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgICAgY29udGVudDogdGhpcy5faXRlbXNbcG9zaXRpb25dLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgdGhpcy5fbWVyZ2Vycy5zcGxpY2UocG9zaXRpb24sIDEpO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShcIml0ZW1zXCIpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcihcInJlbW92ZWRcIiwgeyBjb250ZW50OiBudWxsLCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBQcmVsb2FkcyBpbWFnZXMgd2l0aCBhdXRvIHdpZHRoLlxuXHQgKiBAdG9kbyBSZXBsYWNlIGJ5IGEgbW9yZSBnZW5lcmljIGFwcHJvYWNoXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5wcmVsb2FkQXV0b1dpZHRoSW1hZ2VzID0gZnVuY3Rpb24oaW1hZ2VzKSB7XG4gICAgICAgIGltYWdlcy5lYWNoKFxuICAgICAgICAgICAgJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50ZXIoXCJwcmUtbG9hZGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICQobmV3IEltYWdlKCkpLm9uZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5wcm94eShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInNyY1wiLCBlLnRhcmdldC5zcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNzcyhcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmUoXCJwcmUtbG9hZGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXMoXCJwcmUtbG9hZGluZ1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXMoXCJpbml0aWFsaXppbmdcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLmF0dHIoXCJzcmNcIiwgZWxlbWVudC5hdHRyKFwic3JjXCIpIHx8IGVsZW1lbnQuYXR0cihcImRhdGEtc3JjXCIpIHx8IGVsZW1lbnQuYXR0cihcImRhdGEtc3JjLXJldGluYVwiKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgY2Fyb3VzZWwuXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKFwiLm93bC5jb3JlXCIpO1xuICAgICAgICB0aGlzLiRzdGFnZS5vZmYoXCIub3dsLmNvcmVcIik7XG4gICAgICAgICQoZG9jdW1lbnQpLm9mZihcIi5vd2wuY29yZVwiKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlcnMub25UaHJvdHRsZWRSZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9wbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW5zW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHN0YWdlLmNoaWxkcmVuKFwiLmNsb25lZFwiKS5yZW1vdmUoKTtcblxuICAgICAgICB0aGlzLiRzdGFnZS51bndyYXAoKTtcbiAgICAgICAgdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jb250ZW50cygpLnVud3JhcCgpO1xuICAgICAgICB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLnVud3JhcCgpO1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRlZENsYXNzKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ydGxDbGFzcylcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZHJhZ0NsYXNzKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MpXG4gICAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgICAgICBcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICsgXCItXFxcXFMrXFxcXHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnJlbW92ZURhdGEoXCJvd2wuY2Fyb3VzZWxcIik7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBPcGVyYXRvcnMgdG8gY2FsY3VsYXRlIHJpZ2h0LXRvLWxlZnQgYW5kIGxlZnQtdG8tcmlnaHQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthXSAtIFRoZSBsZWZ0IHNpZGUgb3BlcmFuZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvXSAtIFRoZSBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiXSAtIFRoZSByaWdodCBzaWRlIG9wZXJhbmQuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUub3AgPSBmdW5jdGlvbihhLCBvLCBiKSB7XG4gICAgICAgIHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bDtcbiAgICAgICAgc3dpdGNoIChvKSB7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBydGwgPyBhID4gYiA6IGEgPCBiO1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcnRsID8gYSA8IGIgOiBhID4gYjtcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBydGwgPyBhIDw9IGIgOiBhID49IGI7XG4gICAgICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcnRsID8gYSA+PSBiIDogYSA8PSBiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcblx0ICogQXR0YWNoZXMgdG8gYW4gaW50ZXJuYWwgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBoYW5kbGVyIHRvIGF0dGFjaC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgaGFuZGxlZCBhdCB0aGUgY2FwdHVyaW5nIHBoYXNlIG9yIG5vdC5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgICAgICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIERldGFjaGVzIGZyb20gYW4gaW50ZXJuYWwgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHRvIGRldGFjaC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHdhcyByZWdpc3RlcmVkIGFzIGEgY2FwdHVyaW5nIGxpc3RlbmVyIG9yIG5vdC5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5kZXRhY2hFdmVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBUcmlnZ2VycyBhIHB1YmxpYyBldmVudC5cblx0ICogQHRvZG8gUmVtb3ZlIGBzdGF0dXNgLCBgcmVsYXRlZFRhcmdldGAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IFtkYXRhPW51bGxdIC0gVGhlIGV2ZW50IGRhdGEuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlPWNhcm91c2VsXSAtIFRoZSBldmVudCBuYW1lc3BhY2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdIC0gVGhlIHN0YXRlIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudGVyPWZhbHNlXSAtIEluZGljYXRlcyBpZiB0aGUgY2FsbCBlbnRlcnMgdGhlIHNwZWNpZmllZCBzdGF0ZSBvciBub3QuXG5cdCAqIEByZXR1cm5zIHtFdmVudH0gLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBuYW1lc3BhY2UsIHN0YXRlLCBlbnRlcikge1xuICAgICAgICB2YXIgc3RhdHVzID0ge1xuICAgICAgICAgICAgaXRlbTogeyBjb3VudDogdGhpcy5faXRlbXMubGVuZ3RoLCBpbmRleDogdGhpcy5jdXJyZW50KCkgfVxuICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlciA9ICQuY2FtZWxDYXNlKFxuICAgICAgICAgICAgICAgICQuZ3JlcChbIFwib25cIiwgbmFtZSwgbmFtZXNwYWNlIF0sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIi1cIikudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV2ZW50ID0gJC5FdmVudChcbiAgICAgICAgICAgICAgICBbIG5hbWUsIFwib3dsXCIsIG5hbWVzcGFjZSB8fCBcImNhcm91c2VsXCIgXVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIi5cIilcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgJC5leHRlbmQoeyByZWxhdGVkVGFyZ2V0OiB0aGlzIH0sIHN0YXR1cywgZGF0YSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zdXByZXNzW25hbWVdKSB7XG4gICAgICAgICAgICAkLmVhY2godGhpcy5fcGx1Z2lucywgZnVuY3Rpb24obmFtZSwgcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5vblRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm9uVHJpZ2dlcihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihldmVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzW2hhbmRsZXJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzW2hhbmRsZXJdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICAvKipcblx0ICogRW50ZXJzIGEgc3RhdGUuXG5cdCAqIEBwYXJhbSBuYW1lIC0gVGhlIHN0YXRlIG5hbWUuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICQuZWFjaChcbiAgICAgICAgICAgIFsgbmFtZSBdLmNvbmNhdCh0aGlzLl9zdGF0ZXMudGFnc1tuYW1lXSB8fCBbXSksXG4gICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdKys7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBMZWF2ZXMgYSBzdGF0ZS5cblx0ICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgWyBuYW1lIF0uY29uY2F0KHRoaXMuX3N0YXRlcy50YWdzW25hbWVdIHx8IFtdKSxcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oaSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXS0tO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogUmVnaXN0ZXJzIGFuIGV2ZW50IG9yIHN0YXRlLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgZXZlbnQgb3Igc3RhdGUgdG8gcmVnaXN0ZXIuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09PSBPd2wuVHlwZS5FdmVudCkge1xuICAgICAgICAgICAgaWYgKCEkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0ub3dsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kZWZhdWx0ID0gJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5fZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLl9kZWZhdWx0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0LmFwcGx5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFlLm5hbWVzcGFjZSB8fCBlLm5hbWVzcGFjZS5pbmRleE9mKFwib3dsXCIpID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2RlZmF1bHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5uYW1lc3BhY2UgJiYgZS5uYW1lc3BhY2UuaW5kZXhPZihcIm93bFwiKSA+IC0xO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5vd2wgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC50eXBlID09PSBPd2wuVHlwZS5TdGF0ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0gPSBvYmplY3QudGFncztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnRhZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0gPSAkLmdyZXAoXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLFxuICAgICAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHRhZywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuaW5BcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICApID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBTdXBwcmVzc2VzIGV2ZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBldmVudHMgLSBUaGUgZXZlbnRzIHRvIHN1cHByZXNzLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLnN1cHByZXNzID0gZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICAgICQuZWFjaChcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oaW5kZXgsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1cHJlc3NbZXZlbnRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFJlbGVhc2VzIHN1cHByZXNzZWQgZXZlbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGV2ZW50cyAtIFRoZSBldmVudHMgdG8gcmVsZWFzZS5cblx0ICovXG4gICAgT3dsLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICAgICQuZWFjaChcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oaW5kZXgsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdXByZXNzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIEdldHMgdW5pZmllZCBwb2ludGVyIGNvb3JkaW5hdGVzIGZyb20gZXZlbnQuXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSAtIFRoZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IC0gQ29udGFpbnMgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLnBvaW50ZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyB4OiBudWxsLCB5OiBudWxsIH07XG5cbiAgICAgICAgZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBldmVudCA9IGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGhcbiAgICAgICAgICAgID8gZXZlbnQudG91Y2hlc1swXVxuICAgICAgICAgICAgOiBldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdXG4gICAgICAgICAgICAgICAgOiBldmVudDtcblxuICAgICAgICBpZiAoZXZlbnQucGFnZVgpIHtcbiAgICAgICAgICAgIHJlc3VsdC54ID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICByZXN1bHQueSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgcmVzdWx0LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdHxBcnJheXxCb29sZWFufFJlZ0V4cHxGdW5jdGlvbnxTeW1ib2x9IC0gVGhlIGlucHV0IHRvIGJlIHRlc3RlZFxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBBbiBpbmRpY2F0aW9uIGlmIHRoZSBpbnB1dCBpcyBhIE51bWJlciBvciBjYW4gYmUgY29lcmNlZCB0byBhIE51bWJlclxuXHQgKi9cbiAgICBPd2wucHJvdG90eXBlLmlzTnVtZXJpYyA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobnVtYmVyKSk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBHZXRzIHRoZSBkaWZmZXJlbmNlIG9mIHR3byB2ZWN0b3JzLlxuXHQgKiBAdG9kbyAjMjYxXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtPYmplY3R9IC0gVGhlIGZpcnN0IHZlY3Rvci5cblx0ICogQHBhcmFtIHtPYmplY3R9IC0gVGhlIHNlY29uZCB2ZWN0b3IuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIGRpZmZlcmVuY2UuXG5cdCAqL1xuICAgIE93bC5wcm90b3R5cGUuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogZmlyc3QueCAtIHNlY29uZC54LCB5OiBmaXJzdC55IC0gc2Vjb25kLnkgfTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFRoZSBqUXVlcnkgUGx1Z2luIGZvciB0aGUgT3dsIENhcm91c2VsXG5cdCAqIEB0b2RvIE5hdmlnYXRpb24gcGx1Z2luIGBuZXh0YCBhbmQgYHByZXZgXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgJC5mbi5vd2xDYXJvdXNlbCA9IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIGRhdGEgPSAkdGhpcy5kYXRhKFwib3dsLmNhcm91c2VsXCIpO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IE93bCh0aGlzLCB0eXBlb2Ygb3B0aW9uID09IFwib2JqZWN0XCIgJiYgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKFwib3dsLmNhcm91c2VsXCIsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5leHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXN0cm95XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlZnJlc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVtb3ZlXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oaSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogZXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLiRlbGVtZW50Lm9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ICsgXCIub3dsLmNhcm91c2VsLmNvcmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5uYW1lc3BhY2UgJiYgZS5yZWxhdGVkVGFyZ2V0ICE9PSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1cHByZXNzKFsgZXZlbnQgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtldmVudF0uYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlKFsgZXZlbnQgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gXCJzdHJpbmdcIiAmJiBvcHRpb24uY2hhckF0KDApICE9PSBcIl9cIikge1xuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBqUXVlcnkgUGx1Z2luXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgJC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3RvciA9IE93bDtcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBhdXRvIHJlZnJlc2ggcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIEF1dG8gUmVmcmVzaCBQbHVnaW5cblx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbFxuXHQgKi9cbiAgICB2YXIgQXV0b1JlZnJlc2ggPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgICAgICAvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPd2x9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcblxuICAgICAgICAvKipcblx0XHQgKiBSZWZyZXNoIGludGVydmFsLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG5cdFx0ICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgdmlzaWJsZSBvciBub3QuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gbnVsbDtcblxuICAgICAgICAvKipcblx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge1xuICAgICAgICAgICAgXCJpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9SZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBBdXRvUmVmcmVzaC5EZWZhdWx0cyxcbiAgICAgICAgICAgIHRoaXMuX2NvcmUub3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogRGVmYXVsdCBvcHRpb25zLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuICAgIEF1dG9SZWZyZXNoLkRlZmF1bHRzID0geyBhdXRvUmVmcmVzaDogdHJ1ZSwgYXV0b1JlZnJlc2hJbnRlcnZhbDogNTAwIH07XG5cbiAgICAvKipcblx0ICogV2F0Y2hlcyB0aGUgZWxlbWVudC5cblx0ICovXG4gICAgQXV0b1JlZnJlc2gucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRoaXMuX2NvcmUuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKTtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAkLnByb3h5KHRoaXMucmVmcmVzaCwgdGhpcyksXG4gICAgICAgICAgICB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9SZWZyZXNoSW50ZXJ2YWxcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgZWxlbWVudC5cblx0ICovXG4gICAgQXV0b1JlZnJlc2gucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvcmUuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSA9PT0gdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9ICF0aGlzLl92aXNpYmxlO1xuXG4gICAgICAgIHRoaXMuX2NvcmUuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJvd2wtaGlkZGVuXCIsICF0aGlzLl92aXNpYmxlKTtcblxuICAgICAgICB0aGlzLl92aXNpYmxlICYmXG4gICAgICAgICAgICAodGhpcy5fY29yZS5pbnZhbGlkYXRlKFwid2lkdGhcIikgJiYgdGhpcy5fY29yZS5yZWZyZXNoKCkpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cblx0ICovXG4gICAgQXV0b1JlZnJlc2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIsIHByb3BlcnR5O1xuXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcblxuICAgICAgICBmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgICAgICAgICB0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gXCJmdW5jdGlvblwiICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BdXRvUmVmcmVzaCA9IEF1dG9SZWZyZXNoO1xufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuXG4oZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG4gICAgLyoqXG5cdCAqIENyZWF0ZXMgdGhlIGxhenkgcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIExhenkgUGx1Z2luXG5cdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcblx0ICovXG4gICAgdmFyIExhenkgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgICAgICAvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPd2x9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcblxuICAgICAgICAvKipcblx0XHQgKiBBbHJlYWR5IGxvYWRlZCBpdGVtcy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5LjxqUXVlcnk+fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSBbXTtcblxuICAgICAgICAvKipcblx0XHQgKiBFdmVudCBoYW5kbGVycy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBcImluaXRpYWxpemVkLm93bC5jYXJvdXNlbCBjaGFuZ2Uub3dsLmNhcm91c2VsIHJlc2l6ZWQub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvcmUuc2V0dGluZ3MgfHwgIXRoaXMuX2NvcmUuc2V0dGluZ3MubGF6eUxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJvcGVydHkgJiYgZS5wcm9wZXJ0eS5uYW1lID09IFwicG9zaXRpb25cIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudHlwZSA9PSBcImluaXRpYWxpemVkXCJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBzZXR0aW5ncy5jZW50ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKHNldHRpbmdzLml0ZW1zIC8gMikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHNldHRpbmdzLmNlbnRlciAmJiBuICogKC0xKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKGUucHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcm9wZXJ0eS52YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZS5wcm9wZXJ0eS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2NvcmUuY3VycmVudCgpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVzID0gdGhpcy5fY29yZS5jbG9uZXMoKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZCA9ICQucHJveHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpKysgPCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZXMgLyAyICsgdGhpcy5fY29yZS5yZWxhdGl2ZShwb3NpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLmNsb25lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnJlbGF0aXZlKHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIExhenkuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlclxuICAgICAgICB0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIERlZmF1bHQgb3B0aW9ucy5cblx0ICogQHB1YmxpY1xuXHQgKi9cbiAgICBMYXp5LkRlZmF1bHRzID0geyBsYXp5TG9hZDogZmFsc2UgfTtcblxuICAgIC8qKlxuXHQgKiBMb2FkcyBhbGwgcmVzb3VyY2VzIG9mIGFuIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICAgIExhenkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgJGl0ZW0gPSB0aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKHBvc2l0aW9uKSxcbiAgICAgICAgICAgICRlbGVtZW50cyA9ICRpdGVtICYmICRpdGVtLmZpbmQoXCIub3dsLWxhenlcIik7XG5cbiAgICAgICAgaWYgKCEkZWxlbWVudHMgfHwgJC5pbkFycmF5KCRpdGVtLmdldCgwKSwgdGhpcy5fbG9hZGVkKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkZWxlbWVudHMuZWFjaChcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuYXR0cihcImRhdGEtc3JjLXJldGluYVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmF0dHIoXCJkYXRhLXNyY1wiKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnRyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxhenlcIlxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgkZWxlbWVudC5pcyhcImltZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQub25lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibG9hZC5vd2wubGF6eVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuY3NzKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUudHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxvYWRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsYXp5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApLmF0dHIoXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAkLnByb3h5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWltYWdlXCI6IFwidXJsKFwiICsgdXJsICsgXCIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBcIjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS50cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsb2FkZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxhenlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2xvYWRlZC5wdXNoKCRpdGVtLmdldCgwKSk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuICAgIExhenkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIsIHByb3BlcnR5O1xuXG4gICAgICAgIGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLmhhbmRsZXJzW2hhbmRsZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgICAgICAgICB0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gXCJmdW5jdGlvblwiICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5MYXp5ID0gTGF6eTtcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBhdXRvIGhlaWdodCBwbHVnaW4uXG5cdCAqIEBjbGFzcyBUaGUgQXV0byBIZWlnaHQgUGx1Z2luXG5cdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcblx0ICovXG4gICAgdmFyIEF1dG9IZWlnaHQgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgICAgICAvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPd2x9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcblxuICAgICAgICAvKipcblx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge1xuICAgICAgICAgICAgXCJpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgcmVmcmVzaGVkLm93bC5jYXJvdXNlbFwiOiAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwiY2hhbmdlZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubmFtZXNwYWNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcm9wZXJ0eS5uYW1lID09IFwicG9zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcImxvYWRlZC5vd2wubGF6eVwiOiAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgZS5uYW1lc3BhY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsb3Nlc3QoXCIuXCIgKyB0aGlzLl9jb3JlLnNldHRpbmdzLml0ZW1DbGFzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluZGV4KCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuY3VycmVudCgpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIEF1dG9IZWlnaHQuRGVmYXVsdHMsXG4gICAgICAgICAgICB0aGlzLl9jb3JlLm9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAgICB0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIERlZmF1bHQgb3B0aW9ucy5cblx0ICogQHB1YmxpY1xuXHQgKi9cbiAgICBBdXRvSGVpZ2h0LkRlZmF1bHRzID0geyBhdXRvSGVpZ2h0OiBmYWxzZSwgYXV0b0hlaWdodENsYXNzOiBcIm93bC1oZWlnaHRcIiB9O1xuXG4gICAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHZpZXcuXG5cdCAqL1xuICAgIEF1dG9IZWlnaHQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jb3JlLl9jdXJyZW50LFxuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLl9jb3JlLnNldHRpbmdzLml0ZW1zLFxuICAgICAgICAgICAgdmlzaWJsZSA9IHRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCkudG9BcnJheSgpLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgaGVpZ2h0cyA9IFtdLFxuICAgICAgICAgICAgbWF4aGVpZ2h0ID0gMDtcblxuICAgICAgICAkLmVhY2godmlzaWJsZSwgZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgICAgIGhlaWdodHMucHVzaCgkKGl0ZW0pLmhlaWdodCgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWF4aGVpZ2h0ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XG5cbiAgICAgICAgdGhpcy5fY29yZS4kc3RhZ2VcbiAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgLmhlaWdodChtYXhoZWlnaHQpXG4gICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0Q2xhc3MpO1xuICAgIH07XG5cbiAgICBBdXRvSGVpZ2h0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgICAgICAgICB0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gXCJmdW5jdGlvblwiICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BdXRvSGVpZ2h0ID0gQXV0b0hlaWdodDtcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIC8qKlxuXHQgKiBDcmVhdGVzIHRoZSB2aWRlbyBwbHVnaW4uXG5cdCAqIEBjbGFzcyBUaGUgVmlkZW8gUGx1Z2luXG5cdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcblx0ICovXG4gICAgdmFyIFZpZGVvID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcbiAgICAgICAgLyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T3dsfVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cbiAgICAgICAgLyoqXG5cdFx0ICogQ2FjaGUgYWxsIHZpZGVvIFVSTHMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX3ZpZGVvcyA9IHt9O1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIEN1cnJlbnQgcGxheWluZyBpdGVtLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7alF1ZXJ5fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9wbGF5aW5nID0gbnVsbDtcblxuICAgICAgICAvKipcblx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHRvZG8gVGhlIGNsb25lZCBjb250ZW50IHJlbW92YWxlIGlzIHRvbyBsYXRlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge1xuICAgICAgICAgICAgXCJpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicGxheWluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IFsgXCJpbnRlcmFjdGluZ1wiIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJyZXNpemUub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm5hbWVzcGFjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzSW5GdWxsU2NyZWVuKClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInJlZnJlc2hlZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLmlzKFwicmVzaXppbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuJHN0YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoXCIuY2xvbmVkIC5vd2wtdmlkZW8tZnJhbWVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcImNoYW5nZWQub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm5hbWVzcGFjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJvcGVydHkubmFtZSA9PT0gXCJwb3NpdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheWluZ1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJwcmVwYXJlZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZS5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZS5jb250ZW50KS5maW5kKFwiLm93bC12aWRlb1wiKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoJGVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2goJGVsZW1lbnQsICQoZS5jb250ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBWaWRlby5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcblxuICAgICAgICAvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAgICB0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblxuICAgICAgICB0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKFxuICAgICAgICAgICAgXCJjbGljay5vd2wudmlkZW9cIixcbiAgICAgICAgICAgIFwiLm93bC12aWRlby1wbGF5LWljb25cIixcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBEZWZhdWx0IG9wdGlvbnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgVmlkZW8uRGVmYXVsdHMgPSB7IHZpZGVvOiBmYWxzZSwgdmlkZW9IZWlnaHQ6IGZhbHNlLCB2aWRlb1dpZHRoOiBmYWxzZSB9O1xuXG4gICAgLyoqXG5cdCAqIEdldHMgdGhlIHZpZGVvIElEIGFuZCB0aGUgdHlwZSAoWW91VHViZS9WaW1lby92emFhciBvbmx5KS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250YWluaW5nIHRoZSB2aWRlbyBkYXRhLlxuXHQgKiBAcGFyYW0ge2pRdWVyeX0gaXRlbSAtIFRoZSBpdGVtIGNvbnRhaW5pbmcgdGhlIHZpZGVvLlxuXHQgKi9cbiAgICBWaWRlby5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbih0YXJnZXQsIGl0ZW0pIHtcbiAgICAgICAgdmFyIHR5cGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmF0dHIoXCJkYXRhLXZpbWVvLWlkXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmltZW9cIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dHIoXCJkYXRhLXZ6YWFyLWlkXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidnphYXJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieW91dHViZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuICAgICAgICAgICAgaWQgPSB0YXJnZXQuYXR0cihcImRhdGEtdmltZW8taWRcIikgfHxcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXR0cihcImRhdGEteW91dHViZS1pZFwiKSB8fFxuICAgICAgICAgICAgICAgIHRhcmdldC5hdHRyKFwiZGF0YS12emFhci1pZFwiKSxcbiAgICAgICAgICAgIHdpZHRoID0gdGFyZ2V0LmF0dHIoXCJkYXRhLXdpZHRoXCIpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9XaWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRhcmdldC5hdHRyKFwiZGF0YS1oZWlnaHRcIikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvSGVpZ2h0LFxuICAgICAgICAgICAgdXJsID0gdGFyZ2V0LmF0dHIoXCJocmVmXCIpO1xuXG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIC8qXG5cdFx0XHRcdFx0UGFyc2VzIHRoZSBpZCdzIG91dCBvZiB0aGUgZm9sbG93aW5nIHVybHMgKGFuZCBwcm9iYWJseSBtb3JlKTpcblx0XHRcdFx0XHRodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTppZFxuXHRcdFx0XHRcdGh0dHBzOi8veW91dHUuYmUvOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly92aW1lby5jb20vOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly92aW1lby5jb20vY2hhbm5lbHMvOmNoYW5uZWwvOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly92aW1lby5jb20vZ3JvdXBzLzpncm91cC92aWRlb3MvOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly9hcHAudnphYXIuY29tL3ZpZGVvcy86aWRcblxuXHRcdFx0XHRcdFZpc3VhbCBleGFtcGxlOiBodHRwczovL3JlZ2V4cGVyLmNvbS8jKGh0dHAlM0ElN0NodHRwcyUzQSU3QyklNUMlMkYlNUMlMkYocGxheWVyLiU3Q3d3dy4lN0NhcHAuKSUzRih2aW1lbyU1Qy5jb20lN0N5b3V0dShiZSU1Qy5jb20lN0MlNUMuYmUlN0NiZSU1Qy5nb29nbGVhcGlzJTVDLmNvbSklN0N2emFhciU1Qy5jb20pJTVDJTJGKHZpZGVvJTVDJTJGJTdDdmlkZW9zJTVDJTJGJTdDZW1iZWQlNUMlMkYlN0NjaGFubmVscyU1QyUyRi4lMkIlNUMlMkYlN0Nncm91cHMlNUMlMkYuJTJCJTVDJTJGJTdDd2F0Y2glNUMlM0Z2JTNEJTdDdiU1QyUyRiklM0YoJTVCQS1aYS16MC05Ll8lMjUtJTVEKikoJTVDJTI2JTVDUyUyQiklM0Zcblx0XHRcdCovXG4gICAgICAgICAgICBpZCA9IHVybC5tYXRjaChcbiAgICAgICAgICAgICAgICAvKGh0dHA6fGh0dHBzOnwpXFwvXFwvKHBsYXllci58d3d3LnxhcHAuKT8odmltZW9cXC5jb218eW91dHUoYmVcXC5jb218XFwuYmV8YmVcXC5nb29nbGVhcGlzXFwuY29tKXx2emFhclxcLmNvbSlcXC8odmlkZW9cXC98dmlkZW9zXFwvfGVtYmVkXFwvfGNoYW5uZWxzXFwvLitcXC98Z3JvdXBzXFwvLitcXC98d2F0Y2hcXD92PXx2XFwvKT8oW0EtWmEtejAtOS5fJS1dKikoXFwmXFxTKyk/L1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGlkWzNdLmluZGV4T2YoXCJ5b3V0dVwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwieW91dHViZVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZFszXS5pbmRleE9mKFwidmltZW9cIikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcInZpbWVvXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkWzNdLmluZGV4T2YoXCJ2emFhclwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwidnphYXJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlkZW8gVVJMIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWQgPSBpZFs2XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmlkZW8gVVJMLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZpZGVvc1t1cmxdID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaXRlbS5hdHRyKFwiZGF0YS12aWRlb1wiLCB1cmwpO1xuXG4gICAgICAgIHRoaXMudGh1bWJuYWlsKHRhcmdldCwgdGhpcy5fdmlkZW9zW3VybF0pO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogQ3JlYXRlcyB2aWRlbyB0aHVtYm5haWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtqUXVlcnl9IHRhcmdldCAtIFRoZSB0YXJnZXQgY29udGFpbmluZyB0aGUgdmlkZW8gZGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBUaGUgdmlkZW8gaW5mbyBvYmplY3QuXG5cdCAqIEBzZWUgYGZldGNoYFxuXHQgKi9cbiAgICBWaWRlby5wcm90b3R5cGUudGh1bWJuYWlsID0gZnVuY3Rpb24odGFyZ2V0LCB2aWRlbykge1xuICAgICAgICB2YXIgdG5MaW5rLFxuICAgICAgICAgICAgaWNvbixcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gdmlkZW8ud2lkdGggJiYgdmlkZW8uaGVpZ2h0XG4gICAgICAgICAgICAgICAgPyAnc3R5bGU9XCJ3aWR0aDonICtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8ud2lkdGggK1xuICAgICAgICAgICAgICAgICAgICBcInB4O2hlaWdodDpcIiArXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLmhlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICdweDtcIidcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBjdXN0b21UbiA9IHRhcmdldC5maW5kKFwiaW1nXCIpLFxuICAgICAgICAgICAgc3JjVHlwZSA9IFwic3JjXCIsXG4gICAgICAgICAgICBsYXp5Q2xhc3MgPSBcIlwiLFxuICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzLFxuICAgICAgICAgICAgY3JlYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgIGljb24gPSAnPGRpdiBjbGFzcz1cIm93bC12aWRlby1wbGF5LWljb25cIj48L2Rpdj4nO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmxhenlMb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRuTGluayA9ICc8ZGl2IGNsYXNzPVwib3dsLXZpZGVvLXRuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF6eUNsYXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1R5cGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJz1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCI+PC9kaXY+JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bkxpbmsgPSAnPGRpdiBjbGFzcz1cIm93bC12aWRlby10blwiIHN0eWxlPVwib3BhY2l0eToxO2JhY2tncm91bmQtaW1hZ2U6dXJsKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKVwiPjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5hZnRlcih0bkxpbmspO1xuICAgICAgICAgICAgICAgIHRhcmdldC5hZnRlcihpY29uKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gd3JhcCB2aWRlbyBjb250ZW50IGludG8gb3dsLXZpZGVvLXdyYXBwZXIgZGl2XG4gICAgICAgIHRhcmdldC53cmFwKCc8ZGl2IGNsYXNzPVwib3dsLXZpZGVvLXdyYXBwZXJcIicgKyBkaW1lbnNpb25zICsgXCI+PC9kaXY+XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmxhenlMb2FkKSB7XG4gICAgICAgICAgICBzcmNUeXBlID0gXCJkYXRhLXNyY1wiO1xuICAgICAgICAgICAgbGF6eUNsYXNzID0gXCJvd2wtbGF6eVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VzdG9tIHRodW1ibmFpbFxuICAgICAgICBpZiAoY3VzdG9tVG4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjcmVhdGUoY3VzdG9tVG4uYXR0cihzcmNUeXBlKSk7XG4gICAgICAgICAgICBjdXN0b21Ubi5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWRlby50eXBlID09PSBcInlvdXR1YmVcIikge1xuICAgICAgICAgICAgcGF0aCA9IFwiLy9pbWcueW91dHViZS5jb20vdmkvXCIgKyB2aWRlby5pZCArIFwiL2hxZGVmYXVsdC5qcGdcIjtcbiAgICAgICAgICAgIGNyZWF0ZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlby50eXBlID09PSBcInZpbWVvXCIpIHtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgICAgICB1cmw6IFwiLy92aW1lby5jb20vYXBpL3YyL3ZpZGVvL1wiICsgdmlkZW8uaWQgKyBcIi5qc29uXCIsXG4gICAgICAgICAgICAgICAganNvbnA6IFwiY2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29ucFwiLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGRhdGFbMF0udGh1bWJuYWlsX2xhcmdlO1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGUocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gXCJ2emFhclwiKSB7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiBcIi8vdnphYXIuY29tL2FwaS92aWRlb3MvXCIgKyB2aWRlby5pZCArIFwiLmpzb25cIixcbiAgICAgICAgICAgICAgICBqc29ucDogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25wXCIsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gZGF0YS5mcmFtZWdyYWJfdXJsO1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGUocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFN0b3BzIHRoZSBjdXJyZW50IHZpZGVvLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuICAgIFZpZGVvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NvcmUudHJpZ2dlcihcInN0b3BcIiwgbnVsbCwgXCJ2aWRlb1wiKTtcbiAgICAgICAgdGhpcy5fcGxheWluZy5maW5kKFwiLm93bC12aWRlby1mcmFtZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fcGxheWluZy5yZW1vdmVDbGFzcyhcIm93bC12aWRlby1wbGF5aW5nXCIpO1xuICAgICAgICB0aGlzLl9wbGF5aW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29yZS5sZWF2ZShcInBsYXlpbmdcIik7XG4gICAgICAgIHRoaXMuX2NvcmUudHJpZ2dlcihcInN0b3BwZWRcIiwgbnVsbCwgXCJ2aWRlb1wiKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFN0YXJ0cyB0aGUgY3VycmVudCB2aWRlby5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXG5cdCAqL1xuICAgIFZpZGVvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgICAgIGl0ZW0gPSB0YXJnZXQuY2xvc2VzdChcIi5cIiArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbUNsYXNzKSxcbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5fdmlkZW9zW2l0ZW0uYXR0cihcImRhdGEtdmlkZW9cIildLFxuICAgICAgICAgICAgd2lkdGggPSB2aWRlby53aWR0aCB8fCBcIjEwMCVcIixcbiAgICAgICAgICAgIGhlaWdodCA9IHZpZGVvLmhlaWdodCB8fCB0aGlzLl9jb3JlLiRzdGFnZS5oZWlnaHQoKSxcbiAgICAgICAgICAgIGh0bWw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvcmUuZW50ZXIoXCJwbGF5aW5nXCIpO1xuICAgICAgICB0aGlzLl9jb3JlLnRyaWdnZXIoXCJwbGF5XCIsIG51bGwsIFwidmlkZW9cIik7XG5cbiAgICAgICAgaXRlbSA9IHRoaXMuX2NvcmUuaXRlbXModGhpcy5fY29yZS5yZWxhdGl2ZShpdGVtLmluZGV4KCkpKTtcblxuICAgICAgICB0aGlzLl9jb3JlLnJlc2V0KGl0ZW0uaW5kZXgoKSk7XG5cbiAgICAgICAgaWYgKHZpZGVvLnR5cGUgPT09IFwieW91dHViZVwiKSB7XG4gICAgICAgICAgICBodG1sID0gJzxpZnJhbWUgd2lkdGg9XCInICtcbiAgICAgICAgICAgICAgICB3aWR0aCArXG4gICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgK1xuICAgICAgICAgICAgICAgIGhlaWdodCArXG4gICAgICAgICAgICAgICAgJ1wiIHNyYz1cIi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLycgK1xuICAgICAgICAgICAgICAgIHZpZGVvLmlkICtcbiAgICAgICAgICAgICAgICBcIj9hdXRvcGxheT0xJnY9XCIgK1xuICAgICAgICAgICAgICAgIHZpZGVvLmlkICtcbiAgICAgICAgICAgICAgICAnXCIgZnJhbWVib3JkZXI9XCIwXCIgYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPic7XG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gXCJ2aW1lb1wiKSB7XG4gICAgICAgICAgICBodG1sID0gJzxpZnJhbWUgc3JjPVwiLy9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLycgK1xuICAgICAgICAgICAgICAgIHZpZGVvLmlkICtcbiAgICAgICAgICAgICAgICAnP2F1dG9wbGF5PTFcIiB3aWR0aD1cIicgK1xuICAgICAgICAgICAgICAgIHdpZHRoICtcbiAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAnXCIgZnJhbWVib3JkZXI9XCIwXCIgd2Via2l0YWxsb3dmdWxsc2NyZWVuIG1vemFsbG93ZnVsbHNjcmVlbiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+JztcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlby50eXBlID09PSBcInZ6YWFyXCIpIHtcbiAgICAgICAgICAgIGh0bWwgPSAnPGlmcmFtZSBmcmFtZWJvcmRlcj1cIjBcIicgK1xuICAgICAgICAgICAgICAgICdoZWlnaHQ9XCInICtcbiAgICAgICAgICAgICAgICBoZWlnaHQgK1xuICAgICAgICAgICAgICAgICdcIicgK1xuICAgICAgICAgICAgICAgICd3aWR0aD1cIicgK1xuICAgICAgICAgICAgICAgIHdpZHRoICtcbiAgICAgICAgICAgICAgICAnXCIgYWxsb3dmdWxsc2NyZWVuIG1vemFsbG93ZnVsbHNjcmVlbiB3ZWJraXRBbGxvd0Z1bGxTY3JlZW4gJyArXG4gICAgICAgICAgICAgICAgJ3NyYz1cIi8vdmlldy52emFhci5jb20vJyArXG4gICAgICAgICAgICAgICAgdmlkZW8uaWQgK1xuICAgICAgICAgICAgICAgICcvcGxheWVyP2F1dG9wbGF5PXRydWVcIj48L2lmcmFtZT4nO1xuICAgICAgICB9XG5cbiAgICAgICAgJChcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwib3dsLXZpZGVvLWZyYW1lXCI+JyArIGh0bWwgKyBcIjwvZGl2PlwiXG4gICAgICAgICkuaW5zZXJ0QWZ0ZXIoaXRlbS5maW5kKFwiLm93bC12aWRlb1wiKSk7XG5cbiAgICAgICAgdGhpcy5fcGxheWluZyA9IGl0ZW0uYWRkQ2xhc3MoXCJvd2wtdmlkZW8tcGxheWluZ1wiKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIGFuIHZpZGVvIGlzIGN1cnJlbnRseSBpbiBmdWxsIHNjcmVlbiBtb2RlIG9yIG5vdC5cblx0ICogQHRvZG8gQmFkIHN0eWxlIGJlY2F1c2UgbG9va3MgbGlrZSBhIHJlYWRvbmx5IG1ldGhvZCBidXQgY2hhbmdlcyBtZW1iZXJzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKi9cbiAgICBWaWRlby5wcm90b3R5cGUuaXNJbkZ1bGxTY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmICQoZWxlbWVudCkucGFyZW50KCkuaGFzQ2xhc3MoXCJvd2wtdmlkZW8tZnJhbWVcIik7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuXHQgKi9cbiAgICBWaWRlby5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFuZGxlciwgcHJvcGVydHk7XG5cbiAgICAgICAgdGhpcy5fY29yZS4kZWxlbWVudC5vZmYoXCJjbGljay5vd2wudmlkZW9cIik7XG5cbiAgICAgICAgZm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgICAgICAgICAgdHlwZW9mIHRoaXNbcHJvcGVydHldICE9IFwiZnVuY3Rpb25cIiAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuVmlkZW8gPSBWaWRlbztcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBhbmltYXRlIHBsdWdpbi5cblx0ICogQGNsYXNzIFRoZSBOYXZpZ2F0aW9uIFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuICAgIHZhciBBbmltYXRlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgdGhpcy5jb3JlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEFuaW1hdGUuRGVmYXVsdHMsIHRoaXMuY29yZS5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5zd2FwcGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge1xuICAgICAgICAgICAgXCJjaGFuZ2Uub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09IFwicG9zaXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuY29yZS5jdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBlLnByb3BlcnR5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJkcmFnLm93bC5jYXJvdXNlbCBkcmFnZ2VkLm93bC5jYXJvdXNlbCB0cmFuc2xhdGVkLm93bC5jYXJvdXNlbFwiOiAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN3YXBwaW5nID0gZS50eXBlID09IFwidHJhbnNsYXRlZFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJ0cmFuc2xhdGUub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm5hbWVzcGFjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jb3JlLm9wdGlvbnMuYW5pbWF0ZU91dCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcmUub3B0aW9ucy5hbmltYXRlSW4pXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvcmUuJGVsZW1lbnQub24odGhpcy5oYW5kbGVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBEZWZhdWx0IG9wdGlvbnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgQW5pbWF0ZS5EZWZhdWx0cyA9IHsgYW5pbWF0ZU91dDogZmFsc2UsIGFuaW1hdGVJbjogZmFsc2UgfTtcblxuICAgIC8qKlxuXHQgKiBUb2dnbGVzIHRoZSBhbmltYXRpb24gY2xhc3NlcyB3aGVuZXZlciBhbiB0cmFuc2xhdGlvbnMgc3RhcnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufHVuZGVmaW5lZH1cblx0ICovXG4gICAgQW5pbWF0ZS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jb3JlLnNldHRpbmdzLml0ZW1zICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISQuc3VwcG9ydC5hbmltYXRpb24gfHwgISQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvcmUuc3BlZWQoMCk7XG5cbiAgICAgICAgdmFyIGxlZnQsXG4gICAgICAgICAgICBjbGVhciA9ICQucHJveHkodGhpcy5jbGVhciwgdGhpcyksXG4gICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMuY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcSh0aGlzLnByZXZpb3VzKSxcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5uZXh0KSxcbiAgICAgICAgICAgIGluY29taW5nID0gdGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbixcbiAgICAgICAgICAgIG91dGdvaW5nID0gdGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVPdXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY29yZS5jdXJyZW50KCkgPT09IHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXRnb2luZykge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMuY29yZS5jb29yZGluYXRlcyh0aGlzLnByZXZpb3VzKSAtXG4gICAgICAgICAgICAgICAgdGhpcy5jb3JlLmNvb3JkaW5hdGVzKHRoaXMubmV4dCk7XG4gICAgICAgICAgICBwcmV2aW91c1xuICAgICAgICAgICAgICAgIC5vbmUoJC5zdXBwb3J0LmFuaW1hdGlvbi5lbmQsIGNsZWFyKVxuICAgICAgICAgICAgICAgIC5jc3MoeyBsZWZ0OiBsZWZ0ICsgXCJweFwiIH0pXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiYW5pbWF0ZWQgb3dsLWFuaW1hdGVkLW91dFwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhvdXRnb2luZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jb21pbmcpIHtcbiAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJhbmltYXRlZCBvd2wtYW5pbWF0ZWQtaW5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoaW5jb21pbmcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFuaW1hdGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAkKGUudGFyZ2V0KVxuICAgICAgICAgICAgLmNzcyh7IGxlZnQ6IFwiXCIgfSlcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImFuaW1hdGVkIG93bC1hbmltYXRlZC1vdXQgb3dsLWFuaW1hdGVkLWluXCIpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbilcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZU91dCk7XG4gICAgICAgIHRoaXMuY29yZS5vblRyYW5zaXRpb25FbmQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgQW5pbWF0ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFuZGxlciwgcHJvcGVydHk7XG5cbiAgICAgICAgZm9yIChoYW5kbGVyIGluIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5oYW5kbGVyc1toYW5kbGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgICAgICAgICAgdHlwZW9mIHRoaXNbcHJvcGVydHldICE9IFwiZnVuY3Rpb25cIiAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuQW5pbWF0ZSA9IEFuaW1hdGU7XG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cbihmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcbiAgICAvKipcblx0ICogQ3JlYXRlcyB0aGUgYXV0b3BsYXkgcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIEF1dG9wbGF5IFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuICAgIHZhciBBdXRvcGxheSA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XG4gICAgICAgIC8qKlxuXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge093bH1cblx0XHQgKi9cbiAgICAgICAgdGhpcy5fY29yZSA9IGNhcm91c2VsO1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIFRoZSBhdXRvcGxheSB0aW1lb3V0LlxuXHRcdCAqIEB0eXBlIHtUaW1lb3V0fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hlbmV2ZXIgdGhlIGF1dG9wbGF5IGlzIHBhdXNlZC5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG5cdFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHtcbiAgICAgICAgICAgIFwiY2hhbmdlZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT09IFwic2V0dGluZ3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSBcInBvc2l0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BsYXk/JywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEF1dG9QbGF5SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwiaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInBsYXkub3dsLmF1dG9wbGF5XCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSwgdCwgcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGxheSh0LCBzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RvcC5vd2wuYXV0b3BsYXlcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcIm1vdXNlb3Zlci5vd2wuYXV0b3BsYXlcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLmlzKFwicm90YXRpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcIm1vdXNlbGVhdmUub3dsLmF1dG9wbGF5XCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS5pcyhcInJvdGF0aW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInRvdWNoc3RhcnQub3dsLmNvcmVcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLmlzKFwicm90YXRpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInRvdWNoZW5kLm93bC5jb3JlXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAgICB0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBBdXRvcGxheS5EZWZhdWx0cyxcbiAgICAgICAgICAgIHRoaXMuX2NvcmUub3B0aW9uc1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogRGVmYXVsdCBvcHRpb25zLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuICAgIEF1dG9wbGF5LkRlZmF1bHRzID0ge1xuICAgICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICAgIGF1dG9wbGF5VGltZW91dDogNTAwMCxcbiAgICAgICAgYXV0b3BsYXlIb3ZlclBhdXNlOiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXlTcGVlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFN0YXJ0cyB0aGUgYXV0b3BsYXkuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0XSAtIFRoZSBpbnRlcnZhbCBiZWZvcmUgdGhlIG5leHQgYW5pbWF0aW9uIHN0YXJ0cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGZvciB0aGUgYW5pbWF0aW9ucy5cblx0ICovXG4gICAgQXV0b3BsYXkucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih0aW1lb3V0LCBzcGVlZCkge1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5fY29yZS5pcyhcInJvdGF0aW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb3JlLmVudGVyKFwicm90YXRpbmdcIik7XG5cbiAgICAgICAgdGhpcy5fc2V0QXV0b1BsYXlJbnRlcnZhbCgpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogR2V0cyBhIG5ldyB0aW1lb3V0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dF0gLSBUaGUgaW50ZXJ2YWwgYmVmb3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBzdGFydHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge1RpbWVvdXR9XG5cdCAqL1xuICAgIEF1dG9wbGF5LnByb3RvdHlwZS5fZ2V0TmV4dFRpbWVvdXQgPSBmdW5jdGlvbih0aW1lb3V0LCBzcGVlZCkge1xuICAgICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLmlzKFwiYnVzeVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuaXMoXCJpbnRlcmFjdGluZ1wiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhpZGRlblxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLm5leHQoc3BlZWQgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheVNwZWVkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aW1lb3V0IHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlUaW1lb3V0XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBTZXRzIGF1dG9wbGF5IGluIG1vdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG4gICAgQXV0b3BsYXkucHJvdG90eXBlLl9zZXRBdXRvUGxheUludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSB0aGlzLl9nZXROZXh0VGltZW91dCgpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxuXHQgKiBAcHVibGljXG5cdCAqL1xuICAgIEF1dG9wbGF5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29yZS5pcyhcInJvdGF0aW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICB0aGlzLl9jb3JlLmxlYXZlKFwicm90YXRpbmdcIik7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBTdG9wcyB0aGUgYXV0b3BsYXkuXG5cdCAqIEBwdWJsaWNcblx0ICovXG4gICAgQXV0b3BsYXkucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29yZS5pcyhcInJvdGF0aW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cblx0ICovXG4gICAgQXV0b3BsYXkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIsIHByb3BlcnR5O1xuXG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSBcImZ1bmN0aW9uXCIgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLmF1dG9wbGF5ID0gQXV0b3BsYXk7XG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cbihmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAvKipcblx0ICogQ3JlYXRlcyB0aGUgbmF2aWdhdGlvbiBwbHVnaW4uXG5cdCAqIEBjbGFzcyBUaGUgTmF2aWdhdGlvbiBQbHVnaW5cblx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbC5cblx0ICovXG4gICAgdmFyIE5hdmlnYXRpb24gPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuICAgICAgICAvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPd2x9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcblxuICAgICAgICAvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcGx1Z2luIGlzIGluaXRpYWxpemVkIG9yIG5vdC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgcGFnaW5nIGluZGV4ZXMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cbiAgICAgICAgdGhpcy5fcGFnZXMgPSBbXTtcblxuICAgICAgICAvKipcblx0XHQgKiBBbGwgRE9NIGVsZW1lbnRzIG9mIHRoZSB1c2VyIGludGVyZmFjZS5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSB7fTtcblxuICAgICAgICAvKipcblx0XHQgKiBNYXJrdXAgZm9yIGFuIGluZGljYXRvci5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5LjxTdHJpbmc+fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZXMgPSBbXTtcblxuICAgICAgICAvKipcblx0XHQgKiBUaGUgY2Fyb3VzZWwgZWxlbWVudC5cblx0XHQgKiBAdHlwZSB7alF1ZXJ5fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gdGhpcy5fY29yZS4kZWxlbWVudDtcblxuICAgICAgICAvKipcblx0XHQgKiBPdmVycmlkZGVuIG1ldGhvZHMgb2YgdGhlIGNhcm91c2VsLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9vdmVycmlkZXMgPSB7XG4gICAgICAgICAgICBuZXh0OiB0aGlzLl9jb3JlLm5leHQsXG4gICAgICAgICAgICBwcmV2OiB0aGlzLl9jb3JlLnByZXYsXG4gICAgICAgICAgICB0bzogdGhpcy5fY29yZS50b1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuXHRcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBcInByZXBhcmVkLm93bC5jYXJvdXNlbFwiOiAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuZG90c0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuc2V0dGluZ3MuZG90Q2xhc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoXCJbZGF0YS1kb3RdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQmFjayhcIltkYXRhLWRvdF1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZGF0YS1kb3RcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJhZGRlZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZXMuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZXMucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInJlbW92ZS5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZXMuc3BsaWNlKGUucG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJjaGFuZ2VkLm93bC5jYXJvdXNlbFwiOiAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PSBcInBvc2l0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSAmJiAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUudHJpZ2dlcihcImluaXRpYWxpemVcIiwgbnVsbCwgXCJuYXZpZ2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnRyaWdnZXIoXCJpbml0aWFsaXplZFwiLCBudWxsLCBcIm5hdmlnYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInJlZnJlc2hlZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS50cmlnZ2VyKFwicmVmcmVzaFwiLCBudWxsLCBcIm5hdmlnYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnRyaWdnZXIoXCJyZWZyZXNoZWRcIiwgbnVsbCwgXCJuYXZpZ2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZChcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgTmF2aWdhdGlvbi5EZWZhdWx0cyxcbiAgICAgICAgICAgIHRoaXMuX2NvcmUub3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogRGVmYXVsdCBvcHRpb25zLlxuXHQgKiBAcHVibGljXG5cdCAqIEB0b2RvIFJlbmFtZSBgc2xpZGVCeWAgdG8gYG5hdkJ5YFxuXHQgKi9cbiAgICBOYXZpZ2F0aW9uLkRlZmF1bHRzID0ge1xuICAgICAgICBuYXY6IGZhbHNlLFxuICAgICAgICBuYXZUZXh0OiBbIFwicHJldlwiLCBcIm5leHRcIiBdLFxuICAgICAgICBuYXZTcGVlZDogZmFsc2UsXG4gICAgICAgIG5hdkVsZW1lbnQ6IFwiZGl2XCIsXG4gICAgICAgIG5hdkNvbnRhaW5lcjogZmFsc2UsXG4gICAgICAgIG5hdkNvbnRhaW5lckNsYXNzOiBcIm93bC1uYXZcIixcbiAgICAgICAgbmF2Q2xhc3M6IFsgXCJvd2wtcHJldlwiLCBcIm93bC1uZXh0XCIgXSxcbiAgICAgICAgc2xpZGVCeTogMSxcbiAgICAgICAgZG90Q2xhc3M6IFwib3dsLWRvdFwiLFxuICAgICAgICBkb3RzQ2xhc3M6IFwib3dsLWRvdHNcIixcbiAgICAgICAgZG90czogdHJ1ZSxcbiAgICAgICAgZG90c0VhY2g6IGZhbHNlLFxuICAgICAgICBkb3RzRGF0YTogZmFsc2UsXG4gICAgICAgIGRvdHNTcGVlZDogZmFsc2UsXG4gICAgICAgIGRvdHNDb250YWluZXI6IGZhbHNlXG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgbGF5b3V0IG9mIHRoZSBwbHVnaW4gYW5kIGV4dGVuZHMgdGhlIGNhcm91c2VsLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICAgIE5hdmlnYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG92ZXJyaWRlLCBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XG5cbiAgICAgICAgLy8gY3JlYXRlIERPTSBzdHJ1Y3R1cmUgZm9yIHJlbGF0aXZlIG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5fY29udHJvbHMuJHJlbGF0aXZlID0gKHNldHRpbmdzLm5hdkNvbnRhaW5lclxuICAgICAgICAgICAgPyAkKHNldHRpbmdzLm5hdkNvbnRhaW5lcilcbiAgICAgICAgICAgIDogJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHNldHRpbmdzLm5hdkNvbnRhaW5lckNsYXNzKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLiRlbGVtZW50KSkuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcblxuICAgICAgICB0aGlzLl9jb250cm9scy4kcHJldmlvdXMgPSAkKFwiPFwiICsgc2V0dGluZ3MubmF2RWxlbWVudCArIFwiPlwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzBdKVxuICAgICAgICAgICAgLmh0bWwoc2V0dGluZ3MubmF2VGV4dFswXSlcbiAgICAgICAgICAgIC5wcmVwZW5kVG8odGhpcy5fY29udHJvbHMuJHJlbGF0aXZlKVxuICAgICAgICAgICAgLm9uKFxuICAgICAgICAgICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXYoc2V0dGluZ3MubmF2U3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fY29udHJvbHMuJG5leHQgPSAkKFwiPFwiICsgc2V0dGluZ3MubmF2RWxlbWVudCArIFwiPlwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzFdKVxuICAgICAgICAgICAgLmh0bWwoc2V0dGluZ3MubmF2VGV4dFsxXSlcbiAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLl9jb250cm9scy4kcmVsYXRpdmUpXG4gICAgICAgICAgICAub24oXG4gICAgICAgICAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dChzZXR0aW5ncy5uYXZTcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBET00gc3RydWN0dXJlIGZvciBhYnNvbHV0ZSBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICghc2V0dGluZ3MuZG90c0RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlcyA9IFtcbiAgICAgICAgICAgICAgICAkKFwiPGRpdj5cIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHNldHRpbmdzLmRvdENsYXNzKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8c3Bhbj5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5wcm9wKFwib3V0ZXJIVE1MXCIpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29udHJvbHMuJGFic29sdXRlID0gKHNldHRpbmdzLmRvdHNDb250YWluZXJcbiAgICAgICAgICAgID8gJChzZXR0aW5ncy5kb3RzQ29udGFpbmVyKVxuICAgICAgICAgICAgOiAkKFwiPGRpdj5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3Moc2V0dGluZ3MuZG90c0NsYXNzKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLiRlbGVtZW50KSkuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcblxuICAgICAgICB0aGlzLl9jb250cm9scy4kYWJzb2x1dGUub24oXG4gICAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9ICQoZS50YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pcyh0aGlzLl9jb250cm9scy4kYWJzb2x1dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICQoZS50YXJnZXQpLmluZGV4KClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJChlLnRhcmdldCkucGFyZW50KCkuaW5kZXgoKTtcblxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byhpbmRleCwgc2V0dGluZ3MuZG90c1NwZWVkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBvdmVycmlkZSBwdWJsaWMgbWV0aG9kcyBvZiB0aGUgY2Fyb3VzZWxcbiAgICAgICAgZm9yIChvdmVycmlkZSBpbiB0aGlzLl9vdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcmVbb3ZlcnJpZGVdID0gJC5wcm94eSh0aGlzW292ZXJyaWRlXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFuZGxlciwgY29udHJvbCwgcHJvcGVydHksIG92ZXJyaWRlO1xuXG4gICAgICAgIGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29udHJvbCBpbiB0aGlzLl9jb250cm9scykge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbHNbY29udHJvbF0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChvdmVycmlkZSBpbiB0aGlzLm92ZXJpZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3JlW292ZXJyaWRlXSA9IHRoaXMuX292ZXJyaWRlc1tvdmVycmlkZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgICAgICAgICAgdHlwZW9mIHRoaXNbcHJvcGVydHldICE9IFwiZnVuY3Rpb25cIiAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcblx0ICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgc3RhdGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBsb3dlciA9IHRoaXMuX2NvcmUuY2xvbmVzKCkubGVuZ3RoIC8gMixcbiAgICAgICAgICAgIHVwcGVyID0gbG93ZXIgKyB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoLFxuICAgICAgICAgICAgbWF4aW11bSA9IHRoaXMuX2NvcmUubWF4aW11bSh0cnVlKSxcbiAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcbiAgICAgICAgICAgIHNpemUgPSBzZXR0aW5ncy5jZW50ZXIgfHwgc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLmRvdHNEYXRhXG4gICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgOiBzZXR0aW5ncy5kb3RzRWFjaCB8fCBzZXR0aW5ncy5pdGVtcztcblxuICAgICAgICBpZiAoc2V0dGluZ3Muc2xpZGVCeSAhPT0gXCJwYWdlXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNsaWRlQnkgPSBNYXRoLm1pbihzZXR0aW5ncy5zbGlkZUJ5LCBzZXR0aW5ncy5pdGVtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuZG90cyB8fCBzZXR0aW5ncy5zbGlkZUJ5ID09IFwicGFnZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWdlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBsb3dlciwgaiA9IDAsIGsgPSAwOyBpIDwgdXBwZXI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChqID49IHNpemUgfHwgaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBNYXRoLm1pbihtYXhpbXVtLCBpIC0gbG93ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpIC0gbG93ZXIgKyBzaXplIC0gMVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKG1heGltdW0sIGkgLSBsb3dlcikgPT09IG1heGltdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGogPSAwLCArK2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGogKz0gdGhpcy5fY29yZS5tZXJnZXJzKHRoaXMuX2NvcmUucmVsYXRpdmUoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBEcmF3cyB0aGUgdXNlciBpbnRlcmZhY2UuXG5cdCAqIEB0b2RvIFRoZSBvcHRpb24gYGRvdHNEYXRhYCB3b250IHdvcmsuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSxcbiAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcbiAgICAgICAgICAgIGRpc2FibGVkID0gdGhpcy5fY29yZS5pdGVtcygpLmxlbmd0aCA8PSBzZXR0aW5ncy5pdGVtcyxcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSksXG4gICAgICAgICAgICBsb29wID0gc2V0dGluZ3MubG9vcCB8fCBzZXR0aW5ncy5yZXdpbmQ7XG5cbiAgICAgICAgdGhpcy5fY29udHJvbHMuJHJlbGF0aXZlLnRvZ2dsZUNsYXNzKFxuICAgICAgICAgICAgXCJkaXNhYmxlZFwiLFxuICAgICAgICAgICAgIXNldHRpbmdzLm5hdiB8fCBkaXNhYmxlZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5uYXYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xzLiRwcmV2aW91cy50b2dnbGVDbGFzcyhcbiAgICAgICAgICAgICAgICBcImRpc2FibGVkXCIsXG4gICAgICAgICAgICAgICAgIWxvb3AgJiYgaW5kZXggPD0gdGhpcy5fY29yZS5taW5pbXVtKHRydWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbHMuJG5leHQudG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICAgICAgXCJkaXNhYmxlZFwiLFxuICAgICAgICAgICAgICAgICFsb29wICYmIGluZGV4ID49IHRoaXMuX2NvcmUubWF4aW11bSh0cnVlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS50b2dnbGVDbGFzcyhcbiAgICAgICAgICAgIFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICFzZXR0aW5ncy5kb3RzIHx8IGRpc2FibGVkXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRvdHMpIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSB0aGlzLl9wYWdlcy5sZW5ndGggLVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5jaGlsZHJlbigpLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRvdHNEYXRhICYmIGRpZmZlcmVuY2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuaHRtbCh0aGlzLl90ZW1wbGF0ZXMuam9pbihcIlwiKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbHMuJGFic29sdXRlLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgbmV3IEFycmF5KGRpZmZlcmVuY2UgKyAxKS5qb2luKHRoaXMuX3RlbXBsYXRlc1swXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5jaGlsZHJlbigpLnNsaWNlKGRpZmZlcmVuY2UpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuZmluZChcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9scy4kYWJzb2x1dGVcbiAgICAgICAgICAgICAgICAuY2hpbGRyZW4oKVxuICAgICAgICAgICAgICAgIC5lcSgkLmluQXJyYXkodGhpcy5jdXJyZW50KCksIHRoaXMuX3BhZ2VzKSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIEV4dGVuZHMgZXZlbnQgZGF0YS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3Qgd2hpY2ggZ2V0cyB0aHJvd24uXG5cdCAqL1xuICAgIE5hdmlnYXRpb24ucHJvdG90eXBlLm9uVHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XG5cbiAgICAgICAgZXZlbnQucGFnZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAkLmluQXJyYXkodGhpcy5jdXJyZW50KCksIHRoaXMuX3BhZ2VzKSxcbiAgICAgICAgICAgIGNvdW50OiB0aGlzLl9wYWdlcy5sZW5ndGgsXG4gICAgICAgICAgICBzaXplOiBzZXR0aW5ncyAmJlxuICAgICAgICAgICAgICAgIChzZXR0aW5ncy5jZW50ZXIgfHwgc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLmRvdHNEYXRhXG4gICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICA6IHNldHRpbmdzLmRvdHNFYWNoIHx8IHNldHRpbmdzLml0ZW1zKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcblx0ICogR2V0cyB0aGUgY3VycmVudCBwYWdlIHBvc2l0aW9uIG9mIHRoZSBjYXJvdXNlbC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cbiAgICBOYXZpZ2F0aW9uLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSk7XG4gICAgICAgIHJldHVybiAkLmdyZXAoXG4gICAgICAgICAgICB0aGlzLl9wYWdlcyxcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocGFnZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2Uuc3RhcnQgPD0gY3VycmVudCAmJiBwYWdlLmVuZCA+PSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKVxuICAgICAgICApLnBvcCgpO1xuICAgIH07XG5cbiAgICAvKipcblx0ICogR2V0cyB0aGUgY3VycmVudCBzdWNjZXNvci9wcmVkZWNlc3NvciBwb3NpdGlvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cbiAgICBOYXZpZ2F0aW9uLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHN1Y2Nlc3Nvcikge1xuICAgICAgICB2YXIgcG9zaXRpb24sIGxlbmd0aCwgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5zbGlkZUJ5ID09IFwicGFnZVwiKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9ICQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpO1xuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fcGFnZXMubGVuZ3RoO1xuICAgICAgICAgICAgc3VjY2Vzc29yID8gKytwb3NpdGlvbiA6IC0tcG9zaXRpb247XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX3BhZ2VzWyhwb3NpdGlvbiAlIGxlbmd0aCArIGxlbmd0aCkgJSBsZW5ndGhdLnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGg7XG4gICAgICAgICAgICBzdWNjZXNzb3JcbiAgICAgICAgICAgICAgICA/IHBvc2l0aW9uICs9IHNldHRpbmdzLnNsaWRlQnlcbiAgICAgICAgICAgICAgICA6IHBvc2l0aW9uIC09IHNldHRpbmdzLnNsaWRlQnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBTbGlkZXMgdG8gdGhlIG5leHQgaXRlbSBvciBwYWdlLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWQ9ZmFsc2VdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cblx0ICovXG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG4gICAgICAgICQucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLCB0aGlzLl9jb3JlKSh0aGlzLmdldFBvc2l0aW9uKHRydWUpLCBzcGVlZCk7XG4gICAgfTtcblxuICAgIC8qKlxuXHQgKiBTbGlkZXMgdG8gdGhlIHByZXZpb3VzIGl0ZW0gb3IgcGFnZS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXG5cdCAqL1xuICAgIE5hdmlnYXRpb24ucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbihzcGVlZCkge1xuICAgICAgICAkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkodGhpcy5nZXRQb3NpdGlvbihmYWxzZSksIHNwZWVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0gb3IgcGFnZS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gb3IgcGFnZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGFuZGFyZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgYmVoYXZpb3VyIG9yIG5vdC5cblx0ICovXG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihwb3NpdGlvbiwgc3BlZWQsIHN0YW5kYXJkKSB7XG4gICAgICAgIHZhciBsZW5ndGg7XG5cbiAgICAgICAgaWYgKCFzdGFuZGFyZCAmJiB0aGlzLl9wYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3BhZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgICQucHJveHkoXG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJpZGVzLnRvLFxuICAgICAgICAgICAgICAgIHRoaXMuX2NvcmVcbiAgICAgICAgICAgICkodGhpcy5fcGFnZXNbKHBvc2l0aW9uICUgbGVuZ3RoICsgbGVuZ3RoKSAlIGxlbmd0aF0uc3RhcnQsIHNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLCB0aGlzLl9jb3JlKShwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBoYXNoIHBsdWdpbi5cblx0ICogQGNsYXNzIFRoZSBIYXNoIFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuICAgIHZhciBIYXNoID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcbiAgICAgICAgLyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T3dsfVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cbiAgICAgICAgLyoqXG5cdFx0ICogSGFzaCBpbmRleCBmb3IgdGhlIGl0ZW1zLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLl9oYXNoZXMgPSB7fTtcblxuICAgICAgICAvKipcblx0XHQgKiBUaGUgY2Fyb3VzZWwgZWxlbWVudC5cblx0XHQgKiBAdHlwZSB7alF1ZXJ5fVxuXHRcdCAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gdGhpcy5fY29yZS4kZWxlbWVudDtcblxuICAgICAgICAvKipcblx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge1xuICAgICAgICAgICAgXCJpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWxcIjogJC5wcm94eShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubmFtZXNwYWNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS5zZXR0aW5ncy5zdGFydFBvc2l0aW9uID09PSBcIlVSTEhhc2hcIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQod2luZG93KS50cmlnZ2VyKFwiaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwicHJlcGFyZWQub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gJChlLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoXCJbZGF0YS1oYXNoXVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRCYWNrKFwiW2RhdGEtaGFzaF1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtaGFzaFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNoZXNbaGFzaF0gPSBlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcImNoYW5nZWQub3dsLmNhcm91c2VsXCI6ICQucHJveHkoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSBcInBvc2l0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY29yZS5pdGVtcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gJC5tYXAodGhpcy5faGFzaGVzLCBmdW5jdGlvbihpdGVtLCBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID09PSBjdXJyZW50ID8gaGFzaCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc2ggfHwgd2luZG93LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkgPT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEhhc2guRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyIGZvciBoYXNoIG5hdmlnYXRpb25cbiAgICAgICAgJCh3aW5kb3cpLm9uKFxuICAgICAgICAgICAgXCJoYXNoY2hhbmdlLm93bC5uYXZpZ2F0aW9uXCIsXG4gICAgICAgICAgICAkLnByb3h5KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IHRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2hhc2hlc1toYXNoXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLmluZGV4KHRoaXMuX2hhc2hlc1toYXNoXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID09PSB0aGlzLl9jb3JlLmN1cnJlbnQoKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUudG8odGhpcy5fY29yZS5yZWxhdGl2ZShwb3NpdGlvbiksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG5cdCAqIERlZmF1bHQgb3B0aW9ucy5cblx0ICogQHB1YmxpY1xuXHQgKi9cbiAgICBIYXNoLkRlZmF1bHRzID0geyBVUkxoYXNoTGlzdGVuZXI6IGZhbHNlIH07XG5cbiAgICAvKipcblx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cblx0ICogQHB1YmxpY1xuXHQgKi9cbiAgICBIYXNoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuICAgICAgICAkKHdpbmRvdykub2ZmKFwiaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvblwiKTtcblxuICAgICAgICBmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgICAgICAgICB0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gXCJmdW5jdGlvblwiICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5IYXNoID0gSGFzaDtcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIHZhciBzdHlsZSA9ICQoXCI8c3VwcG9ydD5cIikuZ2V0KDApLnN0eWxlLFxuICAgICAgICBwcmVmaXhlcyA9IFwiV2Via2l0IE1veiBPIG1zXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgICBldmVudHMgPSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zaXRpb246IFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLFxuICAgICAgICAgICAgICAgICAgICBNb3pUcmFuc2l0aW9uOiBcInRyYW5zaXRpb25lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgT1RyYW5zaXRpb246IFwib1RyYW5zaXRpb25FbmRcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogXCJ0cmFuc2l0aW9uZW5kXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIFdlYmtpdEFuaW1hdGlvbjogXCJ3ZWJraXRBbmltYXRpb25FbmRcIixcbiAgICAgICAgICAgICAgICAgICAgTW96QW5pbWF0aW9uOiBcImFuaW1hdGlvbmVuZFwiLFxuICAgICAgICAgICAgICAgICAgICBPQW5pbWF0aW9uOiBcIm9BbmltYXRpb25FbmRcIixcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBcImFuaW1hdGlvbmVuZFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZXN0cyA9IHtcbiAgICAgICAgICAgIGNzc3RyYW5zZm9ybXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRlc3QoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3NzdHJhbnNmb3JtczNkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0ZXN0KFwicGVyc3BlY3RpdmVcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3NzdHJhbnNpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRlc3QoXCJ0cmFuc2l0aW9uXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNzc2FuaW1hdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRlc3QoXCJhbmltYXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICBmdW5jdGlvbiB0ZXN0KHByb3BlcnR5LCBwcmVmaXhlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2UsXG4gICAgICAgICAgICB1cHBlciA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgKHByb3BlcnR5ICsgXCIgXCIgKyBwcmVmaXhlcy5qb2luKHVwcGVyICsgXCIgXCIpICsgdXBwZXIpLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGksIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZWZpeGVkID8gcHJvcGVydHkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlZml4ZWQocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRlc3QocHJvcGVydHksIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0ZXN0cy5jc3N0cmFuc2l0aW9ucygpKSB7XG4gICAgICAgIC8qIGpzaGludCAtVzA1MyAqL1xuICAgICAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IG5ldyBTdHJpbmcocHJlZml4ZWQoXCJ0cmFuc2l0aW9uXCIpKTtcbiAgICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kID0gZXZlbnRzLnRyYW5zaXRpb24uZW5kWyQuc3VwcG9ydC50cmFuc2l0aW9uXTtcbiAgICB9XG5cbiAgICBpZiAodGVzdHMuY3NzYW5pbWF0aW9ucygpKSB7XG4gICAgICAgIC8qIGpzaGludCAtVzA1MyAqL1xuICAgICAgICAkLnN1cHBvcnQuYW5pbWF0aW9uID0gbmV3IFN0cmluZyhwcmVmaXhlZChcImFuaW1hdGlvblwiKSk7XG4gICAgICAgICQuc3VwcG9ydC5hbmltYXRpb24uZW5kID0gZXZlbnRzLmFuaW1hdGlvbi5lbmRbJC5zdXBwb3J0LmFuaW1hdGlvbl07XG4gICAgfVxuXG4gICAgaWYgKHRlc3RzLmNzc3RyYW5zZm9ybXMoKSkge1xuICAgICAgICAvKiBqc2hpbnQgLVcwNTMgKi9cbiAgICAgICAgJC5zdXBwb3J0LnRyYW5zZm9ybSA9IG5ldyBTdHJpbmcocHJlZml4ZWQoXCJ0cmFuc2Zvcm1cIikpO1xuICAgICAgICAkLnN1cHBvcnQudHJhbnNmb3JtM2QgPSB0ZXN0cy5jc3N0cmFuc2Zvcm1zM2QoKTtcbiAgICB9XG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBDOi9Vc2Vycy9EYW5nby9sZWFybi9vYm9sb24vfi9vd2wuY2Fyb3VzZWwvZGlzdC9vd2wuY2Fyb3VzZWwuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery Validation Plugin - v1.16.0 - 12/2/2016\n * http://jqueryvalidation.org/\n * Copyright (c) 2016 Jrn Zaefferer; Licensed MIT */\n!function (a) {\n     true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (a), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = a(require(\"jquery\")) : a(jQuery);\n}(function (a) {\n    a.extend(a.fn, {\n        validate: function validate(b) {\n            if (!this.length) return void (b && b.debug && window.console && console.warn(\"Nothing selected, can't validate, returning nothing.\"));\n            var c = a.data(this[0], \"validator\");\n            return c ? c : (this.attr(\"novalidate\", \"novalidate\"), c = new a.validator(b, this[0]), a.data(this[0], \"validator\", c), c.settings.onsubmit && (this.on(\"click.validate\", \":submit\", function (b) {\n                c.settings.submitHandler && (c.submitButton = b.target), a(this).hasClass(\"cancel\") && (c.cancelSubmit = !0), void 0 !== a(this).attr(\"formnovalidate\") && (c.cancelSubmit = !0);\n            }), this.on(\"submit.validate\", function (b) {\n                function d() {\n                    var d, e;\n                    return !c.settings.submitHandler || (c.submitButton && (d = a(\"<input type='hidden'/>\").attr(\"name\", c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)), e = c.settings.submitHandler.call(c, c.currentForm, b), c.submitButton && d.remove(), void 0 !== e && e);\n                }\n                return c.settings.debug && b.preventDefault(), c.cancelSubmit ? (c.cancelSubmit = !1, d()) : c.form() ? c.pendingRequest ? (c.formSubmitted = !0, !1) : d() : (c.focusInvalid(), !1);\n            })), c);\n        },\n        valid: function valid() {\n            var b, c, d;\n            return a(this[0]).is(\"form\") ? b = this.validate().form() : (d = [], b = !0, c = a(this[0].form).validate(), this.each(function () {\n                b = c.element(this) && b, b || (d = d.concat(c.errorList));\n            }), c.errorList = d), b;\n        },\n        rules: function rules(b, c) {\n            var d,\n                e,\n                f,\n                g,\n                h,\n                i,\n                j = this[0];\n            if (null != j && null != j.form) {\n                if (b) switch (d = a.data(j.form, \"validator\").settings, e = d.rules, f = a.validator.staticRules(j), b) {\n                    case \"add\":\n                        a.extend(f, a.validator.normalizeRule(c)), delete f.messages, e[j.name] = f, c.messages && (d.messages[j.name] = a.extend(d.messages[j.name], c.messages));\n                        break;\n                    case \"remove\":\n                        return c ? (i = {}, a.each(c.split(/\\s/), function (b, c) {\n                            i[c] = f[c], delete f[c], \"required\" === c && a(j).removeAttr(\"aria-required\");\n                        }), i) : (delete e[j.name], f);\n                }\n                return g = a.validator.normalizeRules(a.extend({}, a.validator.classRules(j), a.validator.attributeRules(j), a.validator.dataRules(j), a.validator.staticRules(j)), j), g.required && (h = g.required, delete g.required, g = a.extend({ required: h }, g), a(j).attr(\"aria-required\", \"true\")), g.remote && (h = g.remote, delete g.remote, g = a.extend(g, { remote: h })), g;\n            }\n        }\n    }), a.extend(a.expr.pseudos || a.expr[\":\"], {\n        blank: function blank(b) {\n            return !a.trim(\"\" + a(b).val());\n        },\n        filled: function filled(b) {\n            var c = a(b).val();\n            return null !== c && !!a.trim(\"\" + c);\n        },\n        unchecked: function unchecked(b) {\n            return !a(b).prop(\"checked\");\n        }\n    }), a.validator = function (b, c) {\n        this.settings = a.extend(!0, {}, a.validator.defaults, b), this.currentForm = c, this.init();\n    }, a.validator.format = function (b, c) {\n        return 1 === arguments.length ? function () {\n            var c = a.makeArray(arguments);\n            return c.unshift(b), a.validator.format.apply(this, c);\n        } : void 0 === c ? b : (arguments.length > 2 && c.constructor !== Array && (c = a.makeArray(arguments).slice(1)), c.constructor !== Array && (c = [c]), a.each(c, function (a, c) {\n            b = b.replace(new RegExp(\"\\\\{\" + a + \"\\\\}\", \"g\"), function () {\n                return c;\n            });\n        }), b);\n    }, a.extend(a.validator, {\n        defaults: {\n            messages: {},\n            groups: {},\n            rules: {},\n            errorClass: \"error\",\n            pendingClass: \"pending\",\n            validClass: \"valid\",\n            errorElement: \"label\",\n            focusCleanup: !1,\n            focusInvalid: !0,\n            errorContainer: a([]),\n            errorLabelContainer: a([]),\n            onsubmit: !0,\n            ignore: \":hidden\",\n            ignoreTitle: !1,\n            onfocusin: function onfocusin(a) {\n                this.lastActive = a, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, a, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(a)));\n            },\n            onfocusout: function onfocusout(a) {\n                this.checkable(a) || !(a.name in this.submitted) && this.optional(a) || this.element(a);\n            },\n            onkeyup: function onkeyup(b, c) {\n                var d = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];\n                9 === c.which && \"\" === this.elementValue(b) || a.inArray(c.keyCode, d) !== -1 || (b.name in this.submitted || b.name in this.invalid) && this.element(b);\n            },\n            onclick: function onclick(a) {\n                a.name in this.submitted ? this.element(a) : a.parentNode.name in this.submitted && this.element(a.parentNode);\n            },\n            highlight: function highlight(b, c, d) {\n                \"radio\" === b.type ? this.findByName(b.name).addClass(c).removeClass(d) : a(b).addClass(c).removeClass(d);\n            },\n            unhighlight: function unhighlight(b, c, d) {\n                \"radio\" === b.type ? this.findByName(b.name).removeClass(c).addClass(d) : a(b).removeClass(c).addClass(d);\n            }\n        },\n        setDefaults: function setDefaults(b) {\n            a.extend(a.validator.defaults, b);\n        },\n        messages: {\n            required: \"This field is required.\",\n            remote: \"Please fix this field.\",\n            email: \"Please enter a valid email address.\",\n            url: \"Please enter a valid URL.\",\n            date: \"Please enter a valid date.\",\n            dateISO: \"Please enter a valid date (ISO).\",\n            number: \"Please enter a valid number.\",\n            digits: \"Please enter only digits.\",\n            equalTo: \"Please enter the same value again.\",\n            maxlength: a.validator.format(\"Please enter no more than {0} characters.\"),\n            minlength: a.validator.format(\"Please enter at least {0} characters.\"),\n            rangelength: a.validator.format(\"Please enter a value between {0} and {1} characters long.\"),\n            range: a.validator.format(\"Please enter a value between {0} and {1}.\"),\n            max: a.validator.format(\"Please enter a value less than or equal to {0}.\"),\n            min: a.validator.format(\"Please enter a value greater than or equal to {0}.\"),\n            step: a.validator.format(\"Please enter a multiple of {0}.\")\n        },\n        autoCreateRanges: !1,\n        prototype: {\n            init: function init() {\n                function b(b) {\n                    !this.form && this.hasAttribute(\"contenteditable\") && (this.form = a(this).closest(\"form\")[0]);\n                    var c = a.data(this.form, \"validator\"),\n                        d = \"on\" + b.type.replace(/^validate/, \"\"),\n                        e = c.settings;\n                    e[d] && !a(this).is(e.ignore) && e[d].call(c, this, b);\n                }\n                this.labelContainer = a(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || a(this.currentForm), this.containers = a(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset();\n                var c,\n                    d = this.groups = {};\n                a.each(this.settings.groups, function (b, c) {\n                    \"string\" == typeof c && (c = c.split(/\\s/)), a.each(c, function (a, c) {\n                        d[c] = b;\n                    });\n                }), c = this.settings.rules, a.each(c, function (b, d) {\n                    c[b] = a.validator.normalizeRule(d);\n                }), a(this.currentForm).on(\"focusin.validate focusout.validate keyup.validate\", \":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']\", b).on(\"click.validate\", \"select, option, [type='radio'], [type='checkbox']\", b), this.settings.invalidHandler && a(this.currentForm).on(\"invalid-form.validate\", this.settings.invalidHandler), a(this.currentForm).find(\"[required], [data-rule-required], .required\").attr(\"aria-required\", \"true\");\n            },\n            form: function form() {\n                return this.checkForm(), a.extend(this.submitted, this.errorMap), this.invalid = a.extend({}, this.errorMap), this.valid() || a(this.currentForm).triggerHandler(\"invalid-form\", [this]), this.showErrors(), this.valid();\n            },\n            checkForm: function checkForm() {\n                this.prepareForm();\n                for (var a = 0, b = this.currentElements = this.elements(); b[a]; a++) {\n                    this.check(b[a]);\n                }return this.valid();\n            },\n            element: function element(b) {\n                var c,\n                    d,\n                    e = this.clean(b),\n                    f = this.validationTargetFor(e),\n                    g = this,\n                    h = !0;\n                return void 0 === f ? delete this.invalid[e.name] : (this.prepareElement(f), this.currentElements = a(f), d = this.groups[f.name], d && a.each(this.groups, function (a, b) {\n                    b === d && a !== f.name && (e = g.validationTargetFor(g.clean(g.findByName(a))), e && e.name in g.invalid && (g.currentElements.push(e), h = g.check(e) && h));\n                }), c = this.check(f) !== !1, h = h && c, c ? this.invalid[f.name] = !1 : this.invalid[f.name] = !0, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), a(b).attr(\"aria-invalid\", !c)), h;\n            },\n            showErrors: function showErrors(b) {\n                if (b) {\n                    var c = this;\n                    a.extend(this.errorMap, b), this.errorList = a.map(this.errorMap, function (a, b) {\n                        return { message: a, element: c.findByName(b)[0] };\n                    }), this.successList = a.grep(this.successList, function (a) {\n                        return !(a.name in b);\n                    });\n                }\n                this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors();\n            },\n            resetForm: function resetForm() {\n                a.fn.resetForm && a(this.currentForm).resetForm(), this.invalid = {}, this.submitted = {}, this.prepareForm(), this.hideErrors();\n                var b = this.elements().removeData(\"previousValue\").removeAttr(\"aria-invalid\");\n                this.resetElements(b);\n            },\n            resetElements: function resetElements(a) {\n                var b;\n                if (this.settings.unhighlight) for (b = 0; a[b]; b++) {\n                    this.settings.unhighlight.call(this, a[b], this.settings.errorClass, \"\"), this.findByName(a[b].name).removeClass(this.settings.validClass);\n                } else a.removeClass(this.settings.errorClass).removeClass(this.settings.validClass);\n            },\n            numberOfInvalids: function numberOfInvalids() {\n                return this.objectLength(this.invalid);\n            },\n            objectLength: function objectLength(a) {\n                var b,\n                    c = 0;\n                for (b in a) {\n                    a[b] && c++;\n                }return c;\n            },\n            hideErrors: function hideErrors() {\n                this.hideThese(this.toHide);\n            },\n            hideThese: function hideThese(a) {\n                a.not(this.containers).text(\"\"), this.addWrapper(a).hide();\n            },\n            valid: function valid() {\n                return 0 === this.size();\n            },\n            size: function size() {\n                return this.errorList.length;\n            },\n            focusInvalid: function focusInvalid() {\n                if (this.settings.focusInvalid) try {\n                    a(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(\":visible\").focus().trigger(\"focusin\");\n                } catch (b) {}\n            },\n            findLastActive: function findLastActive() {\n                var b = this.lastActive;\n                return b && 1 === a.grep(this.errorList, function (a) {\n                    return a.element.name === b.name;\n                }).length && b;\n            },\n            elements: function elements() {\n                var b = this,\n                    c = {};\n                return a(this.currentForm).find(\"input, select, textarea, [contenteditable]\").not(\":submit, :reset, :image, :disabled\").not(this.settings.ignore).filter(function () {\n                    var d = this.name || a(this).attr(\"name\");\n                    return !d && b.settings.debug && window.console && console.error(\"%o has no name assigned\", this), this.hasAttribute(\"contenteditable\") && (this.form = a(this).closest(\"form\")[0]), !(d in c || !b.objectLength(a(this).rules())) && (c[d] = !0, !0);\n                });\n            },\n            clean: function clean(b) {\n                return a(b)[0];\n            },\n            errors: function errors() {\n                var b = this.settings.errorClass.split(\" \").join(\".\");\n                return a(this.settings.errorElement + \".\" + b, this.errorContext);\n            },\n            resetInternals: function resetInternals() {\n                this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = a([]), this.toHide = a([]);\n            },\n            reset: function reset() {\n                this.resetInternals(), this.currentElements = a([]);\n            },\n            prepareForm: function prepareForm() {\n                this.reset(), this.toHide = this.errors().add(this.containers);\n            },\n            prepareElement: function prepareElement(a) {\n                this.reset(), this.toHide = this.errorsFor(a);\n            },\n            elementValue: function elementValue(b) {\n                var c,\n                    d,\n                    e = a(b),\n                    f = b.type;\n                return \"radio\" === f || \"checkbox\" === f ? this.findByName(b.name).filter(\":checked\").val() : \"number\" === f && \"undefined\" != typeof b.validity ? b.validity.badInput ? \"NaN\" : e.val() : (c = b.hasAttribute(\"contenteditable\") ? e.text() : e.val(), \"file\" === f ? \"C:\\\\fakepath\\\\\" === c.substr(0, 12) ? c.substr(12) : (d = c.lastIndexOf(\"/\"), d >= 0 ? c.substr(d + 1) : (d = c.lastIndexOf(\"\\\\\"), d >= 0 ? c.substr(d + 1) : c)) : \"string\" == typeof c ? c.replace(/\\r/g, \"\") : c);\n            },\n            check: function check(b) {\n                b = this.validationTargetFor(this.clean(b));\n                var c,\n                    d,\n                    e,\n                    f = a(b).rules(),\n                    g = a.map(f, function (a, b) {\n                    return b;\n                }).length,\n                    h = !1,\n                    i = this.elementValue(b);\n                if (\"function\" == typeof f.normalizer) {\n                    if (i = f.normalizer.call(b, i), \"string\" != typeof i) throw new TypeError(\"The normalizer should return a string value.\");\n                    delete f.normalizer;\n                }\n                for (d in f) {\n                    e = { method: d, parameters: f[d] };\n                    try {\n                        if (c = a.validator.methods[d].call(this, i, b, e.parameters), \"dependency-mismatch\" === c && 1 === g) {\n                            h = !0;\n                            continue;\n                        }\n                        if (h = !1, \"pending\" === c) return void (this.toHide = this.toHide.not(this.errorsFor(b)));\n                        if (!c) return this.formatAndAdd(b, e), !1;\n                    } catch (j) {\n                        throw this.settings.debug && window.console && console.log(\"Exception occurred when checking element \" + b.id + \", check the '\" + e.method + \"' method.\", j), j instanceof TypeError && (j.message += \".  Exception occurred when checking element \" + b.id + \", check the '\" + e.method + \"' method.\"), j;\n                    }\n                }\n                if (!h) return this.objectLength(f) && this.successList.push(b), !0;\n            },\n            customDataMessage: function customDataMessage(b, c) {\n                return a(b).data(\"msg\" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()) || a(b).data(\"msg\");\n            },\n            customMessage: function customMessage(a, b) {\n                var c = this.settings.messages[a];\n                return c && (c.constructor === String ? c : c[b]);\n            },\n            findDefined: function findDefined() {\n                for (var a = 0; a < arguments.length; a++) {\n                    if (void 0 !== arguments[a]) return arguments[a];\n                }\n            },\n            defaultMessage: function defaultMessage(b, c) {\n                \"string\" == typeof c && (c = { method: c });\n                var d = this.findDefined(this.customMessage(b.name, c.method), this.customDataMessage(b, c.method), !this.settings.ignoreTitle && b.title || void 0, a.validator.messages[c.method], \"<strong>Warning: No message defined for \" + b.name + \"</strong>\"),\n                    e = /\\$?\\{(\\d+)\\}/g;\n                return \"function\" == typeof d ? d = d.call(this, c.parameters, b) : e.test(d) && (d = a.validator.format(d.replace(e, \"{$1}\"), c.parameters)), d;\n            },\n            formatAndAdd: function formatAndAdd(a, b) {\n                var c = this.defaultMessage(a, b);\n                this.errorList.push({\n                    message: c,\n                    element: a,\n                    method: b.method\n                }), this.errorMap[a.name] = c, this.submitted[a.name] = c;\n            },\n            addWrapper: function addWrapper(a) {\n                return this.settings.wrapper && (a = a.add(a.parent(this.settings.wrapper))), a;\n            },\n            defaultShowErrors: function defaultShowErrors() {\n                var a, b, c;\n                for (a = 0; this.errorList[a]; a++) {\n                    c = this.errorList[a], this.settings.highlight && this.settings.highlight.call(this, c.element, this.settings.errorClass, this.settings.validClass), this.showLabel(c.element, c.message);\n                }if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) for (a = 0; this.successList[a]; a++) {\n                    this.showLabel(this.successList[a]);\n                }if (this.settings.unhighlight) for (a = 0, b = this.validElements(); b[a]; a++) {\n                    this.settings.unhighlight.call(this, b[a], this.settings.errorClass, this.settings.validClass);\n                }this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show();\n            },\n            validElements: function validElements() {\n                return this.currentElements.not(this.invalidElements());\n            },\n            invalidElements: function invalidElements() {\n                return a(this.errorList).map(function () {\n                    return this.element;\n                });\n            },\n            showLabel: function showLabel(b, c) {\n                var d,\n                    e,\n                    f,\n                    g,\n                    h = this.errorsFor(b),\n                    i = this.idOrName(b),\n                    j = a(b).attr(\"aria-describedby\");\n                h.length ? (h.removeClass(this.settings.validClass).addClass(this.settings.errorClass), h.html(c)) : (h = a(\"<\" + this.settings.errorElement + \">\").attr(\"id\", i + \"-error\").addClass(this.settings.errorClass).html(c || \"\"), d = h, this.settings.wrapper && (d = h.hide().show().wrap(\"<\" + this.settings.wrapper + \"/>\").parent()), this.labelContainer.length ? this.labelContainer.append(d) : this.settings.errorPlacement ? this.settings.errorPlacement.call(this, d, a(b)) : d.insertAfter(b), h.is(\"label\") ? h.attr(\"for\", i) : 0 === h.parents(\"label[for='\" + this.escapeCssMeta(i) + \"']\").length && (f = h.attr(\"id\"), j ? j.match(new RegExp(\"\\\\b\" + this.escapeCssMeta(f) + \"\\\\b\")) || (j += \" \" + f) : j = f, a(b).attr(\"aria-describedby\", j), e = this.groups[b.name], e && (g = this, a.each(g.groups, function (b, c) {\n                    c === e && a(\"[name='\" + g.escapeCssMeta(b) + \"']\", g.currentForm).attr(\"aria-describedby\", h.attr(\"id\"));\n                })))), !c && this.settings.success && (h.text(\"\"), \"string\" == typeof this.settings.success ? h.addClass(this.settings.success) : this.settings.success(h, b)), this.toShow = this.toShow.add(h);\n            },\n            errorsFor: function errorsFor(b) {\n                var c = this.escapeCssMeta(this.idOrName(b)),\n                    d = a(b).attr(\"aria-describedby\"),\n                    e = \"label[for='\" + c + \"'], label[for='\" + c + \"'] *\";\n                return d && (e = e + \", #\" + this.escapeCssMeta(d).replace(/\\s+/g, \", #\")), this.errors().filter(e);\n            },\n            escapeCssMeta: function escapeCssMeta(a) {\n                return a.replace(/([\\\\!\"#$%&'()*+,./:;<=>?@\\[\\]^`{|}~])/g, \"\\\\$1\");\n            },\n            idOrName: function idOrName(a) {\n                return this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name);\n            },\n            validationTargetFor: function validationTargetFor(b) {\n                return this.checkable(b) && (b = this.findByName(b.name)), a(b).not(this.settings.ignore)[0];\n            },\n            checkable: function checkable(a) {\n                return (/radio|checkbox/i.test(a.type)\n                );\n            },\n            findByName: function findByName(b) {\n                return a(this.currentForm).find(\"[name='\" + this.escapeCssMeta(b) + \"']\");\n            },\n            getLength: function getLength(b, c) {\n                switch (c.nodeName.toLowerCase()) {\n                    case \"select\":\n                        return a(\"option:selected\", c).length;\n                    case \"input\":\n                        if (this.checkable(c)) return this.findByName(c.name).filter(\":checked\").length;\n                }\n                return b.length;\n            },\n            depend: function depend(a, b) {\n                return !this.dependTypes[typeof a === \"undefined\" ? \"undefined\" : _typeof(a)] || this.dependTypes[typeof a === \"undefined\" ? \"undefined\" : _typeof(a)](a, b);\n            },\n            dependTypes: {\n                boolean: function boolean(a) {\n                    return a;\n                },\n                string: function string(b, c) {\n                    return !!a(b, c.form).length;\n                },\n                function: function _function(a, b) {\n                    return a(b);\n                }\n            },\n            optional: function optional(b) {\n                var c = this.elementValue(b);\n                return !a.validator.methods.required.call(this, c, b) && \"dependency-mismatch\";\n            },\n            startRequest: function startRequest(b) {\n                this.pending[b.name] || (this.pendingRequest++, a(b).addClass(this.settings.pendingClass), this.pending[b.name] = !0);\n            },\n            stopRequest: function stopRequest(b, c) {\n                this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[b.name], a(b).removeClass(this.settings.pendingClass), c && 0 === this.pendingRequest && this.formSubmitted && this.form() ? (a(this.currentForm).submit(), this.formSubmitted = !1) : !c && 0 === this.pendingRequest && this.formSubmitted && (a(this.currentForm).triggerHandler(\"invalid-form\", [this]), this.formSubmitted = !1);\n            },\n            previousValue: function previousValue(b, c) {\n                return c = \"string\" == typeof c && c || \"remote\", a.data(b, \"previousValue\") || a.data(b, \"previousValue\", { old: null, valid: !0, message: this.defaultMessage(b, { method: c }) });\n            },\n            destroy: function destroy() {\n                this.resetForm(), a(this.currentForm).off(\".validate\").removeData(\"validator\").find(\".validate-equalTo-blur\").off(\".validate-equalTo\").removeClass(\"validate-equalTo-blur\");\n            }\n        },\n        classRuleSettings: {\n            required: { required: !0 },\n            email: { email: !0 },\n            url: { url: !0 },\n            date: { date: !0 },\n            dateISO: { dateISO: !0 },\n            number: { number: !0 },\n            digits: { digits: !0 },\n            creditcard: { creditcard: !0 }\n        },\n        addClassRules: function addClassRules(b, c) {\n            b.constructor === String ? this.classRuleSettings[b] = c : a.extend(this.classRuleSettings, b);\n        },\n        classRules: function classRules(b) {\n            var c = {},\n                d = a(b).attr(\"class\");\n            return d && a.each(d.split(\" \"), function () {\n                this in a.validator.classRuleSettings && a.extend(c, a.validator.classRuleSettings[this]);\n            }), c;\n        },\n        normalizeAttributeRule: function normalizeAttributeRule(a, b, c, d) {\n            /min|max|step/.test(c) && (null === b || /number|range|text/.test(b)) && (d = Number(d), isNaN(d) && (d = void 0)), d || 0 === d ? a[c] = d : b === c && \"range\" !== b && (a[c] = !0);\n        },\n        attributeRules: function attributeRules(b) {\n            var c,\n                d,\n                e = {},\n                f = a(b),\n                g = b.getAttribute(\"type\");\n            for (c in a.validator.methods) {\n                \"required\" === c ? (d = b.getAttribute(c), \"\" === d && (d = !0), d = !!d) : d = f.attr(c), this.normalizeAttributeRule(e, g, c, d);\n            }return e.maxlength && /-1|2147483647|524288/.test(e.maxlength) && delete e.maxlength, e;\n        },\n        dataRules: function dataRules(b) {\n            var c,\n                d,\n                e = {},\n                f = a(b),\n                g = b.getAttribute(\"type\");\n            for (c in a.validator.methods) {\n                d = f.data(\"rule\" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()), this.normalizeAttributeRule(e, g, c, d);\n            }return e;\n        },\n        staticRules: function staticRules(b) {\n            var c = {},\n                d = a.data(b.form, \"validator\");\n            return d.settings.rules && (c = a.validator.normalizeRule(d.settings.rules[b.name]) || {}), c;\n        },\n        normalizeRules: function normalizeRules(b, c) {\n            return a.each(b, function (d, e) {\n                if (e === !1) return void delete b[d];\n                if (e.param || e.depends) {\n                    var f = !0;\n                    switch (_typeof(e.depends)) {\n                        case \"string\":\n                            f = !!a(e.depends, c.form).length;\n                            break;\n                        case \"function\":\n                            f = e.depends.call(c, c);\n                    }\n                    f ? b[d] = void 0 === e.param || e.param : (a.data(c.form, \"validator\").resetElements(a(c)), delete b[d]);\n                }\n            }), a.each(b, function (d, e) {\n                b[d] = a.isFunction(e) && \"normalizer\" !== d ? e(c) : e;\n            }), a.each([\"minlength\", \"maxlength\"], function () {\n                b[this] && (b[this] = Number(b[this]));\n            }), a.each([\"rangelength\", \"range\"], function () {\n                var c;\n                b[this] && (a.isArray(b[this]) ? b[this] = [Number(b[this][0]), Number(b[this][1])] : \"string\" == typeof b[this] && (c = b[this].replace(/[\\[\\]]/g, \"\").split(/[\\s,]+/), b[this] = [Number(c[0]), Number(c[1])]));\n            }), a.validator.autoCreateRanges && (null != b.min && null != b.max && (b.range = [b.min, b.max], delete b.min, delete b.max), null != b.minlength && null != b.maxlength && (b.rangelength = [b.minlength, b.maxlength], delete b.minlength, delete b.maxlength)), b;\n        },\n        normalizeRule: function normalizeRule(b) {\n            if (\"string\" == typeof b) {\n                var c = {};\n                a.each(b.split(/\\s/), function () {\n                    c[this] = !0;\n                }), b = c;\n            }\n            return b;\n        },\n        addMethod: function addMethod(b, c, d) {\n            a.validator.methods[b] = c, a.validator.messages[b] = void 0 !== d ? d : a.validator.messages[b], c.length < 3 && a.validator.addClassRules(b, a.validator.normalizeRule(b));\n        },\n        methods: {\n            required: function required(b, c, d) {\n                if (!this.depend(d, c)) return \"dependency-mismatch\";\n                if (\"select\" === c.nodeName.toLowerCase()) {\n                    var e = a(c).val();\n                    return e && e.length > 0;\n                }\n                return this.checkable(c) ? this.getLength(b, c) > 0 : b.length > 0;\n            },\n            email: function email(a, b) {\n                return this.optional(b) || /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a);\n            },\n            url: function url(a, b) {\n                return this.optional(b) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})).?)(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(a);\n            },\n            date: function date(a, b) {\n                return this.optional(b) || !/Invalid|NaN/.test(new Date(a).toString());\n            },\n            dateISO: function dateISO(a, b) {\n                return this.optional(b) || /^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/.test(a);\n            },\n            number: function number(a, b) {\n                return this.optional(b) || /^(?:-?\\d+|-?\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test(a);\n            },\n            digits: function digits(a, b) {\n                return this.optional(b) || /^\\d+$/.test(a);\n            },\n            minlength: function minlength(b, c, d) {\n                var e = a.isArray(b) ? b.length : this.getLength(b, c);\n                return this.optional(c) || e >= d;\n            },\n            maxlength: function maxlength(b, c, d) {\n                var e = a.isArray(b) ? b.length : this.getLength(b, c);\n                return this.optional(c) || e <= d;\n            },\n            rangelength: function rangelength(b, c, d) {\n                var e = a.isArray(b) ? b.length : this.getLength(b, c);\n                return this.optional(c) || e >= d[0] && e <= d[1];\n            },\n            min: function min(a, b, c) {\n                return this.optional(b) || a >= c;\n            },\n            max: function max(a, b, c) {\n                return this.optional(b) || a <= c;\n            },\n            range: function range(a, b, c) {\n                return this.optional(b) || a >= c[0] && a <= c[1];\n            },\n            step: function step(b, c, d) {\n                var e,\n                    f = a(c).attr(\"type\"),\n                    g = \"Step attribute on input type \" + f + \" is not supported.\",\n                    h = [\"text\", \"number\", \"range\"],\n                    i = new RegExp(\"\\\\b\" + f + \"\\\\b\"),\n                    j = f && !i.test(h.join()),\n                    k = function k(a) {\n                    var b = (\"\" + a).match(/(?:\\.(\\d+))?$/);\n                    return b && b[1] ? b[1].length : 0;\n                },\n                    l = function l(a) {\n                    return Math.round(a * Math.pow(10, e));\n                },\n                    m = !0;\n                if (j) throw new Error(g);\n                return e = k(d), (k(b) > e || l(b) % l(d) !== 0) && (m = !1), this.optional(c) || m;\n            },\n            equalTo: function equalTo(b, c, d) {\n                var e = a(d);\n                return this.settings.onfocusout && e.not(\".validate-equalTo-blur\").length && e.addClass(\"validate-equalTo-blur\").on(\"blur.validate-equalTo\", function () {\n                    a(c).valid();\n                }), b === e.val();\n            },\n            remote: function remote(b, c, d, e) {\n                if (this.optional(c)) return \"dependency-mismatch\";\n                e = \"string\" == typeof e && e || \"remote\";\n                var f,\n                    g,\n                    h,\n                    i = this.previousValue(c, e);\n                return this.settings.messages[c.name] || (this.settings.messages[c.name] = {}), i.originalMessage = i.originalMessage || this.settings.messages[c.name][e], this.settings.messages[c.name][e] = i.message, d = \"string\" == typeof d && { url: d } || d, h = a.param(a.extend({ data: b }, d.data)), i.old === h ? i.valid : (i.old = h, f = this, this.startRequest(c), g = {}, g[c.name] = b, a.ajax(a.extend(!0, {\n                    mode: \"abort\",\n                    port: \"validate\" + c.name,\n                    dataType: \"json\",\n                    data: g,\n                    context: f.currentForm,\n                    success: function success(a) {\n                        var d,\n                            g,\n                            h,\n                            j = a === !0 || \"true\" === a;\n                        f.settings.messages[c.name][e] = i.originalMessage, j ? (h = f.formSubmitted, f.resetInternals(), f.toHide = f.errorsFor(c), f.formSubmitted = h, f.successList.push(c), f.invalid[c.name] = !1, f.showErrors()) : (d = {}, g = a || f.defaultMessage(c, { method: e, parameters: b }), d[c.name] = i.message = g, f.invalid[c.name] = !0, f.showErrors(d)), i.valid = j, f.stopRequest(c, j);\n                    }\n                }, d)), \"pending\");\n            }\n        }\n    });\n    var b,\n        c = {};\n    return a.ajaxPrefilter ? a.ajaxPrefilter(function (a, b, d) {\n        var e = a.port;\n        \"abort\" === a.mode && (c[e] && c[e].abort(), c[e] = d);\n    }) : (b = a.ajax, a.ajax = function (d) {\n        var e = (\"mode\" in d ? d : a.ajaxSettings).mode,\n            f = (\"port\" in d ? d : a.ajaxSettings).port;\n        return \"abort\" === e ? (c[f] && c[f].abort(), c[f] = b.apply(this, arguments), c[f]) : b.apply(this, arguments);\n    }), a;\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvbGliL2pxdWVyeS52YWxpZGF0ZS5taW4uanM/ZjRjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgalF1ZXJ5IFZhbGlkYXRpb24gUGx1Z2luIC0gdjEuMTYuMCAtIDEyLzIvMjAxNlxuICogaHR0cDovL2pxdWVyeXZhbGlkYXRpb24ub3JnL1xuICogQ29weXJpZ2h0IChjKSAyMDE2IErDtnJuIFphZWZmZXJlcjsgTGljZW5zZWQgTUlUICovXG4hKGZ1bmN0aW9uKGEpIHtcbiAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kXG4gICAgICAgID8gZGVmaW5lKFsgXCJqcXVlcnlcIiBdLCBhKVxuICAgICAgICA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0c1xuICAgICAgICAgICAgPyBtb2R1bGUuZXhwb3J0cyA9IGEocmVxdWlyZShcImpxdWVyeVwiKSlcbiAgICAgICAgICAgIDogYShqUXVlcnkpO1xufSkoZnVuY3Rpb24oYSkge1xuICAgIGEuZXh0ZW5kKGEuZm4sIHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgKGIgJiZcbiAgICAgICAgICAgICAgICAgICAgYi5kZWJ1ZyAmJlxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZSAmJlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk5vdGhpbmcgc2VsZWN0ZWQsIGNhbid0IHZhbGlkYXRlLCByZXR1cm5pbmcgbm90aGluZy5cIlxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjID0gYS5kYXRhKHRoaXNbMF0sIFwidmFsaWRhdG9yXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNcbiAgICAgICAgICAgICAgICA/IGNcbiAgICAgICAgICAgICAgICA6ICh0aGlzLmF0dHIoXCJub3ZhbGlkYXRlXCIsIFwibm92YWxpZGF0ZVwiKSwgYyA9IG5ldyBhLnZhbGlkYXRvcihcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgdGhpc1swXVxuICAgICAgICAgICAgICAgICksIGEuZGF0YSh0aGlzWzBdLCBcInZhbGlkYXRvclwiLCBjKSwgYy5zZXR0aW5ncy5vbnN1Ym1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vbihcImNsaWNrLnZhbGlkYXRlXCIsIFwiOnN1Ym1pdFwiLCBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYy5zdWJtaXRCdXR0b24gPSBiLnRhcmdldCksIGEodGhpcykuaGFzQ2xhc3MoXCJjYW5jZWxcIikgJiYgKGMuY2FuY2VsU3VibWl0ID0gITApLCB2b2lkIDAgIT09IGEodGhpcykuYXR0cihcImZvcm1ub3ZhbGlkYXRlXCIpICYmIChjLmNhbmNlbFN1Ym1pdCA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIHRoaXMub24oXCJzdWJtaXQudmFsaWRhdGVcIiwgZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWMuc2V0dGluZ3Muc3VibWl0SGFuZGxlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYy5zdWJtaXRCdXR0b24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkID0gYShcIjxpbnB1dCB0eXBlPSdoaWRkZW4nLz5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIm5hbWVcIiwgYy5zdWJtaXRCdXR0b24ubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsKGEoYy5zdWJtaXRCdXR0b24pLnZhbCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jdXJyZW50Rm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpLCBlID0gYy5zZXR0aW5ncy5zdWJtaXRIYW5kbGVyLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jdXJyZW50Rm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSwgYy5zdWJtaXRCdXR0b24gJiYgZC5yZW1vdmUoKSwgdm9pZCAwICE9PSBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnNldHRpbmdzLmRlYnVnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wcmV2ZW50RGVmYXVsdCgpLCBjLmNhbmNlbFN1Ym1pdCA/IChjLmNhbmNlbFN1Ym1pdCA9ICExLCBkKCkpIDogYy5mb3JtKCkgPyBjLnBlbmRpbmdSZXF1ZXN0ID8gKGMuZm9ybVN1Ym1pdHRlZCA9ICEwLCAhMSkgOiBkKCkgOiAoYy5mb2N1c0ludmFsaWQoKSwgITEpO1xuICAgICAgICAgICAgICAgICAgICB9KSksIGMpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYiwgYywgZDtcbiAgICAgICAgICAgIHJldHVybiBhKHRoaXNbMF0pLmlzKFwiZm9ybVwiKVxuICAgICAgICAgICAgICAgID8gYiA9IHRoaXMudmFsaWRhdGUoKS5mb3JtKClcbiAgICAgICAgICAgICAgICA6IChkID0gW10sIGIgPSAhMCwgYyA9IGEoXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbMF0uZm9ybVxuICAgICAgICAgICAgICAgICkudmFsaWRhdGUoKSwgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBiID0gYy5lbGVtZW50KHRoaXMpICYmIGIsIGIgfHwgKGQgPSBkLmNvbmNhdChjLmVycm9yTGlzdCkpO1xuICAgICAgICAgICAgICAgIH0pLCBjLmVycm9yTGlzdCA9IGQpLCBiO1xuICAgICAgICB9LFxuICAgICAgICBydWxlczogZnVuY3Rpb24oYiwgYykge1xuICAgICAgICAgICAgdmFyIGQsIGUsIGYsIGcsIGgsIGksIGogPSB0aGlzWzBdO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gaiAmJiBudWxsICE9IGouZm9ybSkge1xuICAgICAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKChkID0gYS5kYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgai5mb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWxpZGF0b3JcIlxuICAgICAgICAgICAgICAgICAgICApLnNldHRpbmdzLCBlID0gZC5ydWxlcywgZiA9IGEudmFsaWRhdG9yLnN0YXRpY1J1bGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgalxuICAgICAgICAgICAgICAgICAgICApLCBiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSwgZGVsZXRlIGYubWVzc2FnZXMsIGVbai5uYW1lXSA9IGYsIGMubWVzc2FnZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGQubWVzc2FnZXNbai5uYW1lXSA9IGEuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5tZXNzYWdlc1tqLm5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5tZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChpID0ge30sIGEuZWFjaChjLnNwbGl0KC9cXHMvKSwgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlbY10gPSBmW2NdLCBkZWxldGUgZltjXSwgXCJyZXF1aXJlZFwiID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhKGopLnJlbW92ZUF0dHIoXCJhcmlhLXJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoZGVsZXRlIGVbai5uYW1lXSwgZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZyA9IGEudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGVzKFxuICAgICAgICAgICAgICAgICAgICBhLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYS52YWxpZGF0b3IuY2xhc3NSdWxlcyhqKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEudmFsaWRhdG9yLmF0dHJpYnV0ZVJ1bGVzKGopLFxuICAgICAgICAgICAgICAgICAgICAgICAgYS52YWxpZGF0b3IuZGF0YVJ1bGVzKGopLFxuICAgICAgICAgICAgICAgICAgICAgICAgYS52YWxpZGF0b3Iuc3RhdGljUnVsZXMoailcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgalxuICAgICAgICAgICAgICAgICksIGcucmVxdWlyZWQgJiYgKGggPSBnLnJlcXVpcmVkLCBkZWxldGUgZy5yZXF1aXJlZCwgZyA9IGEuZXh0ZW5kKHsgcmVxdWlyZWQ6IGggfSwgZyksIGEoaikuYXR0cihcImFyaWEtcmVxdWlyZWRcIiwgXCJ0cnVlXCIpKSwgZy5yZW1vdGUgJiYgKGggPSBnLnJlbW90ZSwgZGVsZXRlIGcucmVtb3RlLCBnID0gYS5leHRlbmQoZywgeyByZW1vdGU6IGggfSkpLCBnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksIGEuZXh0ZW5kKGEuZXhwci5wc2V1ZG9zIHx8IGEuZXhwcltcIjpcIl0sIHtcbiAgICAgICAgYmxhbms6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHJldHVybiAhYS50cmltKFwiXCIgKyBhKGIpLnZhbCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbGVkOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGEoYikudmFsKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gYyAmJiAhIWEudHJpbShcIlwiICsgYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuY2hlY2tlZDogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgcmV0dXJuICFhKGIpLnByb3AoXCJjaGVja2VkXCIpO1xuICAgICAgICB9XG4gICAgfSksIGEudmFsaWRhdG9yID0gZnVuY3Rpb24oYiwgYykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gYS5leHRlbmQoXG4gICAgICAgICAgICAhMCxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgYS52YWxpZGF0b3IuZGVmYXVsdHMsXG4gICAgICAgICAgICBiXG4gICAgICAgICksIHRoaXMuY3VycmVudEZvcm0gPSBjLCB0aGlzLmluaXQoKTtcbiAgICB9LCBhLnZhbGlkYXRvci5mb3JtYXQgPSBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgIHJldHVybiAxID09PSBhcmd1bWVudHMubGVuZ3RoID8gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gYS5tYWtlQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy51bnNoaWZ0KGIpLCBhLnZhbGlkYXRvci5mb3JtYXQuYXBwbHkodGhpcywgYyk7XG4gICAgICAgICAgICB9KSA6IHZvaWQgMCA9PT0gY1xuICAgICAgICAgICAgICAgID8gYlxuICAgICAgICAgICAgICAgIDogKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmXG4gICAgICAgICAgICAgICAgICAgIGMuY29uc3RydWN0b3IgIT09IEFycmF5ICYmXG4gICAgICAgICAgICAgICAgICAgIChjID0gYS5tYWtlQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKSksIGMuY29uc3RydWN0b3IgIT09XG4gICAgICAgICAgICAgICAgICAgIEFycmF5ICYmXG4gICAgICAgICAgICAgICAgICAgIChjID0gWyBjIF0pLCBhLmVhY2goYywgZnVuY3Rpb24oYSwgYykge1xuICAgICAgICAgICAgICAgICAgICBiID0gYi5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcIlxcXFx7XCIgKyBhICsgXCJcXFxcfVwiLCBcImdcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KSwgYik7XG4gICAgfSwgYS5leHRlbmQoYS52YWxpZGF0b3IsIHtcbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7fSxcbiAgICAgICAgICAgIGdyb3Vwczoge30sXG4gICAgICAgICAgICBydWxlczoge30sXG4gICAgICAgICAgICBlcnJvckNsYXNzOiBcImVycm9yXCIsXG4gICAgICAgICAgICBwZW5kaW5nQ2xhc3M6IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgdmFsaWRDbGFzczogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgZXJyb3JFbGVtZW50OiBcImxhYmVsXCIsXG4gICAgICAgICAgICBmb2N1c0NsZWFudXA6ICExLFxuICAgICAgICAgICAgZm9jdXNJbnZhbGlkOiAhMCxcbiAgICAgICAgICAgIGVycm9yQ29udGFpbmVyOiBhKFtdKSxcbiAgICAgICAgICAgIGVycm9yTGFiZWxDb250YWluZXI6IGEoW10pLFxuICAgICAgICAgICAgb25zdWJtaXQ6ICEwLFxuICAgICAgICAgICAgaWdub3JlOiBcIjpoaWRkZW5cIixcbiAgICAgICAgICAgIGlnbm9yZVRpdGxlOiAhMSxcbiAgICAgICAgICAgIG9uZm9jdXNpbjogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEFjdGl2ZSA9IGEsIHRoaXMuc2V0dGluZ3MuZm9jdXNDbGVhbnVwICYmICh0aGlzLnNldHRpbmdzLnVuaGlnaGxpZ2h0ICYmIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCh0aGlzLCBhLCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyksIHRoaXMuaGlkZVRoZXNlKHRoaXMuZXJyb3JzRm9yKGEpKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25mb2N1c291dDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2thYmxlKGEpIHx8XG4gICAgICAgICAgICAgICAgICAgICEoYS5uYW1lIGluIHRoaXMuc3VibWl0dGVkKSAmJiB0aGlzLm9wdGlvbmFsKGEpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudChhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmtleXVwOiBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBbXG4gICAgICAgICAgICAgICAgICAgIDE2LFxuICAgICAgICAgICAgICAgICAgICAxNyxcbiAgICAgICAgICAgICAgICAgICAgMTgsXG4gICAgICAgICAgICAgICAgICAgIDIwLFxuICAgICAgICAgICAgICAgICAgICAzNSxcbiAgICAgICAgICAgICAgICAgICAgMzYsXG4gICAgICAgICAgICAgICAgICAgIDM3LFxuICAgICAgICAgICAgICAgICAgICAzOCxcbiAgICAgICAgICAgICAgICAgICAgMzksXG4gICAgICAgICAgICAgICAgICAgIDQwLFxuICAgICAgICAgICAgICAgICAgICA0NSxcbiAgICAgICAgICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgICAgICAgICAyMjVcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIDkgPT09IGMud2hpY2ggJiYgXCJcIiA9PT0gdGhpcy5lbGVtZW50VmFsdWUoYikgfHxcbiAgICAgICAgICAgICAgICAgICAgYS5pbkFycmF5KGMua2V5Q29kZSwgZCkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIChiLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgfHwgYi5uYW1lIGluIHRoaXMuaW52YWxpZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudChiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgYS5uYW1lIGluIHRoaXMuc3VibWl0dGVkXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5lbGVtZW50KGEpXG4gICAgICAgICAgICAgICAgICAgIDogYS5wYXJlbnROb2RlLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudChhLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oYiwgYywgZCkge1xuICAgICAgICAgICAgICAgIFwicmFkaW9cIiA9PT0gYi50eXBlXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5maW5kQnlOYW1lKGIubmFtZSkuYWRkQ2xhc3MoYykucmVtb3ZlQ2xhc3MoZClcbiAgICAgICAgICAgICAgICAgICAgOiBhKGIpLmFkZENsYXNzKGMpLnJlbW92ZUNsYXNzKGQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuaGlnaGxpZ2h0OiBmdW5jdGlvbihiLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgXCJyYWRpb1wiID09PSBiLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmZpbmRCeU5hbWUoYi5uYW1lKS5yZW1vdmVDbGFzcyhjKS5hZGRDbGFzcyhkKVxuICAgICAgICAgICAgICAgICAgICA6IGEoYikucmVtb3ZlQ2xhc3MoYykuYWRkQ2xhc3MoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldERlZmF1bHRzOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICBhLmV4dGVuZChhLnZhbGlkYXRvci5kZWZhdWx0cywgYik7XG4gICAgICAgIH0sXG4gICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogXCJUaGlzIGZpZWxkIGlzIHJlcXVpcmVkLlwiLFxuICAgICAgICAgICAgcmVtb3RlOiBcIlBsZWFzZSBmaXggdGhpcyBmaWVsZC5cIixcbiAgICAgICAgICAgIGVtYWlsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXCIsXG4gICAgICAgICAgICB1cmw6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgVVJMLlwiLFxuICAgICAgICAgICAgZGF0ZTogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlLlwiLFxuICAgICAgICAgICAgZGF0ZUlTTzogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlIChJU08pLlwiLFxuICAgICAgICAgICAgbnVtYmVyOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIG51bWJlci5cIixcbiAgICAgICAgICAgIGRpZ2l0czogXCJQbGVhc2UgZW50ZXIgb25seSBkaWdpdHMuXCIsXG4gICAgICAgICAgICBlcXVhbFRvOiBcIlBsZWFzZSBlbnRlciB0aGUgc2FtZSB2YWx1ZSBhZ2Fpbi5cIixcbiAgICAgICAgICAgIG1heGxlbmd0aDogYS52YWxpZGF0b3IuZm9ybWF0KFxuICAgICAgICAgICAgICAgIFwiUGxlYXNlIGVudGVyIG5vIG1vcmUgdGhhbiB7MH0gY2hhcmFjdGVycy5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1pbmxlbmd0aDogYS52YWxpZGF0b3IuZm9ybWF0KFxuICAgICAgICAgICAgICAgIFwiUGxlYXNlIGVudGVyIGF0IGxlYXN0IHswfSBjaGFyYWN0ZXJzLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcmFuZ2VsZW5ndGg6IGEudmFsaWRhdG9yLmZvcm1hdChcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGJldHdlZW4gezB9IGFuZCB7MX0gY2hhcmFjdGVycyBsb25nLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcmFuZ2U6IGEudmFsaWRhdG9yLmZvcm1hdChcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGJldHdlZW4gezB9IGFuZCB7MX0uXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtYXg6IGEudmFsaWRhdG9yLmZvcm1hdChcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7MH0uXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtaW46IGEudmFsaWRhdG9yLmZvcm1hdChcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7MH0uXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzdGVwOiBhLnZhbGlkYXRvci5mb3JtYXQoXCJQbGVhc2UgZW50ZXIgYSBtdWx0aXBsZSBvZiB7MH0uXCIpXG4gICAgICAgIH0sXG4gICAgICAgIGF1dG9DcmVhdGVSYW5nZXM6ICExLFxuICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGIoYikge1xuICAgICAgICAgICAgICAgICAgICAhdGhpcy5mb3JtICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZm9ybSA9IGEodGhpcykuY2xvc2VzdChcImZvcm1cIilbMF0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGEuZGF0YSh0aGlzLmZvcm0sIFwidmFsaWRhdG9yXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFwib25cIiArIGIudHlwZS5yZXBsYWNlKC9edmFsaWRhdGUvLCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBjLnNldHRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBlW2RdICYmICFhKHRoaXMpLmlzKGUuaWdub3JlKSAmJiBlW2RdLmNhbGwoYywgdGhpcywgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxDb250YWluZXIgPSBhKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXJcbiAgICAgICAgICAgICAgICApLCB0aGlzLmVycm9yQ29udGV4dCA9IHRoaXMubGFiZWxDb250YWluZXIubGVuZ3RoICYmIHRoaXMubGFiZWxDb250YWluZXIgfHwgYSh0aGlzLmN1cnJlbnRGb3JtKSwgdGhpcy5jb250YWluZXJzID0gYSh0aGlzLnNldHRpbmdzLmVycm9yQ29udGFpbmVyKS5hZGQodGhpcy5zZXR0aW5ncy5lcnJvckxhYmVsQ29udGFpbmVyKSwgdGhpcy5zdWJtaXR0ZWQgPSB7fSwgdGhpcy52YWx1ZUNhY2hlID0ge30sIHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwLCB0aGlzLnBlbmRpbmcgPSB7fSwgdGhpcy5pbnZhbGlkID0ge30sIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYywgZCA9IHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgICAgICAgICAgYS5lYWNoKHRoaXMuc2V0dGluZ3MuZ3JvdXBzLCBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjID0gYy5zcGxpdCgvXFxzLykpLCBhLmVhY2goYywgZnVuY3Rpb24oYSwgYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZFtjXSA9IGI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLCBjID0gdGhpcy5zZXR0aW5ncy5ydWxlcywgYS5lYWNoKGMsIGZ1bmN0aW9uKGIsIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY1tiXSA9IGEudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoZCk7XG4gICAgICAgICAgICAgICAgfSksIGEodGhpcy5jdXJyZW50Rm9ybSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmb2N1c2luLnZhbGlkYXRlIGZvY3Vzb3V0LnZhbGlkYXRlIGtleXVwLnZhbGlkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjp0ZXh0LCBbdHlwZT0ncGFzc3dvcmQnXSwgW3R5cGU9J2ZpbGUnXSwgc2VsZWN0LCB0ZXh0YXJlYSwgW3R5cGU9J251bWJlciddLCBbdHlwZT0nc2VhcmNoJ10sIFt0eXBlPSd0ZWwnXSwgW3R5cGU9J3VybCddLCBbdHlwZT0nZW1haWwnXSwgW3R5cGU9J2RhdGV0aW1lJ10sIFt0eXBlPSdkYXRlJ10sIFt0eXBlPSdtb250aCddLCBbdHlwZT0nd2VlayddLCBbdHlwZT0ndGltZSddLCBbdHlwZT0nZGF0ZXRpbWUtbG9jYWwnXSwgW3R5cGU9J3JhbmdlJ10sIFt0eXBlPSdjb2xvciddLCBbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J10sIFtjb250ZW50ZWRpdGFibGVdLCBbdHlwZT0nYnV0dG9uJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAub24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsaWNrLnZhbGlkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlbGVjdCwgb3B0aW9uLCBbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJcbiAgICAgICAgICAgICAgICAgICAgKSwgdGhpcy5zZXR0aW5ncy5pbnZhbGlkSGFuZGxlciAmJiBhKHRoaXMuY3VycmVudEZvcm0pLm9uKFwiaW52YWxpZC1mb3JtLnZhbGlkYXRlXCIsIHRoaXMuc2V0dGluZ3MuaW52YWxpZEhhbmRsZXIpLCBhKHRoaXMuY3VycmVudEZvcm0pLmZpbmQoXCJbcmVxdWlyZWRdLCBbZGF0YS1ydWxlLXJlcXVpcmVkXSwgLnJlcXVpcmVkXCIpLmF0dHIoXCJhcmlhLXJlcXVpcmVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0Zvcm0oKSwgYS5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VibWl0dGVkLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yTWFwXG4gICAgICAgICAgICAgICAgKSwgdGhpcy5pbnZhbGlkID0gYS5leHRlbmQoe30sIHRoaXMuZXJyb3JNYXApLCB0aGlzLnZhbGlkKCkgfHwgYSh0aGlzLmN1cnJlbnRGb3JtKS50cmlnZ2VySGFuZGxlcihcImludmFsaWQtZm9ybVwiLCBbIHRoaXMgXSksIHRoaXMuc2hvd0Vycm9ycygpLCB0aGlzLnZhbGlkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hlY2tGb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVGb3JtKCk7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAwLCBiID0gdGhpcy5jdXJyZW50RWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJbYV07XG4gICAgICAgICAgICAgICAgICAgIGErK1xuICAgICAgICAgICAgICAgICkgdGhpcy5jaGVjayhiW2FdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyxcbiAgICAgICAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuY2xlYW4oYiksXG4gICAgICAgICAgICAgICAgICAgIGYgPSB0aGlzLnZhbGlkYXRpb25UYXJnZXRGb3IoZSksXG4gICAgICAgICAgICAgICAgICAgIGcgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBoID0gITA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZlxuICAgICAgICAgICAgICAgICAgICA/IGRlbGV0ZSB0aGlzLmludmFsaWRbZS5uYW1lXVxuICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLnByZXBhcmVFbGVtZW50KGYpLCB0aGlzLmN1cnJlbnRFbGVtZW50cyA9IGEoXG4gICAgICAgICAgICAgICAgICAgICAgICBmXG4gICAgICAgICAgICAgICAgICAgICksIGQgPSB0aGlzLmdyb3Vwc1tmLm5hbWVdLCBkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID09PSBkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgIT09IGYubmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSA9IGcudmFsaWRhdGlvblRhcmdldEZvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcuY2xlYW4oZy5maW5kQnlOYW1lKGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLCBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm5hbWUgaW4gZy5pbnZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZy5jdXJyZW50RWxlbWVudHMucHVzaChlKSwgaCA9IGcuY2hlY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjID0gdGhpcy5jaGVjayhmKSAhPT0gITEsIGggPSBoICYmIGMsIGNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5pbnZhbGlkW2YubmFtZV0gPSAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmludmFsaWRbZi5uYW1lXSA9ICEwLCB0aGlzLm51bWJlck9mSW52YWxpZHMoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudG9IaWRlID0gdGhpcy50b0hpZGUuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSksIHRoaXMuc2hvd0Vycm9ycygpLCBhKGIpLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtaW52YWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNcbiAgICAgICAgICAgICAgICAgICAgKSksIGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0Vycm9yczogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgYS5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYlxuICAgICAgICAgICAgICAgICAgICApLCB0aGlzLmVycm9yTGlzdCA9IGEubWFwKHRoaXMuZXJyb3JNYXAsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGEsIGVsZW1lbnQ6IGMuZmluZEJ5TmFtZShiKVswXSB9O1xuICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5zdWNjZXNzTGlzdCA9IGEuZ3JlcCh0aGlzLnN1Y2Nlc3NMaXN0LCBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShhLm5hbWUgaW4gYik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNob3dFcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnNldHRpbmdzLnNob3dFcnJvcnMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckxpc3RcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZGVmYXVsdFNob3dFcnJvcnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldEZvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGEuZm4ucmVzZXRGb3JtICYmXG4gICAgICAgICAgICAgICAgICAgIGEoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGb3JtXG4gICAgICAgICAgICAgICAgICAgICkucmVzZXRGb3JtKCksIHRoaXMuaW52YWxpZCA9IHt9LCB0aGlzLnN1Ym1pdHRlZCA9IHt9LCB0aGlzLnByZXBhcmVGb3JtKCksIHRoaXMuaGlkZUVycm9ycygpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAuZWxlbWVudHMoKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlRGF0YShcInByZXZpb3VzVmFsdWVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoXCJhcmlhLWludmFsaWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEVsZW1lbnRzKGIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChiID0gMDsgYVtiXTsgYisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSwgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kQnlOYW1lKGFbYl0ubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy52YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy52YWxpZENsYXNzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1iZXJPZkludmFsaWRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RMZW5ndGgodGhpcy5pbnZhbGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvYmplY3RMZW5ndGg6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiwgYyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChiIGluIGEpIGFbYl0gJiYgYysrO1xuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVFcnJvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRoZXNlKHRoaXMudG9IaWRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlVGhlc2U6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICBhLm5vdCh0aGlzLmNvbnRhaW5lcnMpLnRleHQoXCJcIiksIHRoaXMuYWRkV3JhcHBlcihhKS5oaWRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwID09PSB0aGlzLnNpemUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzSW52YWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZm9jdXNJbnZhbGlkKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRMYXN0QWN0aXZlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yTGlzdFswXS5lbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihcIjp2aXNpYmxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvY3VzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpZ2dlcihcImZvY3VzaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmRMYXN0QWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMubGFzdEFjdGl2ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYiAmJiAxID09PSBhLmdyZXAodGhpcy5lcnJvckxpc3QsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5lbGVtZW50Lm5hbWUgPT09IGIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aCAmJiBiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMsIGMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSh0aGlzLmN1cnJlbnRGb3JtKVxuICAgICAgICAgICAgICAgICAgICAuZmluZChcImlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbY29udGVudGVkaXRhYmxlXVwiKVxuICAgICAgICAgICAgICAgICAgICAubm90KFwiOnN1Ym1pdCwgOnJlc2V0LCA6aW1hZ2UsIDpkaXNhYmxlZFwiKVxuICAgICAgICAgICAgICAgICAgICAubm90KHRoaXMuc2V0dGluZ3MuaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLm5hbWUgfHwgYSh0aGlzKS5hdHRyKFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuc2V0dGluZ3MuZGVidWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJW8gaGFzIG5vIG5hbWUgYXNzaWduZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksIHRoaXMuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICYmICh0aGlzLmZvcm0gPSBhKHRoaXMpLmNsb3Nlc3QoXCJmb3JtXCIpWzBdKSwgIShkIGluIGMgfHwgIWIub2JqZWN0TGVuZ3RoKGEodGhpcykucnVsZXMoKSkpICYmIChjW2RdID0gITAsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW46IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYShiKVswXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLnNwbGl0KFwiIFwiKS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIi5cIiArIGIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JDb250ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldEludGVybmFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzTGlzdCA9IFtdLCB0aGlzLmVycm9yTGlzdCA9IFtdLCB0aGlzLmVycm9yTWFwID0ge30sIHRoaXMudG9TaG93ID0gYShbXSksIHRoaXMudG9IaWRlID0gYShbXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbHMoKSwgdGhpcy5jdXJyZW50RWxlbWVudHMgPSBhKFtdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVwYXJlRm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpLCB0aGlzLnRvSGlkZSA9IHRoaXMuZXJyb3JzKCkuYWRkKHRoaXMuY29udGFpbmVycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlcGFyZUVsZW1lbnQ6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCksIHRoaXMudG9IaWRlID0gdGhpcy5lcnJvcnNGb3IoYSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxlbWVudFZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMsIGQsIGUgPSBhKGIpLCBmID0gYi50eXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcInJhZGlvXCIgPT09IGYgfHwgXCJjaGVja2JveFwiID09PSBmXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5maW5kQnlOYW1lKGIubmFtZSkuZmlsdGVyKFwiOmNoZWNrZWRcIikudmFsKClcbiAgICAgICAgICAgICAgICAgICAgOiBcIm51bWJlclwiID09PSBmICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGIudmFsaWRpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYi52YWxpZGl0eS5iYWRJbnB1dCA/IFwiTmFOXCIgOiBlLnZhbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChjID0gYi5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGUudGV4dCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlLnZhbCgpLCBcImZpbGVcIiA9PT0gZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJDOlxcXFxmYWtlcGF0aFxcXFxcIiA9PT0gYy5zdWJzdHIoMCwgMTIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYy5zdWJzdHIoMTIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGQgPSBjLmxhc3RJbmRleE9mKFwiL1wiKSwgZCA+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGMuc3Vic3RyKGQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoZCA9IGMubGFzdEluZGV4T2YoXCJcXFxcXCIpLCBkID49IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGMuc3Vic3RyKGQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09IHR5cGVvZiBjID8gYy5yZXBsYWNlKC9cXHIvZywgXCJcIikgOiBjKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGVjazogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzLnZhbGlkYXRpb25UYXJnZXRGb3IodGhpcy5jbGVhbihiKSk7XG4gICAgICAgICAgICAgICAgdmFyIGMsXG4gICAgICAgICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAgIGYgPSBhKGIpLnJ1bGVzKCksXG4gICAgICAgICAgICAgICAgICAgIGcgPSBhLm1hcChmLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBoID0gITEsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLmVsZW1lbnRWYWx1ZShiKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBmLm5vcm1hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpID0gZi5ub3JtYWxpemVyLmNhbGwoYiwgaSksIFwic3RyaW5nXCIgIT0gdHlwZW9mIGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBub3JtYWxpemVyIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgdmFsdWUuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmLm5vcm1hbGl6ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoZCBpbiBmKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB7IG1ldGhvZDogZCwgcGFyYW1ldGVyczogZltkXSB9O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjID0gYS52YWxpZGF0b3IubWV0aG9kc1tkXS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLCBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIiA9PT0gYyAmJiAxID09PSBnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChoID0gITEsIFwicGVuZGluZ1wiID09PSBjKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAodGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5ub3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzRm9yKGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWMpIHJldHVybiB0aGlzLmZvcm1hdEFuZEFkZChiLCBlKSwgITE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICh0aGlzLnNldHRpbmdzLmRlYnVnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFeGNlcHRpb24gb2NjdXJyZWQgd2hlbiBjaGVja2luZyBlbGVtZW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGNoZWNrIHRoZSAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5tZXRob2QgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksIGogaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGoubWVzc2FnZSArPSBcIi4gIEV4Y2VwdGlvbiBvY2N1cnJlZCB3aGVuIGNoZWNraW5nIGVsZW1lbnQgXCIgKyBiLmlkICsgXCIsIGNoZWNrIHRoZSAnXCIgKyBlLm1ldGhvZCArIFwiJyBtZXRob2QuXCIpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdExlbmd0aChmKSAmJiB0aGlzLnN1Y2Nlc3NMaXN0LnB1c2goYiksICEwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1c3RvbURhdGFNZXNzYWdlOiBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoYikuZGF0YShcbiAgICAgICAgICAgICAgICAgICAgXCJtc2dcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Vic3RyaW5nKDEpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgICAgIGEoYikuZGF0YShcIm1zZ1wiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXN0b21NZXNzYWdlOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2FdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjICYmIChjLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBjIDogY1tiXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluZERlZmluZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYSA8IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGErK1xuICAgICAgICAgICAgICAgICkgaWYgKHZvaWQgMCAhPT0gYXJndW1lbnRzW2FdKSByZXR1cm4gYXJndW1lbnRzW2FdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRNZXNzYWdlOiBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYyAmJiAoYyA9IHsgbWV0aG9kOiBjIH0pO1xuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5maW5kRGVmaW5lZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21NZXNzYWdlKGIubmFtZSwgYy5tZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbURhdGFNZXNzYWdlKGIsIGMubWV0aG9kKSxcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuc2V0dGluZ3MuaWdub3JlVGl0bGUgJiYgYi50aXRsZSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIGEudmFsaWRhdG9yLm1lc3NhZ2VzW2MubWV0aG9kXSxcbiAgICAgICAgICAgICAgICAgICAgXCI8c3Ryb25nPldhcm5pbmc6IE5vIG1lc3NhZ2UgZGVmaW5lZCBmb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPC9zdHJvbmc+XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBlID0gL1xcJD9cXHsoXFxkKylcXH0vZztcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBkXG4gICAgICAgICAgICAgICAgICAgID8gZCA9IGQuY2FsbCh0aGlzLCBjLnBhcmFtZXRlcnMsIGIpXG4gICAgICAgICAgICAgICAgICAgIDogZS50ZXN0KGQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZCA9IGEudmFsaWRhdG9yLmZvcm1hdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnJlcGxhY2UoZSwgXCJ7JDF9XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSksIGQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0QW5kQWRkOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRNZXNzYWdlKGEsIGIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBhLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGIubWV0aG9kXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuZXJyb3JNYXBbYS5uYW1lXSA9IGMsIHRoaXMuc3VibWl0dGVkW2EubmFtZV0gPSBjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFdyYXBwZXI6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy53cmFwcGVyICYmXG4gICAgICAgICAgICAgICAgICAgIChhID0gYS5hZGQoYS5wYXJlbnQodGhpcy5zZXR0aW5ncy53cmFwcGVyKSkpLCBhO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRTaG93RXJyb3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgYztcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICBhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckxpc3RbYV07XG4gICAgICAgICAgICAgICAgICAgIGErK1xuICAgICAgICAgICAgICAgICkgYyA9IHRoaXMuZXJyb3JMaXN0W2FdLCB0aGlzLnNldHRpbmdzLmhpZ2hsaWdodCAmJiB0aGlzLnNldHRpbmdzLmhpZ2hsaWdodC5jYWxsKHRoaXMsIGMuZWxlbWVudCwgdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCB0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MpLCB0aGlzLnNob3dMYWJlbChjLmVsZW1lbnQsIGMubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5lcnJvckxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50b1Nob3cgPSB0aGlzLnRvU2hvdy5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICApKSwgdGhpcy5zZXR0aW5ncy5zdWNjZXNzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChhID0gMDsgdGhpcy5zdWNjZXNzTGlzdFthXTsgYSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93TGFiZWwodGhpcy5zdWNjZXNzTGlzdFthXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IDAsIGIgPSB0aGlzLnZhbGlkRWxlbWVudHMoKTsgYlthXTsgYSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYlthXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMudG9IaWRlID0gdGhpcy50b0hpZGUubm90KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU2hvd1xuICAgICAgICAgICAgICAgICksIHRoaXMuaGlkZUVycm9ycygpLCB0aGlzLmFkZFdyYXBwZXIodGhpcy50b1Nob3cpLnNob3coKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudHMubm90KHRoaXMuaW52YWxpZEVsZW1lbnRzKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludmFsaWRFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEodGhpcy5lcnJvckxpc3QpLm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZ1bmN0aW9uKGIsIGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCxcbiAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgICAgICAgZyxcbiAgICAgICAgICAgICAgICAgICAgaCA9IHRoaXMuZXJyb3JzRm9yKGIpLFxuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5pZE9yTmFtZShiKSxcbiAgICAgICAgICAgICAgICAgICAgaiA9IGEoYikuYXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIik7XG4gICAgICAgICAgICAgICAgaC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyAoaFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MpLCBoLmh0bWwoYykpXG4gICAgICAgICAgICAgICAgICAgIDogKGggPSBhKFwiPFwiICsgdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgaSArIFwiLWVycm9yXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwoYyB8fCBcIlwiKSwgZCA9IGgsIHRoaXMuc2V0dGluZ3Mud3JhcHBlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGQgPSBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhpZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zaG93KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud3JhcChcIjxcIiArIHRoaXMuc2V0dGluZ3Mud3JhcHBlciArIFwiLz5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KCkpLCB0aGlzLmxhYmVsQ29udGFpbmVyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxhYmVsQ29udGFpbmVyLmFwcGVuZChkKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnNldHRpbmdzLmVycm9yUGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnNldHRpbmdzLmVycm9yUGxhY2VtZW50LmNhbGwodGhpcywgZCwgYShiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGQuaW5zZXJ0QWZ0ZXIoYiksIGguaXMoXCJsYWJlbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBoLmF0dHIoXCJmb3JcIiwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoLnBhcmVudHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxbZm9yPSdcIiArIHRoaXMuZXNjYXBlQ3NzTWV0YShpKSArIFwiJ11cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGYgPSBoLmF0dHIoXCJpZFwiKSwgalxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGoubWF0Y2gobmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxcXGJcIiArIHRoaXMuZXNjYXBlQ3NzTWV0YShmKSArIFwiXFxcXGJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGogKz0gXCIgXCIgKyBmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGogPSBmLCBhKGIpLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSwgZSA9IHRoaXMuZ3JvdXBzW2IubmFtZV0sIGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGcgPSB0aGlzLCBhLmVhY2goZy5ncm91cHMsIGZ1bmN0aW9uKGIsIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPT09IGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltuYW1lPSdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnLmVzY2FwZUNzc01ldGEoYikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnLmN1cnJlbnRGb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5hdHRyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5hdHRyKFwiaWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKSwgIWMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zdWNjZXNzICYmXG4gICAgICAgICAgICAgICAgICAgIChoLnRleHQoXCJcIiksIFwic3RyaW5nXCIgPT0gdHlwZW9mIHRoaXMuc2V0dGluZ3Muc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBoLmFkZENsYXNzKHRoaXMuc2V0dGluZ3Muc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5zZXR0aW5ncy5zdWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYlxuICAgICAgICAgICAgICAgICAgICAgICAgKSksIHRoaXMudG9TaG93ID0gdGhpcy50b1Nob3cuYWRkKGgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yc0ZvcjogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5lc2NhcGVDc3NNZXRhKHRoaXMuaWRPck5hbWUoYikpLFxuICAgICAgICAgICAgICAgICAgICBkID0gYShiKS5hdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiKSxcbiAgICAgICAgICAgICAgICAgICAgZSA9IFwibGFiZWxbZm9yPSdcIiArIGMgKyBcIiddLCBsYWJlbFtmb3I9J1wiICsgYyArIFwiJ10gKlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBkICYmXG4gICAgICAgICAgICAgICAgICAgIChlID0gZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiwgI1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZXNjYXBlQ3NzTWV0YShkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csIFwiLCAjXCIpKSwgdGhpcy5lcnJvcnMoKS5maWx0ZXIoZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXNjYXBlQ3NzTWV0YTogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC8oW1xcXFwhXCIjJCUmJygpKissLi86Ozw9Pj9AXFxbXFxdXmB7fH1+XSkvZyxcbiAgICAgICAgICAgICAgICAgICAgXCJcXFxcJDFcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRPck5hbWU6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNbYS5uYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5jaGVja2FibGUoYSkgPyBhLm5hbWUgOiBhLmlkIHx8IGEubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGlvblRhcmdldEZvcjogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrYWJsZShiKSAmJlxuICAgICAgICAgICAgICAgICAgICAoYiA9IHRoaXMuZmluZEJ5TmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGIubmFtZVxuICAgICAgICAgICAgICAgICAgICApKSwgYShiKS5ub3QodGhpcy5zZXR0aW5ncy5pZ25vcmUpWzBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoZWNrYWJsZTogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAvcmFkaW98Y2hlY2tib3gvaS50ZXN0KGEudHlwZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluZEJ5TmFtZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGb3JtXG4gICAgICAgICAgICAgICAgKS5maW5kKFwiW25hbWU9J1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKGIpICsgXCInXVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKGIsIGMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYShcIm9wdGlvbjpzZWxlY3RlZFwiLCBjKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2thYmxlKGMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kQnlOYW1lKGMubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihcIjpjaGVja2VkXCIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlcGVuZDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5kZXBlbmRUeXBlc1t0eXBlb2YgYV0gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXBlbmRUeXBlc1t0eXBlb2YgYV0oYSwgYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVwZW5kVHlwZXM6IHtcbiAgICAgICAgICAgICAgICBib29sZWFuOiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5nOiBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWEoYiwgYy5mb3JtKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYShiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uYWw6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuZWxlbWVudFZhbHVlKGIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhYS52YWxpZGF0b3IubWV0aG9kcy5yZXF1aXJlZC5jYWxsKHRoaXMsIGMsIGIpICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZGVwZW5kZW5jeS1taXNtYXRjaFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0UmVxdWVzdDogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1tiLm5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnBlbmRpbmdSZXF1ZXN0KyssIGEoYikuYWRkQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnBlbmRpbmdDbGFzc1xuICAgICAgICAgICAgICAgICAgICApLCB0aGlzLnBlbmRpbmdbYi5uYW1lXSA9ICEwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wUmVxdWVzdDogZnVuY3Rpb24oYiwgYykge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3QtLSwgdGhpcy5wZW5kaW5nUmVxdWVzdCA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwKSwgZGVsZXRlIHRoaXMucGVuZGluZ1tiLm5hbWVdLCBhKGIpLnJlbW92ZUNsYXNzKHRoaXMuc2V0dGluZ3MucGVuZGluZ0NsYXNzKSwgYyAmJiAwID09PSB0aGlzLnBlbmRpbmdSZXF1ZXN0ICYmIHRoaXMuZm9ybVN1Ym1pdHRlZCAmJiB0aGlzLmZvcm0oKSA/IChhKHRoaXMuY3VycmVudEZvcm0pLnN1Ym1pdCgpLCB0aGlzLmZvcm1TdWJtaXR0ZWQgPSAhMSkgOiAhYyAmJiAwID09PSB0aGlzLnBlbmRpbmdSZXF1ZXN0ICYmIHRoaXMuZm9ybVN1Ym1pdHRlZCAmJiAoYSh0aGlzLmN1cnJlbnRGb3JtKS50cmlnZ2VySGFuZGxlcihcImludmFsaWQtZm9ybVwiLCBbIHRoaXMgXSksIHRoaXMuZm9ybVN1Ym1pdHRlZCA9ICExKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgPSBcInN0cmluZ1wiID09IHR5cGVvZiBjICYmIGMgfHxcbiAgICAgICAgICAgICAgICAgICAgXCJyZW1vdGVcIiwgYS5kYXRhKGIsIFwicHJldmlvdXNWYWx1ZVwiKSB8fCBhLmRhdGEoYiwgXCJwcmV2aW91c1ZhbHVlXCIsIHsgb2xkOiBudWxsLCB2YWxpZDogITAsIG1lc3NhZ2U6IHRoaXMuZGVmYXVsdE1lc3NhZ2UoYiwgeyBtZXRob2Q6IGMgfSkgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZvcm0oKSwgYSh0aGlzLmN1cnJlbnRGb3JtKVxuICAgICAgICAgICAgICAgICAgICAub2ZmKFwiLnZhbGlkYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVEYXRhKFwidmFsaWRhdG9yXCIpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKFwiLnZhbGlkYXRlLWVxdWFsVG8tYmx1clwiKVxuICAgICAgICAgICAgICAgICAgICAub2ZmKFwiLnZhbGlkYXRlLWVxdWFsVG9cIilcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwidmFsaWRhdGUtZXF1YWxUby1ibHVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGFzc1J1bGVTZXR0aW5nczoge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IHsgcmVxdWlyZWQ6ICEwIH0sXG4gICAgICAgICAgICBlbWFpbDogeyBlbWFpbDogITAgfSxcbiAgICAgICAgICAgIHVybDogeyB1cmw6ICEwIH0sXG4gICAgICAgICAgICBkYXRlOiB7IGRhdGU6ICEwIH0sXG4gICAgICAgICAgICBkYXRlSVNPOiB7IGRhdGVJU086ICEwIH0sXG4gICAgICAgICAgICBudW1iZXI6IHsgbnVtYmVyOiAhMCB9LFxuICAgICAgICAgICAgZGlnaXRzOiB7IGRpZ2l0czogITAgfSxcbiAgICAgICAgICAgIGNyZWRpdGNhcmQ6IHsgY3JlZGl0Y2FyZDogITAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGRDbGFzc1J1bGVzOiBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICBiLmNvbnN0cnVjdG9yID09PSBTdHJpbmdcbiAgICAgICAgICAgICAgICA/IHRoaXMuY2xhc3NSdWxlU2V0dGluZ3NbYl0gPSBjXG4gICAgICAgICAgICAgICAgOiBhLmV4dGVuZCh0aGlzLmNsYXNzUnVsZVNldHRpbmdzLCBiKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NSdWxlczogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgdmFyIGMgPSB7fSwgZCA9IGEoYikuYXR0cihcImNsYXNzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGQgJiYgYS5lYWNoKGQuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcyBpbiBhLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5ncyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5leHRlbmQoYywgYS52YWxpZGF0b3IuY2xhc3NSdWxlU2V0dGluZ3NbdGhpc10pO1xuICAgICAgICAgICAgICAgIH0pLCBjO1xuICAgICAgICB9LFxuICAgICAgICBub3JtYWxpemVBdHRyaWJ1dGVSdWxlOiBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICAvbWlufG1heHxzdGVwLy50ZXN0KGMpICYmXG4gICAgICAgICAgICAgICAgKG51bGwgPT09IGIgfHwgL251bWJlcnxyYW5nZXx0ZXh0Ly50ZXN0KGIpKSAmJlxuICAgICAgICAgICAgICAgIChkID0gTnVtYmVyKGQpLCBpc05hTihkKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZCA9IHZvaWQgMCkpLCBkIHx8IDAgPT09IGQgPyBhW2NdID0gZCA6IGIgPT09IGMgJiYgXCJyYW5nZVwiICE9PSBiICYmIChhW2NdID0gITApO1xuICAgICAgICB9LFxuICAgICAgICBhdHRyaWJ1dGVSdWxlczogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgdmFyIGMsIGQsIGUgPSB7fSwgZiA9IGEoYiksIGcgPSBiLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgICAgICBmb3IgKGMgaW4gYS52YWxpZGF0b3IubWV0aG9kcykgXCJyZXF1aXJlZFwiID09PSBjXG4gICAgICAgICAgICAgICAgICAgID8gKGQgPSBiLmdldEF0dHJpYnV0ZShjKSwgXCJcIiA9PT0gZCAmJiAoZCA9ICEwKSwgZCA9ICEhZClcbiAgICAgICAgICAgICAgICAgICAgOiBkID0gZi5hdHRyKGMpLCB0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZVJ1bGUoZSwgZywgYywgZCk7XG4gICAgICAgICAgICByZXR1cm4gZS5tYXhsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAvLTF8MjE0NzQ4MzY0N3w1MjQyODgvLnRlc3QoZS5tYXhsZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgZGVsZXRlIGUubWF4bGVuZ3RoLCBlO1xuICAgICAgICB9LFxuICAgICAgICBkYXRhUnVsZXM6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHZhciBjLCBkLCBlID0ge30sIGYgPSBhKGIpLCBnID0gYi5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgICAgICAgICAgZm9yIChjIGluIGEudmFsaWRhdG9yLm1ldGhvZHMpIGQgPSBmLmRhdGEoXG4gICAgICAgICAgICAgICAgICAgIFwicnVsZVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5zdWJzdHJpbmcoMSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICksIHRoaXMubm9ybWFsaXplQXR0cmlidXRlUnVsZShlLCBnLCBjLCBkKTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICBzdGF0aWNSdWxlczogZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgdmFyIGMgPSB7fSwgZCA9IGEuZGF0YShiLmZvcm0sIFwidmFsaWRhdG9yXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGQuc2V0dGluZ3MucnVsZXMgJiZcbiAgICAgICAgICAgICAgICAoYyA9IGEudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoZC5zZXR0aW5ncy5ydWxlc1tiLm5hbWVdKSB8fFxuICAgICAgICAgICAgICAgICAgICB7fSksIGM7XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1hbGl6ZVJ1bGVzOiBmdW5jdGlvbihiLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5lYWNoKGIsIGZ1bmN0aW9uKGQsIGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gITEpIHJldHVybiB2b2lkIGRlbGV0ZSBiW2RdO1xuICAgICAgICAgICAgICAgIGlmIChlLnBhcmFtIHx8IGUuZGVwZW5kcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlLmRlcGVuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gISFhKGUuZGVwZW5kcywgYy5mb3JtKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gZS5kZXBlbmRzLmNhbGwoYywgYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBiW2RdID0gdm9pZCAwID09PSBlLnBhcmFtIHx8IGUucGFyYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShjLmZvcm0sIFwidmFsaWRhdG9yXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlc2V0RWxlbWVudHMoYShjKSksIGRlbGV0ZSBiW2RdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgYS5lYWNoKGIsIGZ1bmN0aW9uKGQsIGUpIHtcbiAgICAgICAgICAgICAgICBiW2RdID0gYS5pc0Z1bmN0aW9uKGUpICYmIFwibm9ybWFsaXplclwiICE9PSBkID8gZShjKSA6IGU7XG4gICAgICAgICAgICB9KSwgYS5lYWNoKFsgXCJtaW5sZW5ndGhcIiwgXCJtYXhsZW5ndGhcIiBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiW3RoaXNdICYmIChiW3RoaXNdID0gTnVtYmVyKGJbdGhpc10pKTtcbiAgICAgICAgICAgIH0pLCBhLmVhY2goWyBcInJhbmdlbGVuZ3RoXCIsIFwicmFuZ2VcIiBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYztcbiAgICAgICAgICAgICAgICBiW3RoaXNdICYmXG4gICAgICAgICAgICAgICAgICAgIChhLmlzQXJyYXkoYlt0aGlzXSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYlt0aGlzXSA9IFsgTnVtYmVyKGJbdGhpc11bMF0pLCBOdW1iZXIoYlt0aGlzXVsxXSkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09IHR5cGVvZiBiW3RoaXNdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGMgPSBiW3RoaXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxbXFxdXS9nLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoL1tcXHMsXSsvKSwgYlt0aGlzXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyKGNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIoY1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9KSwgYS52YWxpZGF0b3IuYXV0b0NyZWF0ZVJhbmdlcyAmJlxuICAgICAgICAgICAgICAgIChudWxsICE9IGIubWluICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT0gYi5tYXggJiZcbiAgICAgICAgICAgICAgICAgICAgKGIucmFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBiLm1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGIubWF4XG4gICAgICAgICAgICAgICAgICAgIF0sIGRlbGV0ZSBiLm1pbiwgZGVsZXRlIGIubWF4KSwgbnVsbCAhPSBiLm1pbmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9IGIubWF4bGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChiLnJhbmdlbGVuZ3RoID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5taW5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBiLm1heGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBdLCBkZWxldGUgYi5taW5sZW5ndGgsIGRlbGV0ZSBiLm1heGxlbmd0aCkpLCBiO1xuICAgICAgICB9LFxuICAgICAgICBub3JtYWxpemVSdWxlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgICAgIHZhciBjID0ge307XG4gICAgICAgICAgICAgICAgYS5lYWNoKGIuc3BsaXQoL1xccy8pLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY1t0aGlzXSA9ICEwO1xuICAgICAgICAgICAgICAgIH0pLCBiID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9LFxuICAgICAgICBhZGRNZXRob2Q6IGZ1bmN0aW9uKGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGEudmFsaWRhdG9yLm1ldGhvZHNbYl0gPSBjLCBhLnZhbGlkYXRvci5tZXNzYWdlc1tiXSA9IHZvaWQgMCAhPT0gZCA/IGQgOiBhLnZhbGlkYXRvci5tZXNzYWdlc1tiXSwgYy5sZW5ndGggPCAzICYmIGEudmFsaWRhdG9yLmFkZENsYXNzUnVsZXMoYiwgYS52YWxpZGF0b3Iubm9ybWFsaXplUnVsZShiKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmdW5jdGlvbihiLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlcGVuZChkLCBjKSkgcmV0dXJuIFwiZGVwZW5kZW5jeS1taXNtYXRjaFwiO1xuICAgICAgICAgICAgICAgIGlmIChcInNlbGVjdFwiID09PSBjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBhKGMpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrYWJsZShjKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0TGVuZ3RoKGIsIGMpID4gMFxuICAgICAgICAgICAgICAgICAgICA6IGIubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbWFpbDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWwoYikgfHxcbiAgICAgICAgICAgICAgICAgICAgL14oPzooPzooPzpodHRwcz98ZnRwKTopP1xcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0tKikqW2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rKSg/OlxcLig/OlthLXpcXHUwMGExLVxcdWZmZmYwLTldLSopKlthLXpcXHUwMGExLVxcdWZmZmYwLTldKykqKD86XFwuKD86W2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9KSkuPykoPzo6XFxkezIsNX0pPyg/OlsvPyNdXFxTKik/JC9pLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0ZTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8XG4gICAgICAgICAgICAgICAgICAgICEvSW52YWxpZHxOYU4vLnRlc3QobmV3IERhdGUoYSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0ZUlTTzogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC9eXFxkezR9W1xcL1xcLV0oMD9bMS05XXwxWzAxMl0pW1xcL1xcLV0oMD9bMS05XXxbMTJdWzAtOV18M1swMV0pJC8udGVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1iZXI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25hbChiKSB8fFxuICAgICAgICAgICAgICAgICAgICAvXig/Oi0/XFxkK3wtP1xcZHsxLDN9KD86LFxcZHszfSkrKT8oPzpcXC5cXGQrKT8kLy50ZXN0KGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpZ2l0czogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8IC9eXFxkKyQvLnRlc3QoYSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWlubGVuZ3RoOiBmdW5jdGlvbihiLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhLmlzQXJyYXkoYikgPyBiLmxlbmd0aCA6IHRoaXMuZ2V0TGVuZ3RoKGIsIGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGMpIHx8IGUgPj0gZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhsZW5ndGg6IGZ1bmN0aW9uKGIsIGMsIGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGEuaXNBcnJheShiKSA/IGIubGVuZ3RoIDogdGhpcy5nZXRMZW5ndGgoYiwgYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWwoYykgfHwgZSA8PSBkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJhbmdlbGVuZ3RoOiBmdW5jdGlvbihiLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhLmlzQXJyYXkoYikgPyBiLmxlbmd0aCA6IHRoaXMuZ2V0TGVuZ3RoKGIsIGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGMpIHx8IGUgPj0gZFswXSAmJiBlIDw9IGRbMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWluOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWwoYikgfHwgYSA+PSBjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heDogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8IGEgPD0gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYW5nZTogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8IGEgPj0gY1swXSAmJiBhIDw9IGNbMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RlcDogZnVuY3Rpb24oYiwgYywgZCkge1xuICAgICAgICAgICAgICAgIHZhciBlLFxuICAgICAgICAgICAgICAgICAgICBmID0gYShjKS5hdHRyKFwidHlwZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgZyA9IFwiU3RlcCBhdHRyaWJ1dGUgb24gaW5wdXQgdHlwZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIGggPSBbIFwidGV4dFwiLCBcIm51bWJlclwiLCBcInJhbmdlXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgZiArIFwiXFxcXGJcIiksXG4gICAgICAgICAgICAgICAgICAgIGogPSBmICYmICFpLnRlc3QoaC5qb2luKCkpLFxuICAgICAgICAgICAgICAgICAgICBrID0gZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAoXCJcIiArIGEpLm1hdGNoKC8oPzpcXC4oXFxkKykpPyQvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiICYmIGJbMV0gPyBiWzFdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGwgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhICogTWF0aC5wb3coMTAsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbSA9ICEwO1xuICAgICAgICAgICAgICAgIGlmIChqKSB0aHJvdyBuZXcgRXJyb3IoZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPSBrKFxuICAgICAgICAgICAgICAgICAgICBkXG4gICAgICAgICAgICAgICAgKSwgKGsoYikgPiBlIHx8IGwoYikgJSBsKGQpICE9PSAwKSAmJiAobSA9ICExKSwgdGhpcy5vcHRpb25hbChjKSB8fCBtO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVxdWFsVG86IGZ1bmN0aW9uKGIsIGMsIGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGEoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Mub25mb2N1c291dCAmJlxuICAgICAgICAgICAgICAgICAgICBlLm5vdChcIi52YWxpZGF0ZS1lcXVhbFRvLWJsdXJcIikubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInZhbGlkYXRlLWVxdWFsVG8tYmx1clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiYmx1ci52YWxpZGF0ZS1lcXVhbFRvXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEoYykudmFsaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBiID09PSBlLnZhbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW90ZTogZnVuY3Rpb24oYiwgYywgZCwgZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsKGMpKSByZXR1cm4gXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7XG4gICAgICAgICAgICAgICAgZSA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgZSB8fCBcInJlbW90ZVwiO1xuICAgICAgICAgICAgICAgIHZhciBmLCBnLCBoLCBpID0gdGhpcy5wcmV2aW91c1ZhbHVlKGMsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbYy5uYW1lXSA9IHt9KSwgaS5vcmlnaW5hbE1lc3NhZ2UgPSBpLm9yaWdpbmFsTWVzc2FnZSB8fCB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV1bZV0sIHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbYy5uYW1lXVtlXSA9IGkubWVzc2FnZSwgZCA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGQgJiYgeyB1cmw6IGQgfSB8fCBkLCBoID0gYS5wYXJhbShhLmV4dGVuZCh7IGRhdGE6IGIgfSwgZC5kYXRhKSksIGkub2xkID09PSBoID8gaS52YWxpZCA6IChpLm9sZCA9IGgsIGYgPSB0aGlzLCB0aGlzLnN0YXJ0UmVxdWVzdChjKSwgZyA9IHt9LCBnW2MubmFtZV0gPSBiLCBhLmFqYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogXCJ2YWxpZGF0ZVwiICsgYy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGYuY3VycmVudEZvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkLCBnLCBoLCBqID0gYSA9PT0gITAgfHwgXCJ0cnVlXCIgPT09IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV1bZV0gPSBpLm9yaWdpbmFsTWVzc2FnZSwgaiA/IChoID0gZi5mb3JtU3VibWl0dGVkLCBmLnJlc2V0SW50ZXJuYWxzKCksIGYudG9IaWRlID0gZi5lcnJvcnNGb3IoYyksIGYuZm9ybVN1Ym1pdHRlZCA9IGgsIGYuc3VjY2Vzc0xpc3QucHVzaChjKSwgZi5pbnZhbGlkW2MubmFtZV0gPSAhMSwgZi5zaG93RXJyb3JzKCkpIDogKGQgPSB7fSwgZyA9IGEgfHwgZi5kZWZhdWx0TWVzc2FnZShjLCB7IG1ldGhvZDogZSwgcGFyYW1ldGVyczogYiB9KSwgZFtjLm5hbWVdID0gaS5tZXNzYWdlID0gZywgZi5pbnZhbGlkW2MubmFtZV0gPSAhMCwgZi5zaG93RXJyb3JzKGQpKSwgaS52YWxpZCA9IGosIGYuc3RvcFJlcXVlc3QoYywgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSwgXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGIsIGMgPSB7fTtcbiAgICByZXR1cm4gYS5hamF4UHJlZmlsdGVyID8gYS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uKGEsIGIsIGQpIHtcbiAgICAgICAgICAgIHZhciBlID0gYS5wb3J0O1xuICAgICAgICAgICAgXCJhYm9ydFwiID09PSBhLm1vZGUgJiYgKGNbZV0gJiYgY1tlXS5hYm9ydCgpLCBjW2VdID0gZCk7XG4gICAgICAgIH0pIDogKGIgPSBhLmFqYXgsIGEuYWpheCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciBlID0gKFwibW9kZVwiIGluIGQgPyBkIDogYS5hamF4U2V0dGluZ3MpLm1vZGUsXG4gICAgICAgICAgICAgICAgZiA9IChcInBvcnRcIiBpbiBkID8gZCA6IGEuYWpheFNldHRpbmdzKS5wb3J0O1xuICAgICAgICAgICAgcmV0dXJuIFwiYWJvcnRcIiA9PT0gZVxuICAgICAgICAgICAgICAgID8gKGNbZl0gJiYgY1tmXS5hYm9ydCgpLCBjW2ZdID0gYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBjW2ZdKVxuICAgICAgICAgICAgICAgIDogYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KSwgYTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9qcy9saWIvanF1ZXJ5LnZhbGlkYXRlLm1pbi5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBS0E7QUFHQTtBQXpCQTtBQTRCQTtBQVVBO0FBQ0E7QUE3RkE7QUErRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBZUE7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQTNEQTtBQTZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBNUJBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFNQTtBQVVBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBTkE7QUFBQTtBQVNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFKQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFVQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSkE7QUFZQTtBQURBO0FBSUE7QUFEQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQWdDQTtBQVVBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQW5nQkE7QUFxZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBWEE7QUFhQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVRBO0FBY0E7QUFuSEE7QUFwdEJBO0FBMDBCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFHQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function($) {\"use strict\";\n\nvar owl = $(\".js-owl-carousel\").owlCarousel({\n    loop: true,\n    items: 1,\n    navigation: false,\n    autoplay: true,\n    autoplayTimeout: 6000,\n    smartSpeed: 800\n});\n\n$(\".js-owl-prev\").click(function (e) {\n    owl.trigger(\"prev.owl.carousel\");\n});\n\n$(\".js-owl-next\").click(function (e) {\n    owl.trigger(\"next.owl.carousel\");\n});\n\nvar gallery = $(\".js-owl-gallery\").owlCarousel({\n    loop: true,\n    items: 1,\n    navigation: false,\n    smartSpeed: 800\n});\n\n$(\".js-owl-prev\").click(function (e) {\n    gallery.trigger(\"prev.owl.carousel\");\n});\n\n$(\".js-owl-next\").click(function (e) {\n    gallery.trigger(\"next.owl.carousel\");\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvc2xpZGVyLmpzP2QxYzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG93bCA9ICQoXCIuanMtb3dsLWNhcm91c2VsXCIpLm93bENhcm91c2VsKHtcbiAgICBsb29wOiB0cnVlLFxuICAgIGl0ZW1zOiAxLFxuICAgIG5hdmlnYXRpb246IGZhbHNlLFxuICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgIGF1dG9wbGF5VGltZW91dDogNjAwMCxcbiAgICBzbWFydFNwZWVkOiA4MDBcbn0pO1xuXG4kKFwiLmpzLW93bC1wcmV2XCIpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICBvd2wudHJpZ2dlcihcInByZXYub3dsLmNhcm91c2VsXCIpO1xufSk7XG5cbiQoXCIuanMtb3dsLW5leHRcIikuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgIG93bC50cmlnZ2VyKFwibmV4dC5vd2wuY2Fyb3VzZWxcIik7XG59KTtcblxudmFyIGdhbGxlcnkgPSAkKFwiLmpzLW93bC1nYWxsZXJ5XCIpLm93bENhcm91c2VsKHtcbiAgICBsb29wOiB0cnVlLFxuICAgIGl0ZW1zOiAxLFxuICAgIG5hdmlnYXRpb246IGZhbHNlLFxuICAgIHNtYXJ0U3BlZWQ6IDgwMFxufSk7XG5cbiQoXCIuanMtb3dsLXByZXZcIikuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgIGdhbGxlcnkudHJpZ2dlcihcInByZXYub3dsLmNhcm91c2VsXCIpO1xufSk7XG5cbiQoXCIuanMtb3dsLW5leHRcIikuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgIGdhbGxlcnkudHJpZ2dlcihcIm5leHQub3dsLmNhcm91c2VsXCIpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2pzL3NsaWRlci5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);